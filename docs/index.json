[{"content":"아래 이미지는 만든 배너의 모습이다.\nUI리소스는 친구가 만들어줬다..ㅎㅎ\n💚 만들면서 고민한 것들.\n 오브젝트 풀을 사용할 것인가?  게임 배너는 보통 오브젝트 풀을 사용할 만큼 갯수가 많지 않다. 그래서 사용하지 않기로 결정! 후에 인벤토리 같은 기능을 만들어 때 사용해보도록 하자!\n 자동으로 움직이게 해보자!  한쪽 방향으로 움직이는 배너를 구현하였다. 각 배너마다 유저가 정보를 습득할 수 있는 시간 또한 주었다.\n Snap 기능  유저가 스크롤 뷰를 조작해 해당 배너의 위치를 기준으로 일정부분을 움직였다면, 조작을 끝냈을 때 이전 배너, 다음 배너 또는 원래 배너로 다시 positioning!\n 버튼 추가  각 banner로 바로 이동할 수 있는 버튼을 추가! 해당 banner로 이동할 때 바로 보여주는 것이 아닌, 이동 연출을 보여주었다.\n🍑 snap\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  void ScrollSnap(Vector2 value) //ScrollRect.onValueChanged.AddListener(ScrollSnap)에 추가해줌. { //유저가 스크롤을 조작하고 있는 경우 or 오토무브가 가능한 경우 or 배너가 움직이는 중일 경우(버튼 조작으로)  if (BannerScrollRect.isOnDown || isAbleAutoMove || isBannerMoving) { return; } if (value.x \u0026gt; points[curBannerIndex]) //오른쪽 snap  { if (value.x \u0026gt;= points[curBannerIndex] + snapRange) { var nextIndex = curBannerIndex + 1 \u0026gt;= datas.Length ? 0 : curBannerIndex + 1; MoveBannerByIndex(nextIndex);//해당인덱스로 이동  } else { MoveBannerByIndex(curBannerIndex); } } else //왼쪽 snap  { if (value.x \u0026lt;= points[curBannerIndex] - snapRange) { var prevIndex = curBannerIndex - 1 \u0026lt; 0 ? 0 : curBannerIndex - 1; MoveBannerByIndex(prevIndex); } else { MoveBannerByIndex(curBannerIndex); } } }   🍑 배너 이동 코루틴\n이전에 포스팅했던 타이머를 활용해보자!!\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  IEnumerator CoMoveBanner(int index) { curBannerIndex = index; indexButtons[curBannerIndex].SelectWithoutNotify(true); var timer = 0f; var startPoint = BannerScrollRect.ScrollRect.horizontalNormalizedPosition; while (timer \u0026lt; duration) //duration 동안 이동  { timer += Time.deltaTime; //스크롤 포인트 조절! lerp를 사용하여 부드럽게 이동시키자!  BannerScrollRect.ScrollRect.horizontalNormalizedPosition = Mathf.Lerp(startPoint, points[index], ease.Evaluate(timer / duration)); yield return null; } isAbleAutoMove = true;//오토무브 가능으로 변경  isBannerMoving = false;//배너 움직임이 끝났음을 알림  autoTimer = 0; //무브를 조작했다면 오토무브 타이머를 초기화 }   ","permalink":"https://qutrits.github.io/posts/dummy/studying15_snap/","summary":"아래 이미지는 만든 배너의 모습이다.\nUI리소스는 친구가 만들어줬다..ㅎㅎ\n💚 만들면서 고민한 것들.\n 오브젝트 풀을 사용할 것인가?  게임 배너는 보통 오브젝트 풀을 사용할 만큼 갯수가 많지 않다. 그래서 사용하지 않기로 결정! 후에 인벤토리 같은 기능을 만들어 때 사용해보도록 하자!\n 자동으로 움직이게 해보자!  한쪽 방향으로 움직이는 배너를 구현하였다. 각 배너마다 유저가 정보를 습득할 수 있는 시간 또한 주었다.\n Snap 기능  유저가 스크롤 뷰를 조작해 해당 배너의 위치를 기준으로 일정부분을 움직였다면, 조작을 끝냈을 때 이전 배너, 다음 배너 또는 원래 배너로 다시 positioning!","title":"배너를 만들어보자!"},{"content":"알고리즘 문제는 github에 repository를 만든 후에 포스팅하지않으려고 했는데, 이 문제는 공유해서 올리면 좋을거 같아서 올렸다!! 오랜만에\u0026hellip;ㅎㅎ\n알고리즘 공부 백준 2667 🧐 제로 👉문제 \u0026lt;그림 1\u0026gt;과 같이 정사각형 모양의 지도가 있다. 1은 집이 있는 곳을, 0은 집이 없는 곳을 나타낸다. 철수는 이 지도를 가지고 연결된 집의 모임인 단지를 정의하고, 단지에 번호를 붙이려 한다. 여기서 연결되었다는 것은 어떤 집이 좌우, 혹은 아래위로 다른 집이 있는 경우를 말한다. 대각선상에 집이 있는 경우는 연결된 것이 아니다. \u0026lt;그림 2\u0026gt;는 \u0026lt;그림 1\u0026gt;을 단지별로 번호를 붙인 것이다. 지도를 입력하여 단지수를 출력하고, 각 단지에 속하는 집의 수를 오름차순으로 정렬하여 출력하는 프로그램을 작성하시오.\n👉입력 첫 번째 줄에는 지도의 크기 N(정사각형이므로 가로와 세로의 크기는 같으며 5≤N≤25)이 입력되고, 그 다음 N줄에는 각각 N개의 자료(0혹은 1)가 입력된다.\n👉출력 첫 번째 줄에는 총 단지수를 출력하시오. 그리고 각 단지내 집의 수를 오름차순으로 정렬하여 한 줄에 하나씩 출력하시오.\n🍑풀이\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102  namespace Algorithm19 { class Baekjoon2667 { static void Main(string[] args) { char house = \u0026#39;1\u0026#39;; char visitedHouse = \u0026#39;2\u0026#39;; int N = int.Parse(Console.ReadLine()!); var arr = new char[N,N]; var list = new char[N]; for (int i = 0; i \u0026lt; N; i++) { list = Console.ReadLine()!.ToCharArray(); for (int j = 0; j \u0026lt; N; j++) { arr[i,j] = list[j]; } } List\u0026lt;int\u0026gt; countList = new List\u0026lt;int\u0026gt;(); int c = 0; for (int r= 0; r \u0026lt; N; r++) { for (; c \u0026lt; N; c++) { if (arr[r, c] != house) { continue; } countList.Add(DFS(r, c)); } c = 0; } Console.WriteLine(countList.Count); countList.Sort(); for (int i = 0; i \u0026lt; countList.Count; i++) { Console.WriteLine(countList[i]); } int DFS(int r, int c) { int cnt = 0; if (arr[r, c] == house) { arr[r, c] = visitedHouse; cnt++; } //방법1  if (r + 1 \u0026lt; N \u0026amp;\u0026amp; arr[r + 1, c] == house) //오른쪽  { cnt += DFS(r + 1, c); } if (r - 1 \u0026gt;= 0 \u0026amp;\u0026amp; arr[r - 1, c] == house) //왼쪽  { cnt += DFS(r - 1, c); } if (c - 1 \u0026gt;= 0 \u0026amp;\u0026amp; arr[r, c - 1] == house) //아래쪽  { cnt += DFS(r, c - 1); } if (c + 1 \u0026lt; N \u0026amp;\u0026amp; arr[r, c + 1] == house) //위쪽  { cnt += DFS(r, c + 1); } //방법2  //상하좌우(4 Way) 움직임..  int[] dx = {0, 1, 0, -1}; int[] dy = {1, 0, -1, 0}; for(int d = 0; d \u0026lt; 4; d++) // 상하좌우 탐색  { int nX = x + dx[d]; // 새로운 x좌표  int nY = y + dy[d]; // 새로운 y좌표  if(nX \u0026lt; 0 || nX \u0026gt;= N || nY \u0026lt; 0 || nY \u0026gt;= N) // Out of Bound 체크 - 맵의 경계를 넘어가나 체크하는 것이다.  { continue; } if(board[nX, nY] == house) // 새로 이동할 위치에 아파트 건물이 있고, 아직 방문하지 않은 정점이라면  { DFS(nX, nY); // 이 위치에서 DFS 호출  } } return cnt; } } } }   문제풀러가기\n","permalink":"https://qutrits.github.io/posts/dummy/algorithm19_2667/","summary":"알고리즘 문제는 github에 repository를 만든 후에 포스팅하지않으려고 했는데, 이 문제는 공유해서 올리면 좋을거 같아서 올렸다!! 오랜만에\u0026hellip;ㅎㅎ\n알고리즘 공부 백준 2667 🧐 제로 👉문제 \u0026lt;그림 1\u0026gt;과 같이 정사각형 모양의 지도가 있다. 1은 집이 있는 곳을, 0은 집이 없는 곳을 나타낸다. 철수는 이 지도를 가지고 연결된 집의 모임인 단지를 정의하고, 단지에 번호를 붙이려 한다. 여기서 연결되었다는 것은 어떤 집이 좌우, 혹은 아래위로 다른 집이 있는 경우를 말한다. 대각선상에 집이 있는 경우는 연결된 것이 아니다.","title":"AlgorithmStudy_백준 2667"},{"content":"면접에서 받았던 퀴즈였다.\n 주사위 하나로 1~18를 같은 확률로 어떻게 하면 표현할 수 있을까?\n 면접 당시 나는 사칙연산에 빠져서 답을 도출해내지 못하였다.\n하지만, 웬걸 집에가서 다시 생각해보니 바로 답이 떠오르지 않겠는가?ㅠㅠㅠ 너무 아쉽다.\n🧐 나의 해답 🧐\n 1회 주사위를 굴린다. 이때, 4 -\u0026gt; 1, 5 -\u0026gt; 2, 6 -\u0026gt; 3 으로 간주한다. 2회째 주사위를 굴린다. 첫 주사위가 1이라면, 1 ~ 6 의 값을, 2라면, 7 ~ 12의 값을, 3이었다면, 13 ~18의 값을 가질 수 있다.\n 1 ~ 18 사이의 모든 값은 동일한 확률로 나온다!  ","permalink":"https://qutrits.github.io/posts/dummy/interview1/","summary":"면접에서 받았던 퀴즈였다.\n 주사위 하나로 1~18를 같은 확률로 어떻게 하면 표현할 수 있을까?\n 면접 당시 나는 사칙연산에 빠져서 답을 도출해내지 못하였다.\n하지만, 웬걸 집에가서 다시 생각해보니 바로 답이 떠오르지 않겠는가?ㅠㅠㅠ 너무 아쉽다.\n🧐 나의 해답 🧐\n 1회 주사위를 굴린다. 이때, 4 -\u0026gt; 1, 5 -\u0026gt; 2, 6 -\u0026gt; 3 으로 간주한다. 2회째 주사위를 굴린다. 첫 주사위가 1이라면, 1 ~ 6 의 값을, 2라면, 7 ~ 12의 값을, 3이었다면, 13 ~18의 값을 가질 수 있다.","title":"면접 퀴즈"},{"content":"가비지 컬렉션가 뭐야? 🧐 게임이 실행이 될 때, 메모리를 데이터를 저장하기 위해 사용을 한다. 메모리엔 코드(실행할코드), 데이터(전역변수, 정적변수), 스택메모리(값타입/지역변수)와 힙메모리(사용자동적할당역역/레퍼런스타입)가 있는데, 가비지 컬렉터는 힙메모리를 청소하는 역할이다.\n그렇다면 왜 스택메모리를 청소해주는 것은 없을까? 필요없기 때문이다. 스택메모리에 저장되는 데이터들은 스코프를 벗어나면 메모리가 즉시 해제가된다. 이와 반면에 힙메모리는 스코프를 벗어나도 즉시 메모리 해제가 이루어지지않는다. 힙메모리에서 사용하지않는, 불필요한 메모리들을 정리해 다시 사용이 가능하도록 작업하는 것이 바로 가비지 컬렉션이다.\n힙 변수생성할 때 무슨 일이 일어날까? 🧐  힙공간에 사용가능한 메모리가 있는지, 변수를 할당할 수 있을 지 확인한다. 만약 없다면, 유니티는 가비지 컬렉터 작동을 시켜 메모리가 생기면 변수를 할당한다. 가비지 컬렉터 실행 후에도 메모리가 없을 경우에는 힙공간을 늘린 후 변수를 할당한다.  가비지 컬렉션이 진행될 때 무슨 일이 일어날까? 🧐  힙메모리에 있는 모든 오브젝트들을 조사. 모든 오브젝트들의 레퍼런스를 조사하여 현재 힙메모리에 있는 오브젝트가 스코프에 남아있는지 확인한다. 더 이상 스코프 안에 있지 않은 오브젝트들을 마크한다. 마크된 오브젝트를 메모리해제하여 메모리를 다시 사용할 수 있는 상태로 만든다.  가비지 컬렉터가 작동해야하는 상황, 유니티가 힙공간을 늘려야하는 상황 모두 성능의 저하를 가져온다.\n가비지 컬렉션는 언제 작동할까? 🧐  힙메모리 할당을 요청 받았을 때, 할당이 불가능한 경우.(메모리 자체의 부족 또는 메모리 단편화 상태) 가비지 컬렉터는 자동적으로 작동을 한다.(플랫폼에 따라 작동 횟수는 다양함) 강제로도 작동시킬 수 있지만 권장하지 않는다.(비용이 많이 든다!)  가비지 컬렉션의 문제점은? 🧐  비용이 많이 든다.(어떤 메모리를 청소해야할지 찾는 데에 시간이 듬) 어떠한 타이밍에 실행될지 모른다.(ex. cpu가 게임에서 중요한 부분을 작업하는데 가비지 컬렉션이 일어나면 아무리 작은 추가 오버헤드일지라도 프레임 드랍을 일으킬 수 있다.) 메모리 단편화 문제!  가비지를 줄이려면? 🧐  캐싱: 반복적으로 호출하여 할당하지만 그 결과가 버려지는 오브젝트들을 캐싱해두고 다시 사용하자. 자주 사용되는 함수에서 힙 할당을 자제하자.(update 같은 함수) Collection사용시 Clear()해서 재사용하기.(캐싱해서 사용해라~ new로 새로 만들지 말고!) 런타임에 많은 오브젝트들을 생성하고 파괴하기 보다는 오브젝트 풀링 이용. string 사용에 주의하자! immutable, reference type 이기 때문에 string으로 조작할 때마다 이전 string은 가비지가 됨. Debug.Log() 는 디버깅할 상황이 끝나면 바로바로 지워주자! GameObject.name, GameObject.tag 같은 경우는 새로운 string을 만들어 return 해주기 때문에 GameObject.CompareTag()같은 함수를 대신 적극 이용하는 것이 좋다. 코루틴을 사용할때도 유의해야한다. yield return 시 new 키워드를 반복사용해야한다면 캐싱해놓고 사용하자.  이외에도 더 많은 줄일 수 있는 방법들이 있다.\n참고 링크\n","permalink":"https://qutrits.github.io/posts/dummy/studying14_gc/","summary":"가비지 컬렉션가 뭐야? 🧐 게임이 실행이 될 때, 메모리를 데이터를 저장하기 위해 사용을 한다. 메모리엔 코드(실행할코드), 데이터(전역변수, 정적변수), 스택메모리(값타입/지역변수)와 힙메모리(사용자동적할당역역/레퍼런스타입)가 있는데, 가비지 컬렉터는 힙메모리를 청소하는 역할이다.\n그렇다면 왜 스택메모리를 청소해주는 것은 없을까? 필요없기 때문이다. 스택메모리에 저장되는 데이터들은 스코프를 벗어나면 메모리가 즉시 해제가된다. 이와 반면에 힙메모리는 스코프를 벗어나도 즉시 메모리 해제가 이루어지지않는다. 힙메모리에서 사용하지않는, 불필요한 메모리들을 정리해 다시 사용이 가능하도록 작업하는 것이 바로 가비지 컬렉션이다.\n힙 변수생성할 때 무슨 일이 일어날까? 🧐  힙공간에 사용가능한 메모리가 있는지, 변수를 할당할 수 있을 지 확인한다.","title":"GarbageCollection: 가비지 컬렉션"},{"content":"🍑 타이머\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  public class Timer : MonoBehaviour { private Coroutine curTimer; public void StartTimer(int time, Action\u0026lt;float\u0026gt; onValueChanged) { //진행되던 타이머가 있다면 멈추고 새로 시작  if (curTimer != null) { StopCoroutine(curTimer); } curTimer = StartCoroutine(CoStartTimer(time, onValueChanged)); } //타이머를 진행할 시간, 시간이 바뀔때마다 어떠한 행동을할건지  IEnumerator CoStartTimer(int time, Action\u0026lt;float\u0026gt; onValueChanged) { float timer = 0; while (true) { //타이머가 지정된 시간을 넘기면 break!  if (timer \u0026gt;= time) { break; } //시간을 더해주자!  timer += Time.deltaTime; yield return null; //남은 시간을 보내주기  onValueChanged(time - timer); } //타이머가 끝나면 코루틴을 null  curTimer = null; } }   💚 deltaTime 사용 이유!\n 지난 프레임이 완료되는 데 까지 걸린 시간을 나타내며, 단위는 초를 사용합니다.(읽기전용)\n사용자의 프레임 률(frame rate)을 독립적으로 적용하기 위해서 사용합니다.\n 즉! 사용자의 각자 프레임률이 다르기 때문에 프레임 카운트로 타이머를 만든다면 각 사용자의 타이머는 시간이 모두 다르다.\n하지만 deltaTime을 쓴다면, 같은 결과값을 얻을 수 있다!\n여기서, 매 프레임마다 실행되는 update와 달리 coroutine을 사용했는데 내용이 적용이 될까? 라는 의문이 들 수 있다. yield return null 을 사용함으로 update바로 다음에 실행이 되도록 하였다! 즉, update에서 사용하는 것과 동일하게 사용이 가능하다.\n🍑 스킬아이콘\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91  public class SpellIcon : MonoBehaviour { //연출에 사용할 커브! [SerializeField] private AnimationCurve ease; //스킬 아이콘 이미지  private Image img_icon; //쿨타임이 돌 때 이미지(딤드)  private Image img_cooltime; //쿨타임을 표시해 줄 텍스트  private Text txt_timer; //타이머를 가지고 있자!  private Timer timer; //임시 쿨타임 적용  private int cooltime = 5; private void Awake() { foreach (var img in GetComponentsInChildren\u0026lt;Image\u0026gt;()) { if (img.name == \u0026#34;Image_Spell\u0026#34;) { img_icon = img; } else if (img.name == \u0026#34;Image_CoolTime\u0026#34;) { img_cooltime = img; } } var btn = img_icon.gameObject.AddComponent\u0026lt;Button\u0026gt;(); btn.onClick.AddListener(OnClickSpell); timer = GetComponent\u0026lt;Timer\u0026gt;(); txt_timer = GetComponentInChildren\u0026lt;Text\u0026gt;(); } //바깥에서 불러줘야해!  //useAble : 바로 사용이 가능한지?  public void Initialize(Sprite sprite, int cooltime, bool useAble = true) { img_icon.sprite = sprite; this.cooltime = cooltime; //바로사용이 불가능하다면 쿨타임을 실행!  OnTimeChanged(useAble ? cooltime : 0); } void UseSpell() { img_cooltime.raycastTarget = true; timer.StartTimer(cooltime, OnTimeChanged); } void OnClickSpell() { //어디론가 보내서 스킬을 발동되도록 해야겠지 ?  Debug.Log(\u0026#34;아 스킬 발동ㅋ\u0026#34;); ClickAnimation();//연출!  UseSpell(); } void ClickAnimation() { //클릭시 커졌다가 다시 돌아오는 핑퐁형태의 연출을 추가!  transform.Scale(Vector3.one, Vector3.one * 1.1f, 0.1f).SetEase(ease,true).Play(); } //타임이 변경될 때 마다 업데이트를 시켜줌  void OnTimeChanged(float time) { UpdateCooltimeImage(time); UpdateTimerText(time); } void UpdateCooltimeImage(float time) { if (time \u0026lt;= 0) { //쿨타임이 끝났으니 아이콘을 누를 수 있도록 해당 이미지를 raycastTarget을 꺼줌.  img_cooltime.raycastTarget = false; } if (cooltime \u0026gt; 0) { img_cooltime.fillAmount = time / cooltime; } else { img_cooltime.fillAmount = 0; } } void UpdateTimerText(float time) { txt_timer.text = time \u0026lt;= 0 ? string.Empty : txt_timer.text = Math.Ceiling(time).ToString(); } }   스킬 아이콘을 초기화해주고 정보를 넣어주는 것은 원래 해당 클래스 바깥에서 관리를 해주어야 할 것이다.\n이 스킬 아이콘들의 상태를 관리하고 이벤트들을 실제로 사용하는 곳으로 전달하는 역할의 매니저 클래스가 필요하다. 다음에 이 클래스를 관리하는 클래스도 추가해보겠다.\n이 클래스는 실 데이터(스킬의 데미지, 타겟, 효과 등\u0026hellip;)를 다루거나 그 데이터를 기반으로 행위를 하는 것보다 사용자의 눈에 보여지는 부분만 처리하기 위해 존재한다.(UI적 부분만)\n","permalink":"https://qutrits.github.io/posts/dummy/studying13_timer/","summary":"🍑 타이머\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  public class Timer : MonoBehaviour { private Coroutine curTimer; public void StartTimer(int time, Action\u0026lt;float\u0026gt; onValueChanged) { //진행되던 타이머가 있다면 멈추고 새로 시작  if (curTimer != null) { StopCoroutine(curTimer); } curTimer = StartCoroutine(CoStartTimer(time, onValueChanged)); } //타이머를 진행할 시간, 시간이 바뀔때마다 어떠한 행동을할건지  IEnumerator CoStartTimer(int time, Action\u0026lt;float\u0026gt; onValueChanged) { float timer = 0; while (true) { //타이머가 지정된 시간을 넘기면 break!","title":"타이머를 이용해 스킬아이콘을 만들어보자!"},{"content":"애니메이션 커브에 대해서 조금 더 알 수 있었던 핑퐁 기능 만들기였다.\n🍑 핑퐁 기능 추가!!!!\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  public static Tween SetEase(this Tween tween, AnimationCurve ease, bool pingpong = false) //ping pong: 다시 돌아오는 형태의 애니메이션 { if (!tween.IsPlaying) //트윈이 플레이 중이지 않을 때 수정!  { if (pingpong)//핑퐁을 한다면  { Keyframe[] keyframes = new Keyframe[ease.length]; //애니메이션 커브의 키 프레임만큼 키프레임 배열 생성  for (int i = 0; i \u0026lt; ease.length; i++) { //일대일 매칭을 해서  keyframes[i] = ease.keys[i]; //정해진 기간내에 from으로 와야함.  //반절은 to로 반절은 from로 가야하기때문에 2로 나누어 줌!  keyframes[i].time = keyframes[i].time / 2; } //새로운 커브를 생성해 이전 ease와 교체  ease = new AnimationCurve(keyframes); //핑퐁으로 모드를 변경!  ease.postWrapMode = WrapMode.PingPong; } tween.Ease = ease; } else { Debug.Log(\u0026#34;tween is playing\u0026#34;); } return tween; }   💚 ease.Evaluate(time / duration) 를 통해서 총 애니메이션 기간에 대한 현재 애니메이션 타임의 값을 ease에서 얻을 수 있다. 이 값을 대상이 Transform(position, scale, rotate)이든지 MaskAbleGraphic(color, alpha), CanvasGroup(alpha)이든지 간에 값을 정해줄 수 있다.\n나중에 애니메이션커브만 따로 포스팅을 해보겠다!\n","permalink":"https://qutrits.github.io/posts/dummy/studying12_tweenmaking/","summary":"애니메이션 커브에 대해서 조금 더 알 수 있었던 핑퐁 기능 만들기였다.\n🍑 핑퐁 기능 추가!!!!\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  public static Tween SetEase(this Tween tween, AnimationCurve ease, bool pingpong = false) //ping pong: 다시 돌아오는 형태의 애니메이션 { if (!tween.IsPlaying) //트윈이 플레이 중이지 않을 때 수정!","title":"Tween 만들기 프로젝트 근황"},{"content":"상속이 뭐야? 🧐 상속은 확장의 개념이다. 추상클래스, 일반클래스 모두 상속을 통해 특정 객체의 개념을 확장시킬 수 있다.(인터페이스의 경우 기능확장이라는 말이 좀 더 어울리는 것 같다.) 인터페이스와 추상클래스는 이전 포스트에서 다루었으니 일반클래스를 예시로 들겠다.\n💚 예시\n오크라는 객체가 있다고 하자. 이 오크라는 객체는 마법사 오크가 될수도, 전사 오크, 궁수 오크 등이 될 수 있다. 이런 오크들을 구현할 때 상속을 사용한다. 직업이 있는 오크 모두 하나의 오크라는 객체를 상속받을 수 있는 것이다. 일반클래스의 상속은 추상클래스나 인터페이스를 상속받는 것과 다르게 부모클래스도 인스턴스할 수 있다. 즉, 아무렂 직업이 없는 일반 오크(부모클래스)도 존재할 수 있고, 이 오크를 기반으로 다양한 직업을 가진 오크(자식클래스)도 존재할 수 있다.\n🍑 위의 내용을 바탕으로 코드를 만들어 보자!\n🍑 일반클래스, 추상클래스, 인터페이스 모두 활용해보자!\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122  public abstract class Monster //몬스터라는 분류! { private int maxHp; private int maxMp; private int hp; private int mp; private bool isAbleSkill; public bool IsAbleSkill { get =\u0026gt; mp \u0026gt; 0; private set =\u0026gt; isAbleSkill = value; } private bool IsAlive=\u0026gt; hp \u0026gt; 0; public int Hp { get =\u0026gt; hp; set { var _hp = hp + value; if (_hp \u0026gt; maxHp) { hp = maxHp; } else if (_hp \u0026lt;= 0) { Die(); } else { hp = _hp; } } } public int Mp { get =\u0026gt; mp; set { var _mp = mp + value; if (_mp \u0026gt; maxMp) { mp = maxMp; } else if (_mp \u0026lt;= 0) { mp = 0; } else { mp = _mp; } } } protected Monster(int maxHp, int maxMp)//abstract 클래스의 생성자는 항상 protected로!  { this.maxHp = maxHp; this.maxMp = maxMp; hp = maxHp; mp = maxMp; } public abstract void UseSkill(); public abstract void Die(); public void SetEnableUseSkill(bool able) { isAbleSkill = able; } } public class Orc : Monster { public override void UseSkill() { if (IsAbleSkill) { Skill(); } } public Orc(int maxHp, int maxMp) : base(maxHp,maxMp) { } protected virtual void Skill() { Console.WriteLine(\u0026#34;일반오크 스킬 발동!\u0026#34;); } public override void Die() { Console.WriteLine(\u0026#34;오크 죽음!\u0026#34;); } } public class WizardOrc : Orc, IFly { public WizardOrc(int maxHp, int maxMp) : base(maxHp,maxMp) { } protected override void Skill() //부모의 함수를 오버라이딩 하여 자신에게 알맞은 함수를 실행함  { Console.WriteLine(\u0026#34;마법사 오크 스킬 발동!\u0026#34;); } public void Fly() { Console.WriteLine(\u0026#34;휘익~ 마법사 오크 난다!\u0026#34;); } } public class KnightOrc : Orc { public KnightOrc(int maxHp, int maxMp) : base(maxHp,maxMp) { } protected override void Skill() { Console.WriteLine(\u0026#34;전사오크 스킬 발동!\u0026#34;); } } public class ArcherOrc : Orc { public ArcherOrc(int maxHp, int maxMp) : base(maxHp,maxMp) { } protected override void Skill() { Console.WriteLine(\u0026#34;궁수오크 스킬 발동!\u0026#34;); } }   상속의 특징은? 🧐  자식클래스가 부모클래스의 필드와 메소드를 모두 가지고 있다. 부모클래스에서 private으로 선언되어있는 요소들은 자식클래스라도 접근이 불가능하다.(가지고는 있음!) 부모클래스에서 protected로 선언되어있는 요소는 자식클래스만 접근이 가능하다. 부모클래스이 메소드를 virtual/override 를 통해 자식클래스에서 재정의 할 수 있다. interface를 제외한 모든 상속은 다중상속이 불가능하다.  ","permalink":"https://qutrits.github.io/posts/dummy/studying11_inheritance/","summary":"상속이 뭐야? 🧐 상속은 확장의 개념이다. 추상클래스, 일반클래스 모두 상속을 통해 특정 객체의 개념을 확장시킬 수 있다.(인터페이스의 경우 기능확장이라는 말이 좀 더 어울리는 것 같다.) 인터페이스와 추상클래스는 이전 포스트에서 다루었으니 일반클래스를 예시로 들겠다.\n💚 예시\n오크라는 객체가 있다고 하자. 이 오크라는 객체는 마법사 오크가 될수도, 전사 오크, 궁수 오크 등이 될 수 있다. 이런 오크들을 구현할 때 상속을 사용한다. 직업이 있는 오크 모두 하나의 오크라는 객체를 상속받을 수 있는 것이다. 일반클래스의 상속은 추상클래스나 인터페이스를 상속받는 것과 다르게 부모클래스도 인스턴스할 수 있다.","title":"inheritance: 상속"},{"content":"오늘은 추상 클래스에 대해 알아보쟈!\nabstract class(추상클래스)가 뭐야? 🧐 인터페이스가 Can Do를 알려주는 역할이라면 추상클래스는 분류(category)를 알려주는 클래스다.\n💚 예시 (내가 이해한 방식) 인터페이스에서 이야기했던 예시를 이어가자면, 앵무새와 참새, 펭귄 그리고 슈가 글라이더는 각자 객체를 가질 수 있다. 하지만 앵무새,참새 그리고 펭귄을 포함하는 조류, 슈가 글라이더를 포함하는 포유류라는 것은 객체가 없는, 추상적인 분류(category)의 개념이다. 추상클래스 안에 추상메소드는 인터페이스와 같은 역할이라고 생각하면된다. 즉, \u0026ldquo;이러한 분류(추상클래스)에 속하는 객체들은 이러한(추상메소드)것에 반드시 반응해야한다.\u0026rdquo; 라는 계약이 생긴다.\n🍑 위의 내용을 추가로 코드를 수정해보자\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  public abstract class Animal//동물이라는 카테고리를 표현 { private bool isAlive = true;//추상클래스는 필드를 가질 수 있다.  public abstract void Eat();//추상메소드: 자식클래스에서 모두 구현을 해주어야함!  public virtual void Die()//일반 메소드: 추상클래스는 일반 메소드 또한 가질 수 있다.  { isAlive = false; } } public abstract class Birds : Animal//동물이라는 카테고리 속 조류라는 카테고리 { protected Birds(Beak beak) { this.beak = beak; } public Beak beak { get; private set; } } public class Sparrow : Birds, IFly//조류에 속하는 참새 객체 { public Sparrow(Beak beak) : base(beak) { } public void Fly() { Console.WriteLine(\u0026#34;포로록~ 참새 난다~\u0026#34;); } public override void Eat() { Console.WriteLine(\u0026#34;참새 쌀알 먹는다. 콕콕!\u0026#34;); } } public class Parrot : Birds, IFly//조류에 속하는 앵무새 객체 { public Parrot(Beak beak) : base(beak) { } public void Fly() { Console.WriteLine(\u0026#34;푸드덕~ 앵무새 난다~\u0026#34;); } public override void Eat() { Console.WriteLine(\u0026#34;츄릅~ 앵무새 메뚜기 먹는다!\u0026#34;); } }   abstract class(추상클래스)의 특징은? 🧐  클래스 안에 추상메소드가 하나라도 존재한다면, 그 클래스는 반드시 추상클래스여야한다. 추상클래스: abstract class [\u0026quot;클래스 이름\u0026quot;], 추상메소드: abstract [\u0026quot;반환타입\u0026quot;] [\u0026quot;메소드 이름\u0026quot;]( [\u0026quot;파라미터\u0026quot;] )로 표현한다. 추상메소드는 내부가 구현되지않은 상태여야한다. (이전에 포스팅했던 인터페이스가 추상메소드만으로만 이루어진 것) 접근한정자를 정해주지않으면 private 디폴트 값이다. 필드와 일반메소드 모두 가지고 있을 수 있다.(인터페이스와 가장 큰 차이점 중 하나) 다른 일반 클래스와 마찮가지로 다중상속이 불가능하다. 인터페이스와 마찮가지로 인스턴스가 불가능하다.  ** 다음 포스팅은 일반 클래스와 상속에 대해서 다루겠다!\n","permalink":"https://qutrits.github.io/posts/dummy/stuying10_abstract/","summary":"오늘은 추상 클래스에 대해 알아보쟈!\nabstract class(추상클래스)가 뭐야? 🧐 인터페이스가 Can Do를 알려주는 역할이라면 추상클래스는 분류(category)를 알려주는 클래스다.\n💚 예시 (내가 이해한 방식) 인터페이스에서 이야기했던 예시를 이어가자면, 앵무새와 참새, 펭귄 그리고 슈가 글라이더는 각자 객체를 가질 수 있다. 하지만 앵무새,참새 그리고 펭귄을 포함하는 조류, 슈가 글라이더를 포함하는 포유류라는 것은 객체가 없는, 추상적인 분류(category)의 개념이다. 추상클래스 안에 추상메소드는 인터페이스와 같은 역할이라고 생각하면된다. 즉, \u0026ldquo;이러한 분류(추상클래스)에 속하는 객체들은 이러한(추상메소드)것에 반드시 반응해야한다.\u0026rdquo; 라는 계약이 생긴다.","title":"abstract class: 추상클래스"},{"content":"interface(인터페이스)가 뭐야? 🧐 나는 인터페이스을 기능들의 묶음이라고 이해했다.\nCan Do를 알려주는 역할을 한다.\ninterface(인터페이스)는 어떤 상황에서 사용해야할까? 🧐 💚 예시\n만약 조류라는 클래스가 있다고 하자.\n이 클래스를 상속 받는 참새와 앵무새 파생 클래스가 있다. 새는 날 수 있으니까 Fly()를 조류 클래스에 추가를 했다.\n하지만 이후에 펭귄과 슈가글라이더를 만들어달라는 요청을 받았다. 하지만 생각해보니 펭귄은 날 수 없는데 슈가글라이더는 조류가 아닌데도 날 수 있지않은가?\n이렇게 같은 부모 클래스를 가지고 있지않음에도 수행할 수 있는 기능은 같은 경우(슈가글라이더) 또는 같은 클래스를 상속을 받았지만 그 클래스의 기능이 필요하지 않는 경우가 있다(펭귄).\n이런 경우에 사용해야 할 것이 interface이다. 즉, 인터페이스는 어떠한 기능을 수행할 수 있는지 알려주는 역할을 하는 것이다. Can Do!\n🍑 위의 설명을 코드로 만들어 보자!\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  public interface IFly { void Fly(); } public abstract class Birds : Animal { protected Birds(Beak beak) { this.beak = beak; } public Beak beak { get; private set; } } public class Sparrow : Birds, IFly { public void Fly() { Console.WriteLine(\u0026#34;포로록~ 참새 난다~\u0026#34;); } public Sparrow(Beak beak) : base(beak) { } } public class Parrot : Birds, IFly { public void Fly() { Console.WriteLine(\u0026#34;푸드덕~ 앵무새 난다~\u0026#34;); } public Parrot(Beak beak) : base(beak) { } } public class Penguin : Birds, ISwim { public void Swim() { Console.WriteLine(\u0026#34;슈슉~ 펭귄 수영한다~\u0026#34;); } public Penguin(Beak beak) : base(beak) { } } public class SugarGlider : Mammalia, IFly { public void Fly() { Console.WriteLine(\u0026#34;슝~ 슈가 글라이더 난다~\u0026#34;); } }   interface(인터페이스)의 특징은? 🧐  내부를 구체화 하지않은 메소드만으로 이루워져있다. 인스턴스가 불가능하다.: 다른 일반 클래스처럼 new로 인스턴스화 할 수 없다. 반드시 상속을 통해 사용해야한다. 다중 상속이 가능하다! 인터페이스를 상속한 클래스는 반드시 인터페이스 안의 모든 메소드를 구체화 해야한다. 접근 한정자가 항상 public이다. 내부 메소드 또한 public으로 구현이된다.  ** 다음 포스팅은 abstract class에 대해서 공부해보도록 하겠당~\n","permalink":"https://qutrits.github.io/posts/dummy/studying9_interface/","summary":"interface(인터페이스)가 뭐야? 🧐 나는 인터페이스을 기능들의 묶음이라고 이해했다.\nCan Do를 알려주는 역할을 한다.\ninterface(인터페이스)는 어떤 상황에서 사용해야할까? 🧐 💚 예시\n만약 조류라는 클래스가 있다고 하자.\n이 클래스를 상속 받는 참새와 앵무새 파생 클래스가 있다. 새는 날 수 있으니까 Fly()를 조류 클래스에 추가를 했다.\n하지만 이후에 펭귄과 슈가글라이더를 만들어달라는 요청을 받았다. 하지만 생각해보니 펭귄은 날 수 없는데 슈가글라이더는 조류가 아닌데도 날 수 있지않은가?\n이렇게 같은 부모 클래스를 가지고 있지않음에도 수행할 수 있는 기능은 같은 경우(슈가글라이더) 또는 같은 클래스를 상속을 받았지만 그 클래스의 기능이 필요하지 않는 경우가 있다(펭귄).","title":"interface: 인터페이스"},{"content":"음\u0026hellip; ㅋㅋ 면접보고 왔는데 bfs/dfs의 장단점을 물어보셨다.\n나는 뭔지만 공부했고 구현해보는 데에만 집중한 나머지 장단점이 뭔지 궁금해하지 않았다는 사실\u0026hellip;!😱\n그래서 오늘 공부해보려고 한다.\nBFS의 장단점? 🧐  장점   경로가 여러 개인 경우에도 최적해를 보장한다. 최단 경로가 존재한다면 최적해를 찾을 수 있다. 왜?: 한 노드의 자식들을 모두 탐색하기 때문에.  단점   노드의 수가 많아지면 탐색해야하는 노드의 수도 많아진다.  DFS의 장단점? 🧐  장점   최선의 경우 가장 빠름.  단점   답이 아닌 경로가 깊다면 해를 구하는 데에 오래 걸린다. 왜?: 다시 돌아와서 탐색해야하기 때문에.  💚 딱히 장단점은 중요하지 않은 것 같다. 최단 경로 찾기에는 어쨋든 최적해를 보장해주는 BFS를 써야하지않을까? DFS는 SCC를 찾는 데 사용한다고 한다.\n","permalink":"https://qutrits.github.io/posts/dummy/studying8_bfs_dfs2/","summary":"음\u0026hellip; ㅋㅋ 면접보고 왔는데 bfs/dfs의 장단점을 물어보셨다.\n나는 뭔지만 공부했고 구현해보는 데에만 집중한 나머지 장단점이 뭔지 궁금해하지 않았다는 사실\u0026hellip;!😱\n그래서 오늘 공부해보려고 한다.\nBFS의 장단점? 🧐  장점   경로가 여러 개인 경우에도 최적해를 보장한다. 최단 경로가 존재한다면 최적해를 찾을 수 있다. 왜?: 한 노드의 자식들을 모두 탐색하기 때문에.  단점   노드의 수가 많아지면 탐색해야하는 노드의 수도 많아진다.  DFS의 장단점? 🧐  장점   최선의 경우 가장 빠름.","title":"BFS: 너비우선탐색, DFS: 깊이우선탐색(2)"},{"content":"음\u0026hellip; 나는 탐색알고리즘을 매우 어려워 하는 사람이다\u0026hellip;😭😭 이것에 이어서 길찾기를 무서워하는데..😱 프로그래머로서 이런것들은 좀 이겨내야하지 않을까? 라는 생각이 들어서..\n원래 무서운 것은 몰라서 그런거라고 했으니, 나는 이 녀석들을 공부해서 안무서워해야겠다.😋😋😋\nGraph(그래프)는 무엇일까? 🧐 BFS, DFS를 알기전에 그래프라는 자료구조를 먼저 알아야한다.\n 그래프는 정점(V)과 간선(E)들의 집합이다. 간선은 정점과 정점 사이를 직접 연결하는 선을 말한다. G = (V,E)로 수학적으로 표기한다.  💚 그래프의 표현방법\n 인접 행렬  1 2 3 4 5 6 7 8 9  int V; //정점의 갯수 int E; //간선의 갯수  int[,] Graph = new int[V, V]; //N x N 행렬  for (int i = 0; i \u0026lt; E; i++) { Graph[v1,v2] = 1;//방향 그래프 인접행렬로의 표현 }   인접 리스트  1 2 3 4 5 6 7 8 9 10 11 12 13  int V; //정점의 갯수 int E; //간선의 갯수  List\u0026lt;int\u0026gt;[] Graph = new List\u0026lt;int\u0026gt;[V + 1]; for (int i = 1; i \u0026lt; N + 1; i++) { Graph[i] = new List\u0026lt;int\u0026gt;(); foreach(v in AdjacencyVertices) { Graph[i].Add(v);//간선으로 연결된 정점들을 모두 추가  } }   BFS를 알아보자 🧐  BFS(Breadth First Search)는 너비우선탐색으로 어떠한 정점으로부터 인접한 정점을 먼저 방문하는 탐색 알고리즘이다.  🍑 코드 구현\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  List\u0026lt;int\u0026gt;[] ve;//정점과 정점마다 연결된 다른 정점들의 리스트의 배열 List\u0026lt;int\u0026gt; visited;//방문한 정점  void BFS(int v)//시작 정점 { Queue\u0026lt;int\u0026gt; queue_bfs = new Queue\u0026lt;int\u0026gt;(); queue_bfs.Enqueue(v); visited.Add(v);//방문함!  while (queue_bfs.Count \u0026gt; 0)//큐의 갯수가 1개 이상일 때,  { var w = queue_bfs.Dequeue();//방문한 정점을 빼면서  for (int i = 0; i \u0026lt; ve[w].Count; i++)//인접한 정점들을 탐색  { if (!visited.Contains(ve[w][i]))//방문하지 않은 정점이 있다면  { queue_bfs.Enqueue(ve[w][i]); visited.Add(ve[w][i]);//방문!  } } } }   DFS를 알아보자 🧐  DFS(Depth First Search)는 깊이우선탐색으로   시작 정점으로 부터 인접한 정점 중 한 정점을 방문한다. 그 정점을 기준으로 1을 반복한다. 더 이상 인접한 정점이 없으면, 다시 이전 정점으로 돌아간다(백트래킹). 모든 정점을 방문할 때까지 1~3을 반복한다.  🍑 코드 구현\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  List\u0026lt;int\u0026gt;[] ve;//정점과 정점마다 연결된 다른 정점들의 리스트의 배열 List\u0026lt;int\u0026gt; visited;//방문한 정점  void DFS(int v)//시작 정점  { if (visited.Contains(v)) //이미 방문한 곳이라면 return  { return; } visited.Add(v);//방문한 정점추가  for (int i = 0; i \u0026lt; ve[v].Count; i++) { if (!visited.Contains(ve[v][i]))//방문하지 않은 인접 정점을 방문하러가자!  { DFS(ve[v][i]); } } }```   ","permalink":"https://qutrits.github.io/posts/dummy/studying7_bfs_dfs/","summary":"음\u0026hellip; 나는 탐색알고리즘을 매우 어려워 하는 사람이다\u0026hellip;😭😭 이것에 이어서 길찾기를 무서워하는데..😱 프로그래머로서 이런것들은 좀 이겨내야하지 않을까? 라는 생각이 들어서..\n원래 무서운 것은 몰라서 그런거라고 했으니, 나는 이 녀석들을 공부해서 안무서워해야겠다.😋😋😋\nGraph(그래프)는 무엇일까? 🧐 BFS, DFS를 알기전에 그래프라는 자료구조를 먼저 알아야한다.\n 그래프는 정점(V)과 간선(E)들의 집합이다. 간선은 정점과 정점 사이를 직접 연결하는 선을 말한다. G = (V,E)로 수학적으로 표기한다.  💚 그래프의 표현방법\n 인접 행렬  1 2 3 4 5 6 7 8 9  int V; //정점의 갯수 int E; //간선의 갯수  int[,] Graph = new int[V, V]; //N x N 행렬  for (int i = 0; i \u0026lt; E; i++) { Graph[v1,v2] = 1;//방향 그래프 인접행렬로의 표현 }   인접 리스트  1 2 3 4 5 6 7 8 9 10 11 12 13  int V; //정점의 갯수 int E; //간선의 갯수  List\u0026lt;int\u0026gt;[] Graph = new List\u0026lt;int\u0026gt;[V + 1]; for (int i = 1; i \u0026lt; N + 1; i++) { Graph[i] = new List\u0026lt;int\u0026gt;(); foreach(v in AdjacencyVertices) { Graph[i].","title":"BFS: 너비우선탐색, DFS: 깊이우선탐색(1)"},{"content":"알고리즘 공부 백준 10773 🧐 제로 👉문제 나코더 기장 재민이는 동아리 회식을 준비하기 위해서 장부를 관리하는 중이다.\n재현이는 재민이를 도와서 돈을 관리하는 중인데, 애석하게도 항상 정신없는 재현이는 돈을 실수로 잘못 부르는 사고를 치기 일쑤였다.\n재현이는 잘못된 수를 부를 때마다 0을 외쳐서, 가장 최근에 재민이가 쓴 수를 지우게 시킨다.\n재민이는 이렇게 모든 수를 받아 적은 후 그 수의 합을 알고 싶어 한다. 재민이를 도와주자!\n👉입력 첫 번째 줄에 정수 K가 주어진다. (1 ≤ K ≤ 100,000)\n이후 K개의 줄에 정수가 1개씩 주어진다. 정수는 0에서 1,000,000 사이의 값을 가지며, 정수가 \u0026ldquo;0\u0026rdquo; 일 경우에는 가장 최근에 쓴 수를 지우고, 아닐 경우 해당 수를 쓴다.\n정수가 \u0026ldquo;0\u0026quot;일 경우에 지울 수 있는 수가 있음을 보장할 수 있다.\n👉출력 재민이가 최종적으로 적어 낸 수의 합을 출력한다. 최종적으로 적어낸 수의 합은 231-1보다 작거나 같은 정수이다.\n🍑풀이\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  using System; using System.Collections.Generic; namespace Algorithm15 { class Beakjoon10773 { static void Main(string[] args) { var k = int.Parse(Console.ReadLine()!); var stack = new Stack\u0026lt;int\u0026gt;(); for (int i = 0; i \u0026lt; k; i++) { var input = int.Parse(Console.ReadLine()!); if (input == 0)//0이 들어오면 이전 것을 pop  { stack.Pop(); } else { stack.Push(input);//그렇지않다면 push  } } int sum = 0; foreach (var s in stack) { sum += s; } Console.WriteLine(sum); } } }   후입선출인 Stack의 개념을 이용한 문제였다.\n너무 쉬운 문제를 선택해버렸을지도..?ㅎㅎ\n문제풀러가기\n","permalink":"https://qutrits.github.io/posts/dummy/algorithm15_10773/","summary":"알고리즘 공부 백준 10773 🧐 제로 👉문제 나코더 기장 재민이는 동아리 회식을 준비하기 위해서 장부를 관리하는 중이다.\n재현이는 재민이를 도와서 돈을 관리하는 중인데, 애석하게도 항상 정신없는 재현이는 돈을 실수로 잘못 부르는 사고를 치기 일쑤였다.\n재현이는 잘못된 수를 부를 때마다 0을 외쳐서, 가장 최근에 재민이가 쓴 수를 지우게 시킨다.\n재민이는 이렇게 모든 수를 받아 적은 후 그 수의 합을 알고 싶어 한다. 재민이를 도와주자!\n👉입력 첫 번째 줄에 정수 K가 주어진다. (1 ≤ K ≤ 100,000)","title":"AlgorithmStudy_백준 10773"},{"content":"오늘 면접에서 이전에 드로우콜을 공부했던 것과 관련해서 질문을 받았다. 배칭을 깨지 않고 오브젝트의 컬러를 바꿀 수 있는 방법을 말해보라고 하셨다.\n하지만 난 모른다고 답했다. 그런 방법이 있나? 배칭을 깨지 않고 컬러를 바꾸는 것은 불가능하다고 생각했다.\n그리고 그건 불가능한 게 맞다.\n하나의 머티리얼을 공유하는 오브젝트들이 여러 색깔을 낼 수 있는 것은 가능하다는 새로운 사실을 알아서 포스팅 해보려 한다.\nMaterialPropertyBlock의 활용 🧐  Create -\u0026gt; Shader -\u0026gt; Standard Surface Shader 생성. [PerRendererData] 를 바꾸기 원하는 셰이더 프로퍼티 앞에 추가.\n  💚2 - 예시\n1 2 3 4 5 6 7 8 9 10  Shader \u0026#34;Custom/TestShader\u0026#34; { Properties { [PerRendererData]_Color (\u0026#34;Color\u0026#34;, Color) = (1,1,1,1) _MainTex (\u0026#34;Albedo (RGB)\u0026#34;, 2D) = \u0026#34;white\u0026#34; {} _Glossiness (\u0026#34;Smoothness\u0026#34;, Range(0,1)) = 0.5 _Metallic (\u0026#34;Metallic\u0026#34;, Range(0,1)) = 0.0 } }   변경점 적용.  💚3 - 예시\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  using UnityEngine; public class MaterialColorChanger : MonoBehaviour { public Color toColor; private Renderer _renderer; public Renderer Renderer { get { if (_renderer == null) { _renderer = GetComponent\u0026lt;Renderer\u0026gt;(); } return _renderer; } } public void ChangeColor() //material의 컬러를 직접적으로 바꾸는 방법: 새로운 material instance가 생성됨.  { Renderer.material.color = toColor; } public void ChangeColorWithPropertyBlock()//property의 값을 바꾸는 방법. 하나의 material을 사용하면서 서로 다른 값을 가질 수 있음.  { var propertyBlock = new MaterialPropertyBlock(); Renderer.GetPropertyBlock(propertyBlock); propertyBlock.SetColor(\u0026#34;_Color\u0026#34;, toColor); Renderer.SetPropertyBlock(propertyBlock); } }   차이점 확인 🧐 같은 머티리얼을 공유하는 4개의 오브젝트들을 미리 static batching이 되도록 설정을 해놓은 상태입니다.\n 렌더러에서 머티리얼의 값을 직접적으로 바꿨을 경우.   배칭이 불가능한 이유: 서로 다른 머티리얼을 사용하기 때문. 서로 다른 머티리얼을 사용한다는 것은 런타임 중에 새로운 머티리얼을 인스턴스했다는 것.  프로퍼티의 값을 통해 바꿨을 경우.   배칭이 불가능한 이유: 서로 다른 프로퍼티 값을 가지고 있기 때문.(즉 배칭을 유지하면서 컬러를 바꾸는 것은 불가능) 하나의 공유된 머티리얼을 사용하지만 각자 다른 프로퍼티 값을 가지고 있다는 것.   하지만 같은 프로퍼티 값을 가지고 있는 오브젝트들은 배칭이 유지된다.\n  ⚠️주의⚠️\n[PerRendererData]을 쓰지 않을 경우: 함수들은 사용이 가능하지만 내부적으로 새 머티리얼 인스턴스 하기 때문에 결국은 1번의 방법과 같은 결과를 낳는다.\n","permalink":"https://qutrits.github.io/posts/dummy/studying6_drawcall3/","summary":"오늘 면접에서 이전에 드로우콜을 공부했던 것과 관련해서 질문을 받았다. 배칭을 깨지 않고 오브젝트의 컬러를 바꿀 수 있는 방법을 말해보라고 하셨다.\n하지만 난 모른다고 답했다. 그런 방법이 있나? 배칭을 깨지 않고 컬러를 바꾸는 것은 불가능하다고 생각했다.\n그리고 그건 불가능한 게 맞다.\n하나의 머티리얼을 공유하는 오브젝트들이 여러 색깔을 낼 수 있는 것은 가능하다는 새로운 사실을 알아서 포스팅 해보려 한다.\nMaterialPropertyBlock의 활용 🧐  Create -\u0026gt; Shader -\u0026gt; Standard Surface Shader 생성. [PerRendererData] 를 바꾸기 원하는 셰이더 프로퍼티 앞에 추가.","title":"Draw Call: 드로우콜(3)"},{"content":"알고리즘 공부 백준 11068 🧐 회문인 수 👉문제 어떤 수를 왼쪽부터 읽어도, 오른쪽부터 읽어도 같을 때 이 수를 회문인 수라고 한다. 예를 들어, 747은 회문인 수이다. 255도 회문인 수인데, 16진수로 표현하면 FF이기 때문이다. 양의 정수를 입력받았을 때, 이 수가 어떤 B진법 (2 ≤ B ≤ 64)으로 표현하면 회문이 되는 경우가 있는지 알려주는 프로그램을 작성하시오. B진법이란, 한 자리에서 수를 표현할 때 쓸 수 있는 수의 가짓수가 B라는 뜻이다. 예를 들어, 십진법에서 B는 10이다.\n👉입력 입력 데이터는 표준입력을 사용한다. 입력은 T개의 테스트 데이터로 구성된다. 입력의 첫 번째 줄에는 테스트 데이터의 수를 나타내는 정수 T가 주어진다. 각 테스트 데이터는 64 이상 1,000,000 이하인 하나의 정수로 주어진다.\n👉출력 출력은 표준출력을 사용한다. 하나의 테스트 데이터에 대한 답을 하나의 줄에 출력한다. 각 테스트 데이터에 대해, 주어진 수가 어떤 B진법 (2 ≤ B ≤ 64)으로 표현하여 회문이 될 수 있다면 1을, 그렇지 않다면 0을 출력한다.\n🍑풀이\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61  using System; using System.Collections.Generic; namespace Algorithm14 { class Baekjoon11068 { static void Main(string[] args) { var t = int.Parse(Console.ReadLine()!); var arr = new int[t]; for (int i = 0; i \u0026lt; t; i++) { arr[i] = int.Parse(Console.ReadLine()!); } for (int i = 0; i \u0026lt; t; i++) { int result = 0; for (int j = 2; j \u0026lt;= 64; j++) { var convert = ConvertJ(arr[i], j); result = Check(convert); if (result == 1) { break; } } Console.WriteLine(result); } int Check(List\u0026lt;int\u0026gt; list)//회문인지 체크  { for (int i = 0; i \u0026lt; list.Count / 2; i++) { if (list[i] != list[list.Count - i - 1]) { return 0; } } return 1; } List\u0026lt;int\u0026gt; ConvertJ(int value, int j)//진법 변환(사실 여기서 뒤집어주어야 알맞은 값이 나오지만 사실 이 문제에서는 상관이없기때문에 뒤집지않았다.)  { List\u0026lt;int\u0026gt; list = new List\u0026lt;int\u0026gt;(); while (value / j \u0026gt; 0) { list.Add(value % j); value /= j; } list.Add(value); return list; } } } }   문제풀러가기\n","permalink":"https://qutrits.github.io/posts/dummy/algorithm14_11068/","summary":"알고리즘 공부 백준 11068 🧐 회문인 수 👉문제 어떤 수를 왼쪽부터 읽어도, 오른쪽부터 읽어도 같을 때 이 수를 회문인 수라고 한다. 예를 들어, 747은 회문인 수이다. 255도 회문인 수인데, 16진수로 표현하면 FF이기 때문이다. 양의 정수를 입력받았을 때, 이 수가 어떤 B진법 (2 ≤ B ≤ 64)으로 표현하면 회문이 되는 경우가 있는지 알려주는 프로그램을 작성하시오. B진법이란, 한 자리에서 수를 표현할 때 쓸 수 있는 수의 가짓수가 B라는 뜻이다. 예를 들어, 십진법에서 B는 10이다.","title":"AlgorithmStudy_백준 11068"},{"content":"이전 포스트에서는 드로우콜 자체에 대해 알아보았다면, 이번 포스트에서는 드로우콜을 줄이기 위해 알아야하는 것과 드로우콜을 줄이는 방법에 대해 알아보겠다.\nBatch, Batching이 뭐야? 🧐  Batch: 이전 포스트에서 언급했던 DP Call과 render state change들을 합친 넓은 의미의 드로우콜. Batching: 드로우콜을 줄이는 작업(어떠한 조건 아래 다수의 Batch를 하나로 만드는 작업).  💚Batching 세부 설명\nProject Setting \u0026gt; Player 에서 사용이 체크가 되어있는지 확인.\n Static Batching: Static 플래그가 체크되어있는 정적인 오브젝트에 적용 됨.   적용 방법\n 버텍스 연산을 런타임에 수행하지 않기때문에 Dynamic Batching 보다 효율적. 같은 머티리얼을 사용하는 메쉬들을 렌더링할 때 드로우콜을 줄일 수 있다.(동일한 머티리얼 인스턴스여야 함) 배경 같은 요소(트랜스폼 등이 바뀌지 않는 오브젝트)에 적용해주기에 적합함.  ⚠️주의⚠️\n메모리가 추가로 필요함.\n해당되는 오브젝트들은 처음부터 Scene에 존재해야 함.\n동일한 머터리얼을 사용할 지라도 스크립트에서 Renderer.material.color = Color.red;처럼 머터리얼의 속성을 변경한다면 복사본이 생성되기 때문에 적용되지않는다(Renderer.sharedMaterial사용으로 해결가능).\nDynamic Batching: Static 플래그가 체크되어있지않은 모든 오브젝트에 적용 됨.   매 프레임, 오브젝트들의 버텍스 정보를 합쳐 버텍스 버퍼와 인덱스 버퍼에 담아 GPU가 렌더링 함. 따라서 매 프레임마다 오버헤드가 발생. 그러나 드로우콜을 줄임으로 전체적인 성능 향상.  ⚠️주의⚠️\nSkinned Mesh에는 적용이 되지않음.\n버텍스가 너무 많은 메쉬에는 적용이 되지않음.\n2D 환경에서는 드로우콜을 어떻게 줄이나요? 🧐  Sprite Mode: Multiple 사용. Sprite Atlas 이용.  참고자료: 유니티 그래픽스 최적화 스타트업\n","permalink":"https://qutrits.github.io/posts/dummy/studying5_drawcall2/","summary":"이전 포스트에서는 드로우콜 자체에 대해 알아보았다면, 이번 포스트에서는 드로우콜을 줄이기 위해 알아야하는 것과 드로우콜을 줄이는 방법에 대해 알아보겠다.\nBatch, Batching이 뭐야? 🧐  Batch: 이전 포스트에서 언급했던 DP Call과 render state change들을 합친 넓은 의미의 드로우콜. Batching: 드로우콜을 줄이는 작업(어떠한 조건 아래 다수의 Batch를 하나로 만드는 작업).  💚Batching 세부 설명\nProject Setting \u0026gt; Player 에서 사용이 체크가 되어있는지 확인.\n Static Batching: Static 플래그가 체크되어있는 정적인 오브젝트에 적용 됨.   적용 방법","title":"Draw Call: 드로우콜(2)"},{"content":"오늘 비대면 면접을 보았는데, 이전 프로젝트에서 드로우콜을 줄이려는 노력을 했냐고 물어보셨다.나는 딱히 드로우콜에 대해서 생각을 해본 적이 별로 없어서 없다고 말했지만, 이 부분에 대해 좀 더 알 필요가 있다고 생각했다. 그래서 오늘의 공부는 드로우콜!\nDraw Call이 뭐야? 🧐  간단 요약 정의: CPU가 GPU에 오브젝트를 그리라는 명령을 호출하는 것.  💚세부 설명\n 오브젝트가 실제 화면에 렌더링 되려면 CPU -\u0026gt; GPU 정보 전달 필요함. 정보: 메시, 텍스처, 쉐이더, 트랜스폼, 알파블렌딩 여부 등이 존재. CPU 메모리에서 GPU 메모리로 위의 정보 데이터들의 복사가 이루워짐.(게임 수행 내내 데이터는 메모리에 상주) GPU에는 렌더링 할 것의 상태 정보를 담는 테이블이 존재.(Render States: GPU 메모리의 데이터 위치 정보 보유) 새로운 오브젝트를 그릴 때 마다 상태 변경 CPU -\u0026gt; GPU로 상태 변경 명령을 내림.(변경이 필요한 부분만) CPU -\u0026gt; GPU로 상태 변경 명령(render state change) + 렌더 명령(Draw Primitive Call(DP Call)) = 드로우콜 CPU -\u0026gt; 커맨드 버퍼(Command Buffer) -\u0026gt; GPU 순으로 명령이 이루워짐.  Draw Call이 많으면 무엇이 문제일까? 🧐  명령을 GPU에서 사용하는 신호로 변환해야하기 때문에 CPU에 부담이 된다.(CPU 오버헤드)  어떻게 해야할까? 🧐  렌더링에 관련된 작업들을 별도의 쓰레드에서 수행하게한다.(Multithreaded Rendering)\n 드로우콜을 줄인다.  ⚠️주의⚠️\n드로우콜을 줄이는 데에는 텍스쳐의 크기 또는 폴리곤의 수를 줄이는 것과 관련이 없다!\nDraw Call은 어떻게 발생되는 걸까? 🧐 보통 오브젝트를 그릴 때 Mesh가 1개, Material이 1개일 경우 드로우콜이 한 번 일어난다.\n Mesh가 여러 개인 경우 Material이 여러 개인 경우 Shader에 따라서\u0026hellip;\n  ⚠️주의⚠️\n수많은 상태 변경들을 포함하기 때문에 드로우콜의 비용은 개당으로 계산하기 어렵다.\n참고자료: 유니티 그래픽스 최적화 스타트업\n","permalink":"https://qutrits.github.io/posts/dummy/studying4_drawcall1/","summary":"오늘 비대면 면접을 보았는데, 이전 프로젝트에서 드로우콜을 줄이려는 노력을 했냐고 물어보셨다.나는 딱히 드로우콜에 대해서 생각을 해본 적이 별로 없어서 없다고 말했지만, 이 부분에 대해 좀 더 알 필요가 있다고 생각했다. 그래서 오늘의 공부는 드로우콜!\nDraw Call이 뭐야? 🧐  간단 요약 정의: CPU가 GPU에 오브젝트를 그리라는 명령을 호출하는 것.  💚세부 설명\n 오브젝트가 실제 화면에 렌더링 되려면 CPU -\u0026gt; GPU 정보 전달 필요함. 정보: 메시, 텍스처, 쉐이더, 트랜스폼, 알파블렌딩 여부 등이 존재.","title":"Draw Call: 드로우콜(1)"},{"content":"유니티에서 쓸 Tween을 만들고 있는 중이다.Tween에서 여러가지 클래스를 처리하고 싶어서 Generic class를 활용하기로 하였다.\nGeneric class가 뭐야? 🧐  일반적으로 클래스를 정의할 때, 클래스 내의 모든 데이타 타입을 지정해 주게 된다. 하지만 어떤 경우는 클래스의 거의 모든 부분이 동일한데 일부 데이타 타입만이 다른 경우가 있을 수 있다.이런 경우 C#의 제네릭 타입(Generic Type)을 사용할 수 있는데, 제네릭 타입에서는 int, float, double 같은 데이타 요소 타입을 확정하지 않고 이 데이타 타입 자체를 타입파라미터(Type Parameter)로 받아들이도록 클래스를 정의한다.\n (c++ 의 템플릿과 비슷!)\n왜 사용하는거야? 🧐  기능이 같은 클래스를 타입만 바꾸어 새롭게 구현할 필요없이 Generic class로 구현하면 여러 타입으로 하나의 클래스를 활용할 수 있다. 대표적 예시로 List\u0026lt;T\u0026gt;가 있다.  어떻게 사용해야해? 🧐  public class [ClassName]\u0026lt;T\u0026gt; 로 선언. 여러개의 타입을 사용하고 싶을 때는 \u0026lt;T1, T2 ...\u0026gt; 이런 식으로 나열하면 된다. 제네릭 타입에 제약을 두고 싶을 경우 where T : [제약조건]과 같이 마지막에 조건을 붙인다.  ⚠️주의⚠️ 만약 제네릭 클래스가 MonoBehaviour를 상속하고 있을 때, GameObject에 AddComponent를 바로 할 경우 null이 된다. 각 제네릭 타입마다 class를 새로 생성 후 가능하다.\n⛔ 옳지않은 예시\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  using System; using UnityEngine; namespace MyTween { public class Tween\u0026lt;T1, T2\u0026gt;: MonoBehaviour { private T1 target; private T2 v_end; } public static class TweenManager { public static Tween\u0026lt;Transform, Vector3\u0026gt; Move(this Transform tr, Vector3 to, float duration) { Tween\u0026lt;Transform, Vector3\u0026gt; tween = tr.gameObject.AddComponent\u0026lt;Tween\u0026lt;Transform, Vector3\u0026gt;\u0026gt;();//null 반환!!  return tween; } } }   💚 옳은 예시\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  using System; using UnityEngine; namespace MyTween { public class TweenVector3 : Tween\u0026lt;Transform, Vector3\u0026gt; { } public static class TweenManager { public static Tween\u0026lt;Transform, Vector3\u0026gt; Move(this Transform tr, Vector3 to, float duration) { TweenVector3 tween = tr.gameObject.AddComponent\u0026lt;TweenVector3\u0026gt;();//성공적인 반환!!  return tween; } } }   ","permalink":"https://qutrits.github.io/posts/dummy/studying3_generic/","summary":"유니티에서 쓸 Tween을 만들고 있는 중이다.Tween에서 여러가지 클래스를 처리하고 싶어서 Generic class를 활용하기로 하였다.\nGeneric class가 뭐야? 🧐  일반적으로 클래스를 정의할 때, 클래스 내의 모든 데이타 타입을 지정해 주게 된다. 하지만 어떤 경우는 클래스의 거의 모든 부분이 동일한데 일부 데이타 타입만이 다른 경우가 있을 수 있다.이런 경우 C#의 제네릭 타입(Generic Type)을 사용할 수 있는데, 제네릭 타입에서는 int, float, double 같은 데이타 요소 타입을 확정하지 않고 이 데이타 타입 자체를 타입파라미터(Type Parameter)로 받아들이도록 클래스를 정의한다.","title":"Generic: 제너릭 클래스"},{"content":"알고리즘 공부 백준 2941 🧐 크로아티아 알파벳 👉문제 예전에는 운영체제에서 크로아티아 알파벳을 입력할 수가 없었다. 따라서, 다음과 같이 크로아티아 알파벳을 변경해서 입력했다.\n예를 들어, ljes=njak은 크로아티아 알파벳 6개(lj, e, š, nj, a, k)로 이루어져 있다. 단어가 주어졌을 때, 몇 개의 크로아티아 알파벳으로 이루어져 있는지 출력한다.\ndž는 무조건 하나의 알파벳으로 쓰이고, d와 ž가 분리된 것으로 보지 않는다. lj와 nj도 마찬가지이다. 위 목록에 없는 알파벳은 한 글자씩 센다.\n👉입력 첫째 줄에 최대 100글자의 단어가 주어진다. 알파벳 소문자와 \u0026lsquo;-\u0026rsquo;, \u0026lsquo;=\u0026lsquo;로만 이루어져 있다.\n단어는 크로아티아 알파벳으로 이루어져 있다. 문제 설명의 표에 나와있는 알파벳은 변경된 형태로 입력된다.\n👉출력 입력으로 주어진 단어가 몇 개의 크로아티아 알파벳으로 이루어져 있는지 출력한다.\n🍑풀이\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  using System; using System.Collections.Generic; using System.Text; namespace Algorithm13 { class Baekjoon2941 { static void Main(string[] args) { List\u0026lt;string\u0026gt; list = new List\u0026lt;string\u0026gt; {\u0026#34;c=\u0026#34;, \u0026#34;c-\u0026#34;, \u0026#34;dz=\u0026#34;, \u0026#34;d-\u0026#34;, \u0026#34;lj\u0026#34;, \u0026#34;nj\u0026#34;, \u0026#34;s=\u0026#34;, \u0026#34;z=\u0026#34;}; var input = new StringBuilder(Console.ReadLine()); foreach (var s in list) { input.Replace(s, \u0026#34;*\u0026#34;);//해당되는 문자열을 다른 문자로 변경  } Console.WriteLine(input.Length);//문자열의 길이 출력  } } }   문제풀러가기\n","permalink":"https://qutrits.github.io/posts/dummy/algorithm13/","summary":"알고리즘 공부 백준 2941 🧐 크로아티아 알파벳 👉문제 예전에는 운영체제에서 크로아티아 알파벳을 입력할 수가 없었다. 따라서, 다음과 같이 크로아티아 알파벳을 변경해서 입력했다.\n예를 들어, ljes=njak은 크로아티아 알파벳 6개(lj, e, š, nj, a, k)로 이루어져 있다. 단어가 주어졌을 때, 몇 개의 크로아티아 알파벳으로 이루어져 있는지 출력한다.\ndž는 무조건 하나의 알파벳으로 쓰이고, d와 ž가 분리된 것으로 보지 않는다. lj와 nj도 마찬가지이다. 위 목록에 없는 알파벳은 한 글자씩 센다.\n👉입력 첫째 줄에 최대 100글자의 단어가 주어진다.","title":"AlgorithmStudy_백준 2941"},{"content":"알고리즘 공부 백준 4673 🧐 셀프 넘버 👉문제 셀프 넘버는 1949년 인도 수학자 D.R. Kaprekar가 이름 붙였다. 양의 정수 n에 대해서 d(n)을 n과 n의 각 자리수를 더하는 함수라고 정의하자. 예를 들어, d(75) = 75+7+5 = 87이다.\n양의 정수 n이 주어졌을 때, 이 수를 시작해서 n, d(n), d(d(n)), d(d(d(n))), \u0026hellip;과 같은 무한 수열을 만들 수 있다.\n예를 들어, 33으로 시작한다면 다음 수는 33 + 3 + 3 = 39이고, 그 다음 수는 39 + 3 + 9 = 51, 다음 수는 51 + 5 + 1 = 57이다. 이런식으로 다음과 같은 수열을 만들 수 있다.\n33, 39, 51, 57, 69, 84, 96, 111, 114, 120, 123, 129, 141, \u0026hellip;\nn을 d(n)의 생성자라고 한다. 위의 수열에서 33은 39의 생성자이고, 39는 51의 생성자, 51은 57의 생성자이다. 생성자가 한 개보다 많은 경우도 있다. 예를 들어, 101은 생성자가 2개(91과 100) 있다.\n생성자가 없는 숫자를 셀프 넘버라고 한다. 100보다 작은 셀프 넘버는 총 13개가 있다. 1, 3, 5, 7, 9, 20, 31, 42, 53, 64, 75, 86, 97\n10,000보다 작거나 같은 셀프 넘버를 한 줄에 하나씩 출력하는 프로그램을 작성하시오.\n👉입력 입력은 없다.\n👉출력 10,000보다 작거나 같은 셀프 넘버를 한 줄에 하나씩 증가하는 순서로 출력한다.\n🍑풀이\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  using System; using System.Linq; namespace Algorithm12 { class Baekjoon4673 { static void Main(string[] args) { var arr = new bool[10000]; //생성자가 있는 지 없는 지 체크해주는 배열!  for (int i = 0; i \u0026lt; arr.Length; i++) { var n = i + 1; //실제 체크해야 하는 수는 인덱스 보다 1 더 큼.  if (arr[i] == false) //만약 생성자가 없다면  { Console.WriteLine(n);//출력  } var list = n.ToString().ToArray();//수를 array 로 변환  foreach (var num in list) { n += num - \u0026#39;0\u0026#39;;//수에 각 자리 수를 더함  } if (n - 1 \u0026lt; arr.Length)//만약 인덱스가 arr의 길이보다 작을 경우에는  { arr[n - 1] = true;//생성자가 있다고 true 로 변경하기  } } } } }   문제풀러가기\n","permalink":"https://qutrits.github.io/posts/dummy/algorithm12/","summary":"알고리즘 공부 백준 4673 🧐 셀프 넘버 👉문제 셀프 넘버는 1949년 인도 수학자 D.R. Kaprekar가 이름 붙였다. 양의 정수 n에 대해서 d(n)을 n과 n의 각 자리수를 더하는 함수라고 정의하자. 예를 들어, d(75) = 75+7+5 = 87이다.\n양의 정수 n이 주어졌을 때, 이 수를 시작해서 n, d(n), d(d(n)), d(d(d(n))), \u0026hellip;과 같은 무한 수열을 만들 수 있다.\n예를 들어, 33으로 시작한다면 다음 수는 33 + 3 + 3 = 39이고, 그 다음 수는 39 + 3 + 9 = 51, 다음 수는 51 + 5 + 1 = 57이다.","title":"AlgorithmStudy_백준 4673"},{"content":"유니티에서 여러가지 연습을 하려고 생각하고 있었을 때, 나만의 tween을 만들어 보고싶다고 생각했다.\nDoTween을 사용할 때 여러 함수들이 transform, image 등에서 부터 바로 DoTween 함수를 사용할 수 있었던 것이 기억에 남았다.\n나도 이런식으로 바로바로 접근할 수 있으면 좋겠다고 생각을 해서 방법을 찾아보니, Extenstion Method를 이용하면 되는 것!\nExtenstion Method가 뭐야? 🧐  특수한 종류의 static 메서드. 다른 클래스의 인스턴스 메서드인 것 처럼 사용되는 기능. 클래스, 구조체, 인터페이스 등에 적용 가능.  왜 사용하는거야? 🧐  인스턴스 메서드를 추가하려면 해당 클래스 안에 메서드를 추가해야한다. 하지만 접근이 불가한 클래스라면 ??? Extenstion Method를 사용하자!  어떻게 사용해야해? 🧐  static class static method public Extenstion Method는 첫번째 파라미터로 반드시 클래스명을 지정해야 함.public static void Function(this T parm) 이 파라미터 앞에 반드시 this 키워드를 추가할 것! 만약 Extenstion Method 사용 후 또 다른 확장 메소드를 쓰고 싶을 시 this로 들어왔던 첫 파라미터를 반환 해주면 된다.  🍑 예시: tween 만들기 프로젝트에 일부를 이용했다..ㅎㅎ\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  using System.Collections; using UnityEngine; namespace MyTween { public static class Tween { public static Transform Move(this Transform tr, Vector3 to, float duration, AnimationCurve ease) { return tr; } public static Transform Scale(this Transform tr, Vector3 to, float duration, AnimationCurve ease) { return tr; } } }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  using System; using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEngine.EventSystems; using MyTween; public class ButtonDirecting : MonoBehaviour, IPointerDownHandler, IPointerUpHandler { public AnimationCurve ease; public Vector2 toSize = Vector2.one; public float duration; private bool isTweening = false; private event Action onClick; private Vector2 fromSize; public void OnClick() { transform.Move(Vector3.one, 1f, ease).Scale(Vector3.one, 1f); } }   ","permalink":"https://qutrits.github.io/posts/dummy/studying2/","summary":"유니티에서 여러가지 연습을 하려고 생각하고 있었을 때, 나만의 tween을 만들어 보고싶다고 생각했다.\nDoTween을 사용할 때 여러 함수들이 transform, image 등에서 부터 바로 DoTween 함수를 사용할 수 있었던 것이 기억에 남았다.\n나도 이런식으로 바로바로 접근할 수 있으면 좋겠다고 생각을 해서 방법을 찾아보니, Extenstion Method를 이용하면 되는 것!\nExtenstion Method가 뭐야? 🧐  특수한 종류의 static 메서드. 다른 클래스의 인스턴스 메서드인 것 처럼 사용되는 기능. 클래스, 구조체, 인터페이스 등에 적용 가능.  왜 사용하는거야?","title":"Extenstion Method: 확장 메서드"},{"content":"알고리즘 공부 백준 13116 🧐 잃어버린 괄호 👉문제 혹시 2007학년도 대학수학능력시험 수리영역 가형 이산수학 30번 문제를 아는가? 여러분은 수능을 치는 수험생의 마음으로 이 문제를 해결해야만 한다.\n하지만 우리는 저작권 위반으로 판사님을 뵙고 싶지 않았기 때문에 이 문제를 직접 수록할 수는 없었다. 아래 링크 중 하나를 클릭해서 pdf 파일을 내려받아 가장 마지막 페이지를 보면, 위의 그림과 아주 유사한 문제가 하나 있을 것이다. 여러분은 바로 그 문제를 해결해야만 한다.\n이미지 보러가기\n문제를 그대로 내면 재미없기 때문에, 우리는 위 그림과 같이 33과 79가 적혀 있던 부분을 하얀색 직사각형으로 가렸다. 그림에서 흐릿하게 보이는 모든 부분은 원래 문제와 다르지 않다.\n빈 칸에 들어갈 두 자연수가 주어졌을 때 문제를 해결하는 프로그램을 작성하자.\n👉입력 첫 번째 줄에 테스트 케이스의 수 T (1 ≤ T ≤ 50 000)가 주어진다. 이후 T개의 테스트 케이스가 주어진다. 각 테스트 케이스는 한 줄로 구성되어 있으며, 각 줄에는 두 개의 정수 A와 B (1 ≤ A, B ≤ 1 023, A ≠ B)가 공백을 사이로 두고 주어진다. 이는 첫 번째 빈 칸에는 A를, 두 번째 빈 칸에는 B를 넣었을 때 답을 구하라는 의미이다\n👉출력 각 테스트 케이스에 대해 답을 한 줄에 하나씩 출력한다.\n🍑풀이\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  using System; using System.Collections.Generic; using System.Linq; namespace Algorithm11 { class Baekjoon13116 { static void Main(string[] args) { int tCount = int.Parse(Console.ReadLine()!); var tlist = new List\u0026lt;int\u0026gt;(); for (int i = 0; i \u0026lt; tCount; i++) { var input = Console.ReadLine()!.Split(\u0026#39; \u0026#39;).Select(int.Parse).ToArray(); tlist.AddRange(input); } for (int i = 0; i \u0026lt; tCount; i++) { int n1 = tlist[2 * i]; int n2 = tlist[2 * i + 1]; while (n1 != n2) { while (n1 \u0026lt; n2) //n2가 n1보다 크지 않을 때까지  { n2 /= 2; } if (n1 == n2) //같다면 break;  { break; } n1 /= 2; //n1이 n2보다 크지 않을 때까지  } Console.WriteLine(n1 * 10); } } } }   문제풀러가기\n","permalink":"https://qutrits.github.io/posts/dummy/algorithm11/","summary":"알고리즘 공부 백준 13116 🧐 잃어버린 괄호 👉문제 혹시 2007학년도 대학수학능력시험 수리영역 가형 이산수학 30번 문제를 아는가? 여러분은 수능을 치는 수험생의 마음으로 이 문제를 해결해야만 한다.\n하지만 우리는 저작권 위반으로 판사님을 뵙고 싶지 않았기 때문에 이 문제를 직접 수록할 수는 없었다. 아래 링크 중 하나를 클릭해서 pdf 파일을 내려받아 가장 마지막 페이지를 보면, 위의 그림과 아주 유사한 문제가 하나 있을 것이다. 여러분은 바로 그 문제를 해결해야만 한다.\n이미지 보러가기\n문제를 그대로 내면 재미없기 때문에, 우리는 위 그림과 같이 33과 79가 적혀 있던 부분을 하얀색 직사각형으로 가렸다.","title":"AlgorithmStudy_백준 13116"},{"content":"알고리즘 공부 백준 1541 🧐 잃어버린 괄호 👉문제 세준이는 양수와 +, -, 그리고 괄호를 가지고 식을 만들었다. 그리고 나서 세준이는 괄호를 모두 지웠다.\n그리고 나서 세준이는 괄호를 적절히 쳐서 이 식의 값을 최소로 만들려고 한다.\n괄호를 적절히 쳐서 이 식의 값을 최소로 만드는 프로그램을 작성하시오.\n👉입력 첫째 줄에 식이 주어진다. 식은 ‘0’~‘9’, ‘+’, 그리고 ‘-’만으로 이루어져 있고, 가장 처음과 마지막 문자는 숫자이다. 그리고 연속해서 두 개 이상의 연산자가 나타나지 않고, 5자리보다 많이 연속되는 숫자는 없다. 수는 0으로 시작할 수 있다. 입력으로 주어지는 식의 길이는 50보다 작거나 같다.\n👉출력 첫째 줄에 정답을 출력한다.\n🍑풀이\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  using System; using System.Collections.Generic; using System.Linq; namespace Algorithm10 { class Baekjon1541 { static void Main(string[] args) { var op = new char[] {\u0026#39;+\u0026#39;, \u0026#39;-\u0026#39;}; var input = Console.ReadLine(); var opList = input!.ToCharArray().Where(a =\u0026gt; a is \u0026#39;+\u0026#39; or \u0026#39;-\u0026#39;).ToArray(); var nList = input!.Split(op).Select(int.Parse).ToArray();//연산자를 기준으로 SPLIT  if (nList.Length == 1) //수 하나만 들어왔을 경우(연산자가 없는 경우)  { Console.WriteLine(nList[0]); return; } int re = nList[0]; List\u0026lt;int\u0026gt; results = new List\u0026lt;int\u0026gt;();//결과값들을 저장해 놓을 공간(-기준으로 끊어 +연산한 값들)  for (int i = 0; i \u0026lt; opList.Length; i++) { if (opList[i] == \u0026#39;+\u0026#39;) { re += nList[i + 1]; } else { results.Add(re);//-를 만나기 전까지 더한 수의 합을 ADD  re = nList[i + 1];// -를 만난 후 다음 수  } if (i == opList.Length - 1)//다음 연산자가 없을 경우  { results.Add(re); } } var result = results[0]; for (int i = 1; i \u0026lt; results.Count; i++) { result -= results[i];//처음 값에서 나머지 값을 모두 빼줌  } Console.WriteLine(result); } } }   문제풀러가기\n","permalink":"https://qutrits.github.io/posts/dummy/algorithm10/","summary":"알고리즘 공부 백준 1541 🧐 잃어버린 괄호 👉문제 세준이는 양수와 +, -, 그리고 괄호를 가지고 식을 만들었다. 그리고 나서 세준이는 괄호를 모두 지웠다.\n그리고 나서 세준이는 괄호를 적절히 쳐서 이 식의 값을 최소로 만들려고 한다.\n괄호를 적절히 쳐서 이 식의 값을 최소로 만드는 프로그램을 작성하시오.\n👉입력 첫째 줄에 식이 주어진다. 식은 ‘0’~‘9’, ‘+’, 그리고 ‘-’만으로 이루어져 있고, 가장 처음과 마지막 문자는 숫자이다. 그리고 연속해서 두 개 이상의 연산자가 나타나지 않고, 5자리보다 많이 연속되는 숫자는 없다.","title":"AlgorithmStudy_백준 1541"},{"content":"시간 복잡도  정의: 특정한 크기의 입력에 대하여 알고리즘이 얼마나 오래 걸리는가. 알고리즘을 위해 필요한 연산의 수로 계산할 수 있음. 빅오(Big-O) 표기법: 함수의 상한을 표기 (ex. $3N^3 + N^2 + 1,000,000$ =\u0026gt; O($N^3$)으로 표기.)  공간 복잡도  정의: 특정한 크기의 입력에 대하여 알고리즘이 얼마나 많은 메모리를 차지하는가. 알고리즘을 위해 필요한 메모리의 양으로 계산할 수 있음. 시간 복잡도와 같이 빅오(Big-O) 표기법을 사용한다.  ","permalink":"https://qutrits.github.io/posts/dummy/studying1/","summary":"시간 복잡도  정의: 특정한 크기의 입력에 대하여 알고리즘이 얼마나 오래 걸리는가. 알고리즘을 위해 필요한 연산의 수로 계산할 수 있음. 빅오(Big-O) 표기법: 함수의 상한을 표기 (ex. $3N^3 + N^2 + 1,000,000$ =\u0026gt; O($N^3$)으로 표기.)  공간 복잡도  정의: 특정한 크기의 입력에 대하여 알고리즘이 얼마나 많은 메모리를 차지하는가. 알고리즘을 위해 필요한 메모리의 양으로 계산할 수 있음. 시간 복잡도와 같이 빅오(Big-O) 표기법을 사용한다.  ","title":"Studying_복잡도"},{"content":"알고리즘 공부 백준 9461 🧐 파도반 수열 👉문제 아래의 그림과 같이 삼각형이 나선 모양으로 놓여져 있다. 첫 삼각형은 정삼각형으로 변의 길이는 1이다. 그 다음에는 다음과 같은 과정으로 정삼각형을 계속 추가한다. 나선에서 가장 긴 변의 길이를 k라 했을 때, 그 변에 길이가 k인 정삼각형을 추가한다.\n파도반 수열 P(N)은 나선에 있는 정삼각형의 변의 길이이다. P(1)부터 P(10)까지 첫 10개 숫자는 1, 1, 1, 2, 2, 3, 4, 5, 7, 9이다.\nN이 주어졌을 때, P(N)을 구하는 프로그램을 작성하시오.\n👉입력 첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, N이 주어진다. (1 ≤ N ≤ 100)\n👉출력 각 테스트 케이스마다 P(N)을 출력한다.\n🍑풀이\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  using System; using System.Linq; namespace Algorithm9 { class Baekjoon9461 { static void Main(string[] args) { var t = int.Parse(Console.ReadLine()!); var n = new int[t];//n 수열에서 뽑아 출력해야하는 n번째 수들의 배열  for (int i = 0; i \u0026lt; t; i++) { n[i] = int.Parse(Console.ReadLine()!); } var list = n.ToList(); list.Sort(); var max = list[t - 1];//입력 중 가장 큰 숫자  var padovan = new long[max]; padovan[0] = 1; padovan[1] = 1; padovan[2] = 1; while (padovan[^1] == 0) { for (int i = 3; i \u0026lt; max; i++)//입력된 가장 큰 수 번째까지 수열을 구한다.  { if (padovan[i] != 0) { continue; } padovan[i] = padovan[i - 3] + padovan[i - 2]; //(규칙) =\u0026gt; i번째는 i-3번째 + i-2번째  } } var result = new long[t];//결과값을 담을 배열  for (int i = 0; i \u0026lt; t; i++) { result[i] = padovan[n[i] - 1];//결과값의 배열에 n값의 순서대로 수열의 값을 대입  } Console.WriteLine(String.Join(\u0026#34;\\n\u0026#34;, result)); } } }   문제풀러가기\n","permalink":"https://qutrits.github.io/posts/dummy/algorithm9/","summary":"알고리즘 공부 백준 9461 🧐 파도반 수열 👉문제 아래의 그림과 같이 삼각형이 나선 모양으로 놓여져 있다. 첫 삼각형은 정삼각형으로 변의 길이는 1이다. 그 다음에는 다음과 같은 과정으로 정삼각형을 계속 추가한다. 나선에서 가장 긴 변의 길이를 k라 했을 때, 그 변에 길이가 k인 정삼각형을 추가한다.\n파도반 수열 P(N)은 나선에 있는 정삼각형의 변의 길이이다. P(1)부터 P(10)까지 첫 10개 숫자는 1, 1, 1, 2, 2, 3, 4, 5, 7, 9이다.\nN이 주어졌을 때, P(N)을 구하는 프로그램을 작성하시오.","title":"AlgorithmStudy_백준 9461"},{"content":"블로그를 Hugo를 이용해서 만들었는데, 열심히 html 코드로 텍스트에 컬러를 넣었지만 빌드를 하고 보니 텍스에 컬러가 적용이 되어있지않았다!\r알고 보니.. MarkDown에서는 본래 text color change를 지원하지 않는다.\r그리고 이것을 html을 이용해서 그 기능을 수행했던 것. 그런데 Hugo자체에서 html을 막아놨던 것!😑😑\r그냥 사용하는 방법으로는 unsafe를 True로 바꾸면 되지만... (막은데에는 이유가 있을거라고 생각하고...다른 방법을 선택!)\r그래서 이런 html코드를 수행해주는 새로운 코드들을 적용 시켜줘야하는데 고것이 바로 Shortcode!\r 참조\nShortcode란 🧐  Shortcodes are simple snippets inside your content files calling built-in or custom templates.\n 여기서 snippet이란 재사용이 가능한 소스코드이다. 우리가 작성하는 content안에서 이 Shortcode를 불러옴으로서 원하는 기능을 수행할 수 있게 해준다.\n {{\u0026lt; Shortcode Parmeters \u0026gt;}} 형식을 따라 MarkDown에서 사용이 가능하다! html 코드들을 적용 시킬 수 있다!  자세한 설명\nShortcode를 이용해 Text에 Color 입히기 🎨   layout 폴더 아래 shortcodes라는 이름으로 폴더 생성!\n  자신이 이 Shortcode를 부를 때 사용할 이름으로 [Name].html 파일 생성! (내 경우 이름을 color라고 지정)\n  \u0026lt;span style=color:{{ .Get \u0026quot;color\u0026quot; }}\u0026gt;{{ .Get \u0026quot;text\u0026quot; }}\u0026lt;/span\u0026gt;  작성!\n  content를 만들 때 색깔을 입히고 싶은 곳에 {{\u0026lt; [Name] color=\u0026#34;[Color]\u0026#34; text=\u0026#34;[Text]\u0026#34; \u0026gt;}} 요로코롬 Shortcode를 호출하고 적용!\n  처음에는 이해하기 어려웠는데 Unity에서 쓰는 Component랑 비슷하다고 생각하니 개념에 좀 더 쉽게 다가갈 수 있었다.(어떤 오브젝트에게 어떠한 일을 시키고 싶을 때 Component를 추가하는 것 처럼?)\n","permalink":"https://qutrits.github.io/posts/dummy/markdown1/","summary":"블로그를 Hugo를 이용해서 만들었는데, 열심히 html 코드로 텍스트에 컬러를 넣었지만 빌드를 하고 보니 텍스에 컬러가 적용이 되어있지않았다!\r알고 보니.. MarkDown에서는 본래 text color change를 지원하지 않는다.\r그리고 이것을 html을 이용해서 그 기능을 수행했던 것. 그런데 Hugo자체에서 html을 막아놨던 것!😑😑\r그냥 사용하는 방법으로는 unsafe를 True로 바꾸면 되지만... (막은데에는 이유가 있을거라고 생각하고...다른 방법을 선택!)\r그래서 이런 html코드를 수행해주는 새로운 코드들을 적용 시켜줘야하는데 고것이 바로 Shortcode!\r 참조\nShortcode란 🧐  Shortcodes are simple snippets inside your content files calling built-in or custom templates.","title":"Hugo와 MarkDown: Text Color"},{"content":"알고리즘 공부 백준 1181 🧐 단어 정렬 👉문제 알파벳 소문자로 이루어진 N개의 단어가 들어오면 아래와 같은 조건에 따라 정렬하는 프로그램을 작성하시오.\n 길이가 짧은 것부터 길이가 같으면 사전 순으로  👉입력 첫째 줄에 단어의 개수 N이 주어진다. (1 ≤ N ≤ 20,000) 둘째 줄부터 N개의 줄에 걸쳐 알파벳 소문자로 이루어진 단어가 한 줄에 하나씩 주어진다. 주어지는 문자열의 길이는 50을 넘지 않는다.\n👉출력 조건에 따라 정렬하여 단어들을 출력한다. 단, 같은 단어가 여러 번 입력된 경우에는 한 번씩만 출력한다.\n🍑풀이 1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  using System; using System.Collections.Generic; using System.Linq; namespace Algorithm8 { class Beakjun1181 { static void Main(string[] args) { List\u0026lt;string\u0026gt; words = new List\u0026lt;string\u0026gt;(); var count = int.Parse(Console.ReadLine()!); for (int i = 0; i \u0026lt; count; i++) { string word = Console.ReadLine(); if (words.Exists(x=\u0026gt; x== word) == false) { words.Add(word); } } //알파벳 순으로 정렬  var list = words.OrderBy(x =\u0026gt; x); //길이 순으로 정렬  var result = list.OrderBy(x =\u0026gt; x.Length); Console.WriteLine(string.Join(\u0026#34;\\n\u0026#34;, result)); } } }   😿 풀이 2 시간초과로 맞히지 못한 Quick Sort를 이용한 풀이\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103  using System; using System.Collections.Generic; namespace Algorithm8 { class Beakjun1181 { static void Main(string[] args) { List\u0026lt;string\u0026gt; words = new List\u0026lt;string\u0026gt;(); var count = int.Parse(Console.ReadLine()!); for (int i = 0; i \u0026lt; count; i++) { string word = Console.ReadLine(); if (words.Exists(x=\u0026gt; x== word) == false) { words.Add(word); } } int left = 0; int right = words.Count - 1; Sort(left, right); void Sort(int _left, int _right) { if (_left \u0026gt;= _right) { return; } var pivot = Divide(_left, _right); Sort(_left, pivot - 1); Sort(pivot + 1, _right); } int Divide(int _left, int _right) { int _pivot = _left; _left++; while (true) { if (words[_pivot].Length \u0026gt;= words[_left].Length) { if (words[_pivot].Length == words[_left].Length)//길이가 같을 경우  { for (int i = 0; i \u0026lt; words[_pivot].Length; i++)//각 자리를 비교하기  { if (words[_pivot][i] \u0026lt; words[_left][i])//피봇의 알파벳이 우선일 경우  { break; } else if(words[_pivot][i] \u0026gt; words[_left][i])//피봇의 알파벳이 후순위일 경우  { _left++;//left를 한 칸 뒤로 옮기기  break; } } } else//피봇의 값이 왼쪽의 값보다 길 경우  { _left++;//left를 한 칸 옮기기  } } if (words[_pivot].Length \u0026lt;= words[_right].Length) { if (words[_pivot].Length == words[_right].Length)//길이가 같을 경우  { for (int i = 0; i \u0026lt; words[_pivot].Length; i++)//각 자리를 비교하기  { if (words[_pivot][i] \u0026gt; words[_left][i])//피봇의 알파벳이 후순위일 경우  { break; } else if (words[_pivot][i] \u0026lt; words[_right][i])//피봇의 알파벳이 우선일 경우  { _right--;//right를 한 칸 앞으로 옮기기  break; } } } else { _right--;//right를 한 칸 앞으로 옮기기  } } if (_left \u0026gt; _right)//left와 right가 역전되었을 경우  { break; } if (words[_left].Length \u0026gt; words[_right].Length)// left의 값이 right의 값보다 클 경우 서로 swap  { (words[_left], words[_right]) = (words[_right], words[_left]); } } (words[_pivot], words[_right]) = (words[_right], words[_pivot]);//역전된 right값과 pivot값을 swap  return _right;//right반환 =\u0026gt; 다음 pivot  } Console.WriteLine(string.Join(\u0026#34;\\n\u0026#34;, words)); }   최악의 경우 시간복잡도가 O(n^2)로 매우 성능이 떨어지게 된다. 아마 이걸 잡나보다\u0026hellip;. Quick Sort 말고 Merge Sort를 사용해 볼 걸 그랬다\u0026hellip;\n[문제풀러가기] (https://www.acmicpc.net/problem/1181)\n","permalink":"https://qutrits.github.io/posts/dummy/algorithm8/","summary":"알고리즘 공부 백준 1181 🧐 단어 정렬 👉문제 알파벳 소문자로 이루어진 N개의 단어가 들어오면 아래와 같은 조건에 따라 정렬하는 프로그램을 작성하시오.\n 길이가 짧은 것부터 길이가 같으면 사전 순으로  👉입력 첫째 줄에 단어의 개수 N이 주어진다. (1 ≤ N ≤ 20,000) 둘째 줄부터 N개의 줄에 걸쳐 알파벳 소문자로 이루어진 단어가 한 줄에 하나씩 주어진다. 주어지는 문자열의 길이는 50을 넘지 않는다.\n👉출력 조건에 따라 정렬하여 단어들을 출력한다. 단, 같은 단어가 여러 번 입력된 경우에는 한 번씩만 출력한다.","title":"AlgorithmStudy_백준 1181"},{"content":"알고리즘 공부 백준 1929 🧐 소수 구하기 👉문제 M이상 N이하의 소수를 모두 출력하는 프로그램을 작성하시오.\n👉입력 첫째 줄에 자연수 M과 N이 빈 칸을 사이에 두고 주어진다. (1 ≤ M ≤ N ≤ 1,000,000) M이상 N이하의 소수가 하나 이상 있는 입력만 주어진다.\n👉출력 한 줄에 하나씩, 증가하는 순서대로 소수를 출력한다.\n🍑풀이\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  using System; using System.Collections.Generic; using System.Linq; using System.Text; namespace Algorithm7 { class Beakjun1929 { static void Main(string[] args) { var list = Console.ReadLine()!.Split(\u0026#39; \u0026#39;).Select(int.Parse).ToArray(); int m = list[0]; int n = list[1]; List\u0026lt;int\u0026gt; result = new List\u0026lt;int\u0026gt;(); //소수의 정의 : 1과 자기자신으로 밖에 나눌 없는 것..  for (int i = m; i \u0026lt;= n; i++) { if (i == 1) { continue; } if (i is \u0026gt; 1 and \u0026lt; 4)//2, 3은 소수  { result.Add(i); continue; } if (i % 2 == 0)//2의 배수는 모두 합성수  { continue; } bool primeNum = true; for (int k = 1; (k * 2 + 1) \u0026lt;= Math.Sqrt(i); k++)//소수는 다 홀수이다. =\u0026gt; 2k + 1  { //합성수라면 수의 제곱근보다 작거나 같은 수가 존재한다.  if (i % (k * 2 + 1) == 0) { primeNum = false;//소수가 아니다!  break; } } if (primeNum == true) { result.Add(i); } } StringBuilder sb = new StringBuilder(String.Join(\u0026#34;\\n\u0026#34;, result.ToArray())); Console.WriteLine(sb); } } }   문제풀러가기\n","permalink":"https://qutrits.github.io/posts/dummy/algorithm7/","summary":"알고리즘 공부 백준 1929 🧐 소수 구하기 👉문제 M이상 N이하의 소수를 모두 출력하는 프로그램을 작성하시오.\n👉입력 첫째 줄에 자연수 M과 N이 빈 칸을 사이에 두고 주어진다. (1 ≤ M ≤ N ≤ 1,000,000) M이상 N이하의 소수가 하나 이상 있는 입력만 주어진다.\n👉출력 한 줄에 하나씩, 증가하는 순서대로 소수를 출력한다.\n🍑풀이\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  using System; using System.","title":"AlgorithmStudy_백준 1929"},{"content":"알고리즘 공부 백준 11866 🧐 오세푸스 문제 👉문제 요세푸스 문제는 다음과 같다.\n1번부터 N번까지 N명의 사람이 원을 이루면서 앉아있고, 양의 정수 K(≤ N)가 주어진다. 이제 순서대로 K번째 사람을 제거한다. 한 사람이 제거되면 남은 사람들로 이루어진 원을 따라 이 과정을 계속해 나간다. 이 과정은 N명의 사람이 모두 제거될 때까지 계속된다. 원에서 사람들이 제거되는 순서를 (N, K)-요세푸스 순열이라고 한다. 예를 들어 (7, 3)-요세푸스 순열은 \u0026lt;3, 6, 2, 7, 5, 1, 4\u0026gt;이다.\nN과 K가 주어지면 (N, K)-요세푸스 순열을 구하는 프로그램을 작성하시오.\n👉입력 첫째 줄에 N과 K가 빈 칸을 사이에 두고 순서대로 주어진다. (1 ≤ K ≤ N ≤ 1,000)\n👉출력 예제와 같이 요세푸스 순열을 출력한다.\n🍑풀이 1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61  using System; using System.Collections; using System.Collections.Generic; using System.Linq; using System.Text; namespace Algorithm1 { public static class Program { public static void Main() { var input = Console.ReadLine().Split(\u0026#39; \u0026#39;).Select(int.Parse).ToArray(); int n = input[0]; int k = input[1]; var index = k - 1; Queue result = new Queue(); int[] people = new int[n]; for (int i = 0; i \u0026lt; n; i++) { people[i] = i + 1; } //배열로 하는 풀이  while (result.Count != n)//결과의 갯수가 n 값이 아닌동안  { if (people[index] \u0026gt; 0)//값이 0보다 크면  { result.Enqueue(people[index]);//결과에 enqeue  people[index] = 0;//결과에 넣은 값은 0으로  } if (result.Count == n) { break; } for (int i = 0; i \u0026lt; k; i++)//k번동안 인덱스 변경  { index = (index + 1) % n;//n의 크기를 넘지 않도록 설계  while(people[index] == 0)//값이 0인 경우 횟수로 치지 않음  { index = (index + 1) % n; } } } StringBuilder st = new StringBuilder(); st.Append(\u0026#34;\u0026lt;\u0026#34;); st.Append(string.Join(\u0026#34;, \u0026#34;, result.ToArray())); st.Append(\u0026#34;\u0026gt;\u0026#34;); Console.WriteLine(st); } } }   🍑풀이 2\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  using System; using System.Collections; using System.Linq; namespace Algorithm1 { public static class Program { public static void Main() { var input = Console.ReadLine().Split(\u0026#39; \u0026#39;).Select(int.Parse).ToArray(); int n = input[0]; int k = input[1]; Queue result = new Queue(); Queue que = new Queue(); for (int i = 1; i \u0026lt;= n; i++) { que.Enqueue(i); } //queue를 이용한 풀이  while (result.Count != n) { for (int i = 0; i \u0026lt; k - 1; i++)//k-1번째까지는 dequeue 후 다시 enqueue  { var pop =que.Dequeue(); que.Enqueue(pop); } result.Enqueue(que.Dequeue());//k번째에 결과값에 추가  } var r = string.Join(\u0026#34;, \u0026#34;, result.ToArray()); Console.WriteLine($\u0026#34;\u0026lt;{r}\u0026gt;\u0026#34;); } } }   🤣🤣\n배열로 푼다고 고집부렸다가 애먹음..\n큐로 푸는 것이 정신건강에 좋은 것 같다.\n문제풀러가기\n","permalink":"https://qutrits.github.io/posts/dummy/algorithm6/","summary":"알고리즘 공부 백준 11866 🧐 오세푸스 문제 👉문제 요세푸스 문제는 다음과 같다.\n1번부터 N번까지 N명의 사람이 원을 이루면서 앉아있고, 양의 정수 K(≤ N)가 주어진다. 이제 순서대로 K번째 사람을 제거한다. 한 사람이 제거되면 남은 사람들로 이루어진 원을 따라 이 과정을 계속해 나간다. 이 과정은 N명의 사람이 모두 제거될 때까지 계속된다. 원에서 사람들이 제거되는 순서를 (N, K)-요세푸스 순열이라고 한다. 예를 들어 (7, 3)-요세푸스 순열은 \u0026lt;3, 6, 2, 7, 5, 1, 4\u0026gt;이다.\nN과 K가 주어지면 (N, K)-요세푸스 순열을 구하는 프로그램을 작성하시오.","title":"AlgorithmStudy_백준 11866"},{"content":"알고리즘 공부 백준 1920 🧐 수 찾기 👉문제 N개의 정수 A[1], A[2], …, A[N]이 주어져 있을 때, 이 안에 X라는 정수가 존재하는지 알아내는 프로그램을 작성하시오.\n👉입력 첫째 줄에 자연수 N(1 ≤ N ≤ 100,000)이 주어진다. 다음 줄에는 N개의 정수 A[1], A[2], …, A[N]이 주어진다. 다음 줄에는 M(1 ≤ M ≤ 100,000)이 주어진다. 다음 줄에는 M개의 수들이 주어지는데, 이 수들이 A안에 존재하는지 알아내면 된다. 모든 정수의 범위는 -231 보다 크거나 같고 231보다 작다.\n👉출력 M개의 줄에 답을 출력한다. 존재하면 1을, 존재하지 않으면 0을 출력한다.\n🍑풀이\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62  using System; using System.Linq; using System.Text; namespace Algorithm1 { public static class Program { public static void Main() { var count_n = int.Parse(Console.ReadLine()!); var n = Console.ReadLine()!.Split(\u0026#39; \u0026#39;).Select(int.Parse).ToArray(); var count_m = int.Parse(Console.ReadLine()!); var m = Console.ReadLine()!.Split(\u0026#39; \u0026#39;).Select(int.Parse).ToArray(); var result = new int[m.Length]; Array.Sort(n); for (int i = 0; i \u0026lt; count_m; i++) { if (m[i] \u0026lt; n[0] || m[i] \u0026gt; n[^1]) //값이 범위에서 벗어나면 0  { result[i] = 0; continue; } int pivot = count_n / 2; //이진탐색을 활용!  int left = 0; int right = count_n - 1; while (true) { if (left \u0026gt; right) { result[i] = 0; break; } else { if (m[i] == n[pivot]) // 피봇과 값이 같은 경우  { result[i] = 1; break; } else if (m[i] \u0026gt; n[pivot]) // 피봇의 값보다 큰 경우  { left = pivot + 1; } else // 피봇의 값보다 작은 경우  { right = pivot - 1; } pivot = (left + right) / 2; } } } Console.WriteLine(string.Join(\u0026#34;\\n\u0026#34;, result)); } } }   시간초과로 애먹었음\u0026hellip;\n출력 방식을 바꾸었더니 해결이 되었다..! (원래는 result를 돌면서 하나씩 출력했었다)\n문제풀러가기\n","permalink":"https://qutrits.github.io/posts/dummy/algorithm5/","summary":"알고리즘 공부 백준 1920 🧐 수 찾기 👉문제 N개의 정수 A[1], A[2], …, A[N]이 주어져 있을 때, 이 안에 X라는 정수가 존재하는지 알아내는 프로그램을 작성하시오.\n👉입력 첫째 줄에 자연수 N(1 ≤ N ≤ 100,000)이 주어진다. 다음 줄에는 N개의 정수 A[1], A[2], …, A[N]이 주어진다. 다음 줄에는 M(1 ≤ M ≤ 100,000)이 주어진다. 다음 줄에는 M개의 수들이 주어지는데, 이 수들이 A안에 존재하는지 알아내면 된다. 모든 정수의 범위는 -231 보다 크거나 같고 231보다 작다.","title":"AlgorithmStudy_백준 1920"},{"content":"C# 공부 string/StringBuilder🤔 ✨string  Immutable(불변) 변수. 값이 아닌 참조 변수. 내부적으로 문자열을 관리하는 버퍼를 가지고 있지않다. 대신 이를 참조하고 있다. string마다 새로운 클래스가 생성이 된다.  1 2 3 4  string a = \u0026#34;안녕\u0026#34; + \u0026#34;하세요\u0026#34;; //\u0026#34;안녕\u0026#34; \u0026#34;하세요\u0026#34; -\u0026gt; 각각의 string class 생성. //a string class 생성. //총 3개의 string class가 생성된다. -\u0026gt; 즉 garbage가 많이 생긴다.   ✨StringBuilder  내부적으로 버퍼를 가지고 있다. 조합이 가능하다. 즉, 조합할 때마다 새롭게 class를 생성하지않는다. 조합한 것을 string으로 반환이 가능하다. 길이가 충분히 길고 길이를 모를 때 사용하는 것이 바람직하다.  1 2 3 4 5 6  StringBuilder sb1 = new StringBuilder(\u0026#34;Hello\u0026#34;); //생성할 당시에 바로 넣기가 가능하다. StringBuilder sb2 = new StringBuilder(100); //버퍼공간을 미리 할당하는 것이 가능하다. //미리 할당을 해놓으면 크기가 넘어가는 데이터가 들어오기 전까지는 Append를 사용할 시 추가 공간을 마련하지않아도 되어 조금 더 빠르다.    🌟🌟 StringBuilder가 편리함에도 string이 필요한 이유  값의 변형없이 사용되는 string 에 대한 참조만이 필요할 경우.  1 2 3 4 5 6 7 8  string a = \u0026#34;immutable\u0026#34;; //s1, s2, s3는 내부적으로 버퍼를 가지고 있지않기 때문에 a와 같은 버퍼를 참조한다. //만약, string이 StringBuilder처럼 작동을 한다면... //s1, s2, s3는 내부적으로 버퍼를 가지고 있어야하고 이는 a의 내부 버퍼를 복사한 값을 가지고 있을 것이다. =\u0026gt; 메모리 낭비! string s1 = a; string s2 = b; string s3 = c;    멀티스레드 환경에서 string이 StringBuilder보다 안전하다.  1 2 3 4 5 6 7 8  string s = \u0026#34;a\u0026#34; + \u0026#34;b\u0026#34; + \u0026#34;c\u0026#34;; //string을 조합할 때는 연산의 최소 단위인 원자적 연산을 하기 때문에 스레드가 연산 중간에 간섭할 수 없어 값이 변할 위험이 없다.  StringBuilder sb = new StringBuilder(); sb.Append(\u0026#34;a\u0026#34;); sb.Append(\u0026#34;b\u0026#34;); sb.Append(\u0026#34;c\u0026#34;); //StringBuilder로 조합할 경우에는 원자적 연산이 아니기 때문에 멀티스레드 환경에서 값이 변형될 위험이 있다.   ","permalink":"https://qutrits.github.io/posts/dummy/csharp1/","summary":"C# 공부 string/StringBuilder🤔 ✨string  Immutable(불변) 변수. 값이 아닌 참조 변수. 내부적으로 문자열을 관리하는 버퍼를 가지고 있지않다. 대신 이를 참조하고 있다. string마다 새로운 클래스가 생성이 된다.  1 2 3 4  string a = \u0026#34;안녕\u0026#34; + \u0026#34;하세요\u0026#34;; //\u0026#34;안녕\u0026#34; \u0026#34;하세요\u0026#34; -\u0026gt; 각각의 string class 생성. //a string class 생성. //총 3개의 string class가 생성된다. -\u0026gt; 즉 garbage가 많이 생긴다.   ✨StringBuilder  내부적으로 버퍼를 가지고 있다. 조합이 가능하다. 즉, 조합할 때마다 새롭게 class를 생성하지않는다.","title":"c#_string_StringBuilder"},{"content":"알고리즘 공부 백준 1439 🧐 숫자의 합 👉문제 다솜이는 0과 1로만 이루어진 문자열 S를 가지고 있다. 다솜이는 이 문자열 S에 있는 모든 숫자를 전부 같게 만들려고 한다. 다솜이가 할 수 있는 행동은 S에서 연속된 하나 이상의 숫자를 잡고 모두 뒤집는 것이다. 뒤집는 것은 1을 0으로, 0을 1로 바꾸는 것을 의미한다.\n예를 들어 S=0001100 일 때,\n 전체를 뒤집으면 1110011이 된다. 4번째 문자부터 5번째 문자까지 뒤집으면 1111111이 되어서 2번 만에 모두 같은 숫자로 만들 수 있다.\n하지만, 처음부터 4번째 문자부터 5번째 문자까지 문자를 뒤집으면 한 번에 0000000이 되어서 1번 만에 모두 같은 숫자로 만들 수 있다.  문자열 S가 주어졌을 때, 다솜이가 해야하는 행동의 최소 횟수를 출력하시오.\n👉입력 첫째 줄에 문자열 S가 주어진다. S의 길이는 100만보다 작다.\n👉출력 첫째 줄에 다솜이가 해야하는 행동의 최소 횟수를 출력한다.\n🍑풀이\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  using System; public class Program { public static void Main() {\tvar list = Console.ReadLine(); int count_zero = 0;//0이 쓰여진 카드 그룹의 갯수 (1 이 나오기 전까지의 카드 그룹) \tint count_one = 0;//1 이 쓰여진 카드 그룹의 갯수 (0 이 나오기 전까지의 카드 그룹) \tfor(int i = 0; i \u0026lt; list.Length - 1; ++i) { if(list[i] != list[i + 1]) //다음 카드와 비교했을 때 서로 다른 카드일 경우 \t{\tif(list[i] == \u0026#39;0\u0026#39;) { if(count_zero == 0 \u0026amp;\u0026amp; count_one == 0)//맨 처음 분기점 일 경우 \t{ count_one++;//그룹이 하나 생성 \t} count_zero++;//그룹 생성 \t} else if(list[i] == \u0026#39;1\u0026#39;) { if(count_zero == 0 \u0026amp;\u0026amp; count_one == 0) { count_zero++; } count_one++; } } } var result = Math.Min(count_zero, count_one); //더 작은 값을 출력 \tConsole.WriteLine(result);\t}\t}   문제풀러가기\n이..친구는.. 네번이나 틀렸다눈\u0026hellip; ㅠㅠ\n","permalink":"https://qutrits.github.io/posts/dummy/algorithm4/","summary":"알고리즘 공부 백준 1439 🧐 숫자의 합 👉문제 다솜이는 0과 1로만 이루어진 문자열 S를 가지고 있다. 다솜이는 이 문자열 S에 있는 모든 숫자를 전부 같게 만들려고 한다. 다솜이가 할 수 있는 행동은 S에서 연속된 하나 이상의 숫자를 잡고 모두 뒤집는 것이다. 뒤집는 것은 1을 0으로, 0을 1로 바꾸는 것을 의미한다.\n예를 들어 S=0001100 일 때,\n 전체를 뒤집으면 1110011이 된다. 4번째 문자부터 5번째 문자까지 뒤집으면 1111111이 되어서 2번 만에 모두 같은 숫자로 만들 수 있다.","title":"AlgorithmStudy_백준 1439"},{"content":"알고리즘 공부 백준 1712 🧐 숫자의 합 👉문제 월드전자는 노트북을 제조하고 판매하는 회사이다. 노트북 판매 대수에 상관없이 매년 임대료, 재산세, 보험료, 급여 등 A만원의 고정 비용이 들며, 한 대의 노트북을 생산하는 데에는 재료비와 인건비 등 총 B만원의 가변 비용이 든다고 한다.\n예를 들어 A=1,000, B=70이라고 하자. 이 경우 노트북을 한 대 생산하는 데는 총 1,070만원이 들며, 열 대 생산하는 데는 총 1,700만원이 든다.\n노트북 가격이 C만원으로 책정되었다고 한다. 일반적으로 생산 대수를 늘려 가다 보면 어느 순간 총 수입(판매비용)이 총 비용(=고정비용+가변비용)보다 많아지게 된다. 최초로 총 수입이 총 비용보다 많아져 이익이 발생하는 지점을 손익분기점(BREAK-EVEN POINT)이라고 한다.\nA, B, C가 주어졌을 때, 손익분기점을 구하는 프로그램을 작성하시오.\n👉입력 첫째 줄에 A, B, C가 빈 칸을 사이에 두고 순서대로 주어진다. A, B, C는 21억 이하의 자연수이다.\n👉출력 첫 번째 줄에 손익분기점 즉 최초로 이익이 발생하는 판매량을 출력한다. 손익분기점이 존재하지 않으면 -1을 출력한다.\n🍑풀이 1\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  using System; public class Program { public static void Main() {\tstring input = Console.ReadLine(); var list = input.Split(\u0026#39; \u0026#39;); int fix = int.Parse(list[0]); int variable = int.Parse(list[1]); int price = int.Parse(list[2]); if(variable \u0026gt;= price)//가변지출이 제품 가격과 같거나 크면 손익이 날 수 없다. \t{ Console.WriteLine(-1);//-1 출력 \treturn; } int count = 1; int cost = 0; while(true) //카운트를 1씩 올리면서 손익분기점을 찾는다 \t{ cost = fix + variable * count; //총 비용 = 고정지출 + 가변지출 * 제품 갯수 \tif(price * count - cost \u0026gt; 0 )//순 이익 = 제품 가격 * 제품 갯수 - 총 비용 \t{ break; } count++; } Console.WriteLine(count); } }   🍑풀이 2\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  using System; public class Program { public static void Main() {\tstring input = Console.ReadLine(); var list = input.Split(\u0026#39; \u0026#39;); int fix = int.Parse(list[0]); int variable = int.Parse(list[1]); int price = int.Parse(list[2]); if(variable \u0026gt;= price) { Console.WriteLine(-1); return; } int count = 1; // 0이 되는 지점 =\u0026gt; fix + variable * count = price * count  // fix = (price - variable) * count \tcount = fix/(price - variable) + 1; Console.WriteLine(count); } }   문제풀러가기\n","permalink":"https://qutrits.github.io/posts/dummy/algorithm3/","summary":"알고리즘 공부 백준 1712 🧐 숫자의 합 👉문제 월드전자는 노트북을 제조하고 판매하는 회사이다. 노트북 판매 대수에 상관없이 매년 임대료, 재산세, 보험료, 급여 등 A만원의 고정 비용이 들며, 한 대의 노트북을 생산하는 데에는 재료비와 인건비 등 총 B만원의 가변 비용이 든다고 한다.\n예를 들어 A=1,000, B=70이라고 하자. 이 경우 노트북을 한 대 생산하는 데는 총 1,070만원이 들며, 열 대 생산하는 데는 총 1,700만원이 든다.\n노트북 가격이 C만원으로 책정되었다고 한다. 일반적으로 생산 대수를 늘려 가다 보면 어느 순간 총 수입(판매비용)이 총 비용(=고정비용+가변비용)보다 많아지게 된다.","title":"AlgorithmStudy_백준 1712"},{"content":"블로그 처음 만든날..  이제부터 여기에 공부한 거 매일매일 올릴거야 진짜루 매일매일 할꼬야 왜 안고쳐지는거지 ?  1 2 3 4  private void A() { }   ","permalink":"https://qutrits.github.io/posts/dummy/my-first-post/","summary":"블로그 처음 만든날..  이제부터 여기에 공부한 거 매일매일 올릴거야 진짜루 매일매일 할꼬야 왜 안고쳐지는거지 ?  1 2 3 4  private void A() { }   ","title":"My First Post"},{"content":"알고리즘 공부 백준 11399 🧐 ATM 👉문제 인하은행에는 ATM이 1대밖에 없다. 지금 이 ATM앞에 N명의 사람들이 줄을 서있다. 사람은 1번부터 N번까지 번호가 매겨져 있으며, i번 사람이 돈을 인출하는데 걸리는 시간은 Pi분이다.\n사람들이 줄을 서는 순서에 따라서, 돈을 인출하는데 필요한 시간의 합이 달라지게 된다. 예를 들어, 총 5명이 있고, P1 = 3, P2 = 1, P3 = 4, P4 = 3, P5 = 2 인 경우를 생각해보자. [1, 2, 3, 4, 5] 순서로 줄을 선다면, 1번 사람은 3분만에 돈을 뽑을 수 있다. 2번 사람은 1번 사람이 돈을 뽑을 때 까지 기다려야 하기 때문에, 3+1 = 4분이 걸리게 된다. 3번 사람은 1번, 2번 사람이 돈을 뽑을 때까지 기다려야 하기 때문에, 총 3+1+4 = 8분이 필요하게 된다. 4번 사람은 3+1+4+3 = 11분, 5번 사람은 3+1+4+3+2 = 13분이 걸리게 된다. 이 경우에 각 사람이 돈을 인출하는데 필요한 시간의 합은 3+4+8+11+13 = 39분이 된다.\n줄을 [2, 5, 1, 4, 3] 순서로 줄을 서면, 2번 사람은 1분만에, 5번 사람은 1+2 = 3분, 1번 사람은 1+2+3 = 6분, 4번 사람은 1+2+3+3 = 9분, 3번 사람은 1+2+3+3+4 = 13분이 걸리게 된다. 각 사람이 돈을 인출하는데 필요한 시간의 합은 1+3+6+9+13 = 32분이다. 이 방법보다 더 필요한 시간의 합을 최소로 만들 수는 없다.\n줄을 서 있는 사람의 수 N과 각 사람이 돈을 인출하는데 걸리는 시간 Pi가 주어졌을 때, 각 사람이 돈을 인출하는데 필요한 시간의 합의 최솟값을 구하는 프로그램을 작성하시오. 👉입력 첫째 줄에 사람의 수 N(1 ≤ N ≤ 1,000)이 주어진다. 둘째 줄에는 각 사람이 돈을 인출하는데 걸리는 시간 Pi가 주어진다. (1 ≤ Pi ≤ 1,000)\n👉출력 첫째 줄에 각 사람이 돈을 인출하는데 필요한 시간의 합의 최솟값을 출력한다.\n🍑풀이\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  using System; using System.Linq; public class Program { public static void Main() {\tint people; people = int.Parse(Console.ReadLine()); //시간이 가장 적은 사람이 순으로 줄을 서면 전체가 돈을 인출하는 시간의 총합이 줄어들음 \tvar list = Console.ReadLine().Split(\u0026#39; \u0026#39;).Select((int.Parse)).ToArray();\tArray.Sort(list);//정렬 \tvar result = list[0]; for(int i = 1; i \u0026lt; list.Length; ++i) { list[i] = list[i-1] + list[i]; result += list[i];//걸리는 시간 더하기 \t} Console.WriteLine(result); }\t}   문제풀러가기\n","permalink":"https://qutrits.github.io/posts/dummy/algorithm2/","summary":"알고리즘 공부 백준 11399 🧐 ATM 👉문제 인하은행에는 ATM이 1대밖에 없다. 지금 이 ATM앞에 N명의 사람들이 줄을 서있다. 사람은 1번부터 N번까지 번호가 매겨져 있으며, i번 사람이 돈을 인출하는데 걸리는 시간은 Pi분이다.\n사람들이 줄을 서는 순서에 따라서, 돈을 인출하는데 필요한 시간의 합이 달라지게 된다. 예를 들어, 총 5명이 있고, P1 = 3, P2 = 1, P3 = 4, P4 = 3, P5 = 2 인 경우를 생각해보자. [1, 2, 3, 4, 5] 순서로 줄을 선다면, 1번 사람은 3분만에 돈을 뽑을 수 있다.","title":"AlgorithmStudy_백준 11399"},{"content":"알고리즘 공부 백준 11720 🧐 숫자의 합 👉문제 N개의 숫자가 공백 없이 쓰여있다. 이 숫자를 모두 합해서 출력하는 프로그램을 작성하시오.\n👉입력 첫째 줄에 숫자의 개수 N (1 ≤ N ≤ 100)이 주어진다. 둘째 줄에 숫자 N개가 공백없이 주어진다.\n👉입력 입력으로 주어진 숫자 N개의 합을 출력한다.\n🍑풀이\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  using System;\tpublic class Program { public static void Main() {\tint count = int.Parse(Console.ReadLine()); //입력받아 int로 전환 \tstring nums = Console.ReadLine(); //공백없이 숫자 입력 \tint result = 0; foreach(var item in nums)//item : char \t{ //변환된 값을 더하기. \tresult += int.Parse(item.ToString());//char-\u0026gt;string-\u0026gt;int \t} Console.WriteLine(result);\t}\t}   문제풀러가기\n","permalink":"https://qutrits.github.io/posts/dummy/algorithm1/","summary":"알고리즘 공부 백준 11720 🧐 숫자의 합 👉문제 N개의 숫자가 공백 없이 쓰여있다. 이 숫자를 모두 합해서 출력하는 프로그램을 작성하시오.\n👉입력 첫째 줄에 숫자의 개수 N (1 ≤ N ≤ 100)이 주어진다. 둘째 줄에 숫자 N개가 공백없이 주어진다.\n👉입력 입력으로 주어진 숫자 N개의 합을 출력한다.\n🍑풀이\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  using System;\tpublic class Program { public static void Main() {\tint count = int.","title":"AlgorithmStudy_백준 11720"},{"content":"[아이템 33] 타입 안전 이종 컨테이너를 고려하라. 타입 안전 이종 컨테이너 패턴이란 키를 매개변수화한 다음, 컨테이너에 값을 넣거나 뺄 때 매개변수화한 키를 함께 제공하는 방식입니다.\n1 2 3 4 5  // 타입 안전 이종 컨테이너 패턴 - API public class Favorites { public \u0026lt;T\u0026gt; void putFavorite(Class\u0026lt;T\u0026gt; type, T instance); public \u0026lt;T\u0026gt; getFavorite(Class\u0026lt;T\u0026gt; type); }   다음은 Favorite 클래스를 사용하는 예시입니다.\n1 2 3 4 5 6 7 8 9 10  // 타입 안전 이종 컨태이너 패턴 - 클라이언트 Favorites f = new Favorites(); f.putFavorite(String.class, \u0026#34;JAVA\u0026#34;); f.putFavorite(Integer.class, 0xcafebabe); f.putFavorite(Class.class, Favorite.class); String favoriteString = f.getFavorite(String.class); Integer favoriteInteger = f.getFavorite(Integer.class); Class\u0026lt;?\u0026gt; favoriteClass = f.getFavorite(Class.class);   favorite 인스턴스는 type safe합니다. String을 요청했는데 Integer를 반환할 일이 없습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13  // 타입 안전 이종 컨태이너 패턴 - 구현 public class Favorites { private Map\u0026lt;Class\u0026lt;?\u0026gt;, Object\u0026gt; favorite = new HashMap\u0026lt;\u0026gt;(); public \u0026lt;T\u0026gt; void putFavorite(Class\u0026lt;T\u0026gt; type, T instance) { favorite.put(Objects.requireNonNull(type), instance); } public \u0026lt;T\u0026gt; T getFavorite(Class\u0026lt;T\u0026gt; type) { return type.cast(favorites.get(type)); } }   Map\u0026lt;Class\u0026lt;?\u0026gt;, Object\u0026gt;에서 비한정적 와일드카드 타입을 사용해서 값을 아무것도 넣을 수 없을 거라고 생각할 수 있지만, 맵이 아니라 키가 와일드카드 타입이라서 값을 넣을 수 있습니다.\n지금 만든 Favorites 클래스에 주의점이 두 가지가 있습니다.\n첫 번째는 Class 객체를 raw type으로 넘기면 Favorites 인스턴스의 타입 안전성이 쉽게 깨집니다. Favorites가 타입 불변식이 어기는 일이 없도록 보장하려면 다음과 같이 수정할 수 있습니다.\n1 2 3  public \u0026lt;T\u0026gt; void putFavorite(Class\u0026lt;T\u0026gt; type, T instance) { favorites.put(Objects.requireNonNull(type, type.cast(instance))); }   java.util.Collections에는 checkedSet, checkedList, checkedMap 가 대표적으로 이 방식을 적용한 메서드입니다.\n두 번째는 실체화 불가 타입에는 사용할 수 없다는 것입니다. String이나 String[]는 저장할 수 있어도 List\u0026lt;String\u0026gt;은 저장할 수 없습니다. List\u0026lt;String\u0026gt;이나 List\u0026lt;Integer\u0026gt;는 List.class라는 같은 Class 객체를 공유하기 때문입니다.\n정리  컬렉션 API로 대표되는 일반적인 제네릭 형태에서는 한 컨테이너가 다룰 수 있는 타입 매개변수의 수가 고정되어 있습니다. 컨테이너 자체가 아닌 키를 타입 매개변수로 바꾸면 이런 제약이 없는 타입 안전 이종 컨테이너를 만들 수 있습니다. 타입 안전 이종 컨테이너는 Class를 키로 쓰며, 이런 식으로 쓰이는 Class 객체를 타입 토큰이라 합니다.  ","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-04/item33/","summary":"[아이템 33] 타입 안전 이종 컨테이너를 고려하라. 타입 안전 이종 컨테이너 패턴이란 키를 매개변수화한 다음, 컨테이너에 값을 넣거나 뺄 때 매개변수화한 키를 함께 제공하는 방식입니다.\n1 2 3 4 5  // 타입 안전 이종 컨테이너 패턴 - API public class Favorites { public \u0026lt;T\u0026gt; void putFavorite(Class\u0026lt;T\u0026gt; type, T instance); public \u0026lt;T\u0026gt; getFavorite(Class\u0026lt;T\u0026gt; type); }   다음은 Favorite 클래스를 사용하는 예시입니다.\n1 2 3 4 5 6 7 8 9 10  // 타입 안전 이종 컨태이너 패턴 - 클라이언트 Favorites f = new Favorites(); f.","title":"[아이템 33] 타입 안전 이종 컨테이너를 고려하라"},{"content":"[아이템 32] 제네릭과 가변인수를 함께 쓸 때는 신중하라. 가변인수와 제네릭은 자바 5에 함께 추가되었는데 이 둘은 서로 어울리지 않습니다.\n가변인수(varargs)란 메서드에 넘기는 인수의 개수를 클라이언트가 조절할 수 있게 해주는 것입니다. 구현 방식에 허점이 있습나다. 가변인수 메서드를 호출하면 가변인수를 담기 위한 배열이 자동으로 하나 만들어집니다. 그런데 내부로 감춰야 했을 이 배열을 그만 클라이언트에 노출하는 문제가 생겼습니다. 그 결과 verargs 매개변수에 제네릭이나 매개변수화 타입이 포함되면 알기 어려운 컴파일 경고가 발생합니다.\n실체화 불가 타입은 런타임에 컴파일보다 타입 관련 정보를 적게 담고 있습니다. 그리고 거의 모든 제네릭과 매개변수화 타입은 실체화되지 않습니다. 메서드 선언할 때 실체화 불가 타입으로 varargs 매겨변수를 선언하면 컴파일러가 경고를 보냅니다. 가변인수 메서드를 호출할 때도 varags 매개변수가 실체화 불가 타입으로 추론되면, 그 호출에 대해서도 경고를 냅니다.\n매개변수화 타입의 변수가 타입이 다른 다른 객체를 참조하면 힙 오염이 발생합니다. 이렇게 다른 타입 객체를 참조하는 상황에서는 컴파일러가 자동 생성한 형변환이 실패할 수 있으니, 제네릭 타입 시스템이 약속한 타입 안전성의 근간이 흔들려버립니다. 다음 메서드를 예로 생각해봅시다.\n1 2 3 4 5 6  static void dangerous(List\u0026lt;String\u0026gt;... stringList) { List\u0026lt;Integer\u0026gt; integerList = Collections.singletonList(42); Object[] objects = stringList; objects[0] = integerList; // 힙 오염  String s = stringList[0].get(0); // ClassCaseException  }   가변인수와 제네릭을 사용하는 메서드는 대표적으로 Arrys.asList, Collections.addAll등이 있습니다. JAVA 7부터는 @SafeVarargs 에너테이션을 사용해서 그 메서드가 타입 안전성을 보장한다는 걸 알려줄 수 있습니다.\n메서드가 이 배열에 아무것도 저장하지 않는다면 괜찮지만 아무것도 저장하지 않고도 타입 안전성을 깨뜨릴 수 있습니다.\n1 2 3  static \u0026lt;T\u0026gt; T[] toArrays(T... args) { return args; }   이 메서드가 반환하는 타입은 이 메서드에 인수를 넘기는 컴파일타임에 결정되는데, 그 시점에는 컴파일러에게 충분한 정보가 주이지지 않아 타입을 잘못 판단할 수 있습니다. 따라서 varargs 매개변수 배열을 그대로 반환하면 힙 오염을 이 메서드를 호출한 쪽의 콕스 택으로 까지 전이할 수도 있습니다.\n1 2 3 4 5 6 7 8  static \u0026lt;T\u0026gt; T[] pickTwo(T a, T b, T c) { switch (ThreadLocalRandom.current().nextInt(3)) { case 0: return toArrays(a, b); case 1: return toArrays(a, c); case 2: return toArrays(c, b); } throw new AssertionError(); }   toArray 메서드가 돌려준 이 배열이 그대로 pickTwo를 호출한 클라이언트까지 전달되는데 항상 Object[] 타입 배열을 반환하게 됩니다.\n1  String[] attributes = pickTwo(\u0026#34;좋은\u0026#34;, \u0026#34;빠른\u0026#34;, \u0026#34;저렴한\u0026#34;);   런타임시 ClassCastException을 던집니다. pickTwo에서 Object[]을 반환하는데 String[]으로 변환하려고 해서 예외가 발생합니다.\n배열 내용의 일부 함수를 호출하는(varargs를 받지 않는)일반 메서드에 넘기는 것은 안전합니다.\n1 2 3 4 5 6 7 8  @SafeVarargs static \u0026lt;T\u0026gt; List\u0026lt;T\u0026gt; flatten(List\u0026lt;? extends T\u0026gt;... lists) { List\u0026lt;T\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); for (List\u0026lt;? extends T\u0026gt; list : lists) { result.addAll(list); } return result; }   임의 개수의 리스트를 받아서, 순서대로 그 안의 모든 원소를 하나의 리스트로 옮겨 반환하는 메서드입니다. @SafeVarargs 애너테이션은 안전하지 않은 varargs 메서드에는 절대 작성해서는 안 됩니다. 힙 오염 경고가 뜨면 무조건 검증을 해야합니다. 그리고 재정의할 수 없는 메서드에만 달아야 합니다. 재정의한 메서드도 안전할지는 보장할 수 없기 때문입니다.\n1 2 3 4 5 6 7  static \u0026lt;T\u0026gt; List\u0026lt;T\u0026gt; flatten(List\u0026lt;List\u0026lt;? extends T\u0026gt;\u0026gt; lists) { List\u0026lt;T\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); for (List\u0026lt;? extends T\u0026gt; list : lists) { result.addAll(list); } return result; }   위와 같이 @SafeVarargs 애너테이션을 사용하지 않고 verargs 매개변수를 List 매개변수로 바꿀 수도 있습니다.\n정리  가변인수와 제네릭은 궁합이 좋지 않습니다. 가변인수 기능은 배열을 노출하여 추상화가 완벽하지 못하고, 배열과 제네릭의 타입 규칙이서 서로 다르기 때문입니다. 제네릭 verargs 매개변수는 type safe하지 않지만, 허용됩니다. verargs 매개변수를 사용하려면 타입이 안전한지 확인하고 @SafeVarargs 애너테이션을 이용합시다.  ","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-04/item32/","summary":"[아이템 32] 제네릭과 가변인수를 함께 쓸 때는 신중하라. 가변인수와 제네릭은 자바 5에 함께 추가되었는데 이 둘은 서로 어울리지 않습니다.\n가변인수(varargs)란 메서드에 넘기는 인수의 개수를 클라이언트가 조절할 수 있게 해주는 것입니다. 구현 방식에 허점이 있습나다. 가변인수 메서드를 호출하면 가변인수를 담기 위한 배열이 자동으로 하나 만들어집니다. 그런데 내부로 감춰야 했을 이 배열을 그만 클라이언트에 노출하는 문제가 생겼습니다. 그 결과 verargs 매개변수에 제네릭이나 매개변수화 타입이 포함되면 알기 어려운 컴파일 경고가 발생합니다.\n실체화 불가 타입은 런타임에 컴파일보다 타입 관련 정보를 적게 담고 있습니다.","title":"[아이템 32] 제네릭과 가변인수를 함께 쓸 때는 신중하라"},{"content":"[아이템 31] 한정적 와일드카드를 사용해 API 유연성을 높여라. 때론 불공변 방식보다 유연한 무언가가 필요할 때가 있습니다.\n아이템29의 Stack 클래스를 떠올려보면\n1 2 3 4 5 6  public class Stack\u0026lt;T\u0026gt; { public Stack(); public void push (E e); public E pop(); public boolean isEmpty(); }   여기서 일련의 원소를 스택에 넣는 메서드를 추가한다고 하면\n1 2 3 4 5  public void pushAll(Iterable\u0026lt;E\u0026gt; src) { for (E e : src) { push(e); } }   Iterable src의 원소 타입의 스택의 원소 타입과 일치하면 잘 작동합니다. 하지만 Stack\u0026lt;Number\u0026gt;로 선언한 후 pushAll(intVal)을(Iteger 타입) 호출하면 오류가 뜹니다. 매개변수 타입이 불공변이기 떄문입니다.\n이러한 상황에서는 한정된 와일드카드(unbounded wildcard)를 이용해서 해결할 수 있습니다. pushAll의 입력 매개변수 타입은 \u0026lsquo;E의 iterable\u0026lsquo;이 아니라 \u0026lsquo;E의 하위타입 Iterable\u0026lsquo;이어야 하며, 와일드 카드 Iterable\u0026lt;? extends E\u0026gt;가 정확히 이런뜻입니다.\n1 2 3 4 5  public void pushAll(Iterable\u0026lt;? extends E\u0026gt; src) { for (E e : src) { push(e); } }   위와 같이 수정할 수 있습니다. 이번에는 popAll메서드를 와일드카드 타입을 사용하지 않고 작성해 보겠습니다.\n1 2 3 4 5 6  // 와일드카드 타입을 사용하지 않은 메서드 - 결함이 있습니다. public void popAll(Collection\u0026lt;E\u0026gt; dst) { while (!isEmpty()) { dst.add(pop()); } }   1 2 3  Stack\u0026lt;Number\u0026gt; numberStack = new Stack\u0026lt;\u0026gt;(); Collection\u0026lt;Object\u0026gt; objects = ...; numberStack.popAll(objects);   컴파일 하면 \u0026ldquo;Collection\u0026lt;Object\u0026gt;는 Collection\u0026lt;Nummber\u0026gt;의 하위 타입이 아니다\u0026rdquo; 라는 오류가 발생합니다. 이번에는 반대로 \u0026lsquo;E의 Collection\u0026rsquo; 이 아니라 \u0026lsquo;E의 상위타입 Collection\u0026rsquo; 이어야 합니다.\n1 2 3 4 5 6  // 와을드카드 타입을 사용하지 않은 메서드 - 결함이 있습니다. public void popAll(Collection\u0026lt;E super E\u0026gt; dst) { while (!isEmpty()) { dst.add(pop()); } }   위와 같이 수정할 수 있습니다. 메세지는 분명합니다. 유연성을 극대화하려면 원소의 생산자나 소비자용 매개변수에 와일드 카드를 사용합시다. 한편,입력 매개변수가 생상자와 소비자 역할을 동시에 한다면 와일드카드 타입을 써도 좋을 게 없습니다. 타입을 정확히 지정해야 하는 상황으로, 이때는 와일드카드 타입을 쓰지말아야합니다.\n다음 공식을 외워두면 어떤 와일드 카드 타입을 써야 하는지 도움이 될 것입니다.\n PECS: producer-extends, consumer-super\n 즉 매개변수화 타입 T가 생성자라면 \u0026lt;? extends T\u0026gt;를 사용하고, 소비자라면 \u0026lt;?super T\u0026gt;를 사용합시다.\n클래스 사용자가 와일드카드 타입을 신경 써야 한다면 그 API에 무슨 문제가 있을 가능성이 큽니다.\n1 2  // 아이템30 에서 사용했던 코드 public static \u0026lt;E extends Comparable\u0026lt;E\u0026gt;\u0026gt; E max(List\u0026lt;E\u0026gt; c);   아이템30\n위 코드를 와일드카드 타입을 사용해 다듬은 모습입니다.\n1 2  // 아이템30 에서 사용했던 코드 public static \u0026lt;E extends Comparable\u0026lt;? super E\u0026gt;\u0026gt; E max(List\u0026lt;? extends E\u0026gt; c);   위 코드는 PECS 공식을 두 번 적용했습니다. 입력 매개변수에서는 E 인스턴스를 생산하므로 원래의 List\u0026lt;E\u0026gt;를 List\u0026lt;? extends E\u0026gt;로 수정했습니다.\n원래 선언에서는 E가 Comparale\u0026lt;E\u0026gt;를 확장한다고 정의했는데, 이때 Comparable\u0026lt;E\u0026gt;는 E인스턴스를 소비합니다. (그리고 선후 관계를 뜻하는 정수를 생산합니다) 그래서 매개변수화 타입 Comparable\u0026lt;E\u0026gt;는 E 한정적 와일드카드 타입 Comparable\u0026lt;? super E\u0026gt;로 대체 했습니다.\nComparable은 언제나 소비자이므로, 일반적으로 Comparable, Comparable\u0026lt;E\u0026gt;보다는 Comparable\u0026lt;? super E\u0026gt;를 사용하는 편이 낫습니다.\nComparator도 마찬가지입니다. 일반적으로 Comparator\u0026lt;E\u0026gt;보다는 Comparator\u0026lt;? super E\u0026gt;를 사용하는 편이 낫습니다.\n와일드카드와 관련해 논의해야 할 주제가 더 있습니다. 타입 매개변수와 와일드카드에 공통되는 부분이 있어서, 메서드를 정의할 때 둘 중 어느것을 사용해도 괜찮을 때가 많습니다.\n1 2  public static \u0026lt;E\u0026gt; void swap(List\u0026lt;E\u0026gt; list, int i, int j); public static swap(List\u0026lt;?\u0026gt; list, int i, int j);   public API라면 간단한 두 번째가 낫습니다. 어떤 리스트든 이 메서드에 넘기면 명시한 인덱스의 원소들을 교환해 줄 것입니다. 신경 써야 할 타입 매개변수도 없습니다.\n기본 규칙은 이렇습니다. 메서드에 선언에 타입 매개변수가 한 번만 나오면 와일드카드로 대체하라. 이때 비한정적 타입 매개변수라면 비한정적 와일드카드로 바꾸고, 한정적 타입 매개변수라면 한정적 와일드카드로 바꾸면 됩니다.\n하지만 두 번째 swap 선언에는 문제가 하나 있는데, 다음과 같이 직관적으로 구현한 코드가 컴파일 되지 않는다는 것입니다.\n1 2 3 4  public static swap(List\u0026lt;?\u0026gt; list, int i, int j) { list.set(i, list.set(j, list.get(i))); } // 방금 꺼낸 원소를 리스트에 다시 넣을 수 없습니다.   원인 리스트의 타입이 List\u0026lt;?\u0026gt;인데, List\u0026lt;?\u0026gt;에는 null 외에는 어떤 값도 넣을 수 없기 때문입니다.\n1 2 3 4 5 6 7 8  public static swap(List\u0026lt;?\u0026gt; list, int i, int j) { swapHelper(list, i, j); } // 와일드카드 타입을 실제 타입으로 바꿔주는 private 도우미 메서드 public static \u0026lt;E\u0026gt; void swapHelper(List\u0026lt;E\u0026gt; list, int i, int j) { list.set(i, list.set(j, list.get(i))); }   swapHelper 메서드는 리스트가 List\u0026lt;E\u0026gt;임을 알고 있습니다. 즉, 이 리스트에서 꺼낸 값은 항상 E이고, E 타입의 값이라면 이 리스트에 넣어도 안전함을 알고 있습니다.\n다소 복잡하지만 덕분에 외부에서는 와일드카드 기반의 멋진 선언을 유지할 수 있습니다. 즉 swap 메서드를 호출 하는 클라이언트는 복잡힌 swapHelper의 존재를 모른 채 그 혜택을 누리는 것입니다.\n","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-04/item31/","summary":"[아이템 31] 한정적 와일드카드를 사용해 API 유연성을 높여라. 때론 불공변 방식보다 유연한 무언가가 필요할 때가 있습니다.\n아이템29의 Stack 클래스를 떠올려보면\n1 2 3 4 5 6  public class Stack\u0026lt;T\u0026gt; { public Stack(); public void push (E e); public E pop(); public boolean isEmpty(); }   여기서 일련의 원소를 스택에 넣는 메서드를 추가한다고 하면\n1 2 3 4 5  public void pushAll(Iterable\u0026lt;E\u0026gt; src) { for (E e : src) { push(e); } }   Iterable src의 원소 타입의 스택의 원소 타입과 일치하면 잘 작동합니다.","title":"[아이템 31] 한정적 와일드카드를 사용해 API 유연성을 높여라"},{"content":"[아이템 30] 이왕이면 제네릭 메서드로 만들라. 제네릭 메서드는 대표적으로 Collections의 알고리즘 메서드(binarySearch, sort 등..)가 있습니다. 사용 방법은 리턴타입 앞에다 타입을 명시해주면 됩니다. 다음은 두 집합의 합집합을 반환하는 문제가 있는 메서드입니다.\n1 2 3 4 5 6  // raw tyoe 사용 - 수용 불가 public static Set union(Set s1, Set s2) { Set result = new HashSet(s1); result.addAll(s2); return result; }   컴파일은 되지만 경고가 발생합니다. 경고를 없애려면 이 메서드 타입을 안전하게 만들어야 합니다. 다음 코드에서 타입 매개변수 목록은 \u0026lt;E\u0026gt;이고 반환 타입은 Set\u0026lt;E\u0026gt;입니다.\n1 2 3 4 5  public static \u0026lt;E\u0026gt; Set\u0026lt;E\u0026gt; union(Set\u0026lt;E\u0026gt; s1, Set\u0026lt;E\u0026gt; s2) { Set\u0026lt;E\u0026gt; result = new HashSet\u0026lt;\u0026gt;(s1); result.addAll(s2); return result; }   다음 코드는 이 메서드를 사용하는 프로그램입니다. 직접 형변환 하지 않아도 어떤 오류나 경고 없이 컴파일 됩니다.\n1 2 3 4 5 6  public static void main(Sting[] args) { Set\u0026lt;String\u0026gt; guys = Set.of(\u0026#34;pual\u0026#34;, \u0026#34;jin\u0026#34;); Set\u0026lt;String\u0026gt; stooges = Set.of(\u0026#34;jerry\u0026#34;, \u0026#34;sia\u0026#34;); Set\u0026lt;String\u0026gt; aflCio = union(guys, stooges); System.out.println(aflCio); }   이를 한정적 와일드카드 타입을 사용하면 더 유연하게 개선할 수 있습니다.\n제네릭은 런타임에 타입 정보가 소거되므로 하나의 객체를 어떤 타입으로든 매개변수화 할 수가 있습니다. 하지만 이렇게 하려면 요청한 타입 매개변수에 맞게 매번 그 객체의 타입을 바꿔주는 정적 팩터리를 만들어야 합니다. 이 패턴을 제네릭 싱글턴 팩터티라 하며, Collections.reverseOrder 같은 함수 객체나 Collections.emptySet 같은 컬렉션용으로 사용합니다.\n이번에는 항등함수를 담은 클래스를 만들고 싶다고 해봅시다. 자바 라이브러리의 Function.idenify를 사용해도 되지만 직접 작성해 보겠습니다. 항등함수 객체는 상태가 없으니 요청할 때마다 새로 생성하는 것은 낭비입니다. 자바의 제네릭이 실체화된다면 항등함수를 타입별로 하나씩 만들어야 했겠지만, 소거 방식을 사용한 덕에 제네릭 싱글턴 하나면 충분합니다.\n1 2 3 4 5 6  private static UnaryOperator\u0026lt;Object\u0026gt; IDENTIFY_FN = (t) -\u0026gt; t; @SuppressWarnings(\u0026#34;unchecked\u0026#34;) public static \u0026lt;T\u0026gt; UnaryOperator\u0026lt;T\u0026gt; identifyFunction() { return (UnaryOperator\u0026lt;T\u0026gt;) IDENTIFY_FN; }   T가 어떤 타입이든 UnaryOperator\u0026lt;T\u0026gt;를 사용해도 type safe합니다.\n상대적으로 드물긴 하지만 자기 자신이 들어간 표현식을 사용하여 타입 매개변수의 허용 범위를 한정할 수 있습니다. 바로 재귀적 타입 한정이라는 개념입니다. 주로 타입의 자연적 순서를 정하는 Comparable 인터페이스와 함께 쓰입니다.\n1 2 3  public interface Comparable\u0026lt;T\u0026gt; { int compareTo(T o); }   타입 매개변수 T는 Comparable\u0026lt;T\u0026gt;를 구현한 타입이 비교할 수 있는 원소의 타입을 정의합니다. 실제로 거의 모든 타입은 자신과 같은 타입의 원소와만 비교할 수 있습니다. 따라서 String은 Comparable\u0026lt;String\u0026gt;을 구현하고 Integer는 Comparable\u0026lt;Integer\u0026gt;를 구현한 식입니다.\n1  public static \u0026lt;E extends Comparable\u0026lt;E\u0026gt;\u0026gt; E max(Collection\u0026lt;E\u0026gt; c);   타입 한정인 \u0026lt;E extends Comparable\u0026lt;E\u0026gt;\u0026gt;는 \u0026ldquo;모든 타입 E는 자신과 비교할 수 있다\u0026quot;라고 해석할 수 있습니다.\n다음은 방금 선언한 메서드의 구현입니다. 컬렉션에 담긴 원소의 자연적 순서를 기준으로 최댓값을 계산하며, 컴파일 오류나 경고는 발생하지 않습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13  public static \u0026lt;E extends Comparable\u0026lt;E\u0026gt;\u0026gt; E max(Collection\u0026lt;E\u0026gt; c) { if (c.isEmpty()) { throw new IllegalArgumentException(\u0026#34;컬렉션이 비어 있습니다.\u0026#34;); } E result = null; for (E e : c) { if (result == null || e.compareTo(result) \u0026gt; 0) { result = Objects.requireNonNull(e); } } return result; }   정리  제네릭 타입과 마찬가지로, 클라이언트에서 입력 매개변수와 반환값을 명시적으로 형변환해야 하는 메서드보다 제네릭 메서드가 더 안전하며 사용하기도 쉽습니다.  ","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-04/item30/","summary":"[아이템 30] 이왕이면 제네릭 메서드로 만들라. 제네릭 메서드는 대표적으로 Collections의 알고리즘 메서드(binarySearch, sort 등..)가 있습니다. 사용 방법은 리턴타입 앞에다 타입을 명시해주면 됩니다. 다음은 두 집합의 합집합을 반환하는 문제가 있는 메서드입니다.\n1 2 3 4 5 6  // raw tyoe 사용 - 수용 불가 public static Set union(Set s1, Set s2) { Set result = new HashSet(s1); result.addAll(s2); return result; }   컴파일은 되지만 경고가 발생합니다. 경고를 없애려면 이 메서드 타입을 안전하게 만들어야 합니다.","title":"[아이템 30] 이왕이면 제네릭 메서드로 만들라"},{"content":"[아이템 29] 이왕이면 제네릭 타입으로 만들라. 아이템7에서 다루었던 스택 코드를 제네릭으로 변형한 코드입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  public class Stack\u0026lt;E\u0026gt; { private E[] elements; private int size = 0; private static final int DEFAULT_INITIAL_CAPACITY = 16; public Stack() { elements = (E[]) new Object[DEFAULT_INITIAL_CAPACITY]; // 경고 메세지 타입이 안전하지 않음  } public void push(E e) { ensoureCapaciy(); elements[size++] = e; } public E pop() { if (size == 0) { throw new EmptyStackException(); } E result = elements[--size]; elements[size] = null; return result; } ... 중략 }   컴파일러는 이 프로그램이 안전한지 증명할 방법은 없지만, 우리는 할 수 있는 한 이 비검사 형변환이 프로그램의 타입 안전성을 해치지 않는지 스스로 확인해야합니다.\n비검사 형변환이 안전하다는 걸 확인했다면 범위를 최소로 좁혀 @SuppressWarnings(\u0026quot;unchecked\u0026quot;)를 이용하여 해당 경고를 숨깁시다.\n1 2 3 4 5 6 7  // 배열 elements는 push(E)로 넘어온 E 인스턴스만 담는다. // 따라서 타입 안전성을 보장하지만 // 이 배열의 런타임 타입은 E[]가 아닌 Object[]입니다. @SuppressWarnings(\u0026#34;unchecked\u0026#34;) public Stack() { elements = (E[]) new Object[DEFAULT_INITIAL_CAPACITY]; }   위 방법 말고 다른 방식으로는 elements 필드의 타입을 E[]에서 Object[]로 바꾸는 것입니다. 이렇게 하면 pop메서드 부분을 다음과 같이 수정해줘야 합니다.\n1  E result = (E) elements[--size];   E는 실체화 불가 타입이므로 컴파일러는 런타임에 이뤄지는 형변환이 안전한지 증명할 방법이 없습니다. 이번에도 직접 증명하고 경고를 숨길 수 있습니다.\n1 2  @SuppressWarnings(\u0026#34;unchecked\u0026#34;) E result = (E) elements[--size];   첫 번째 방식은 형변환을 배열 생성시 단 한 번만 해주면 되지만, 두 번째 방식에서는 배열에서 원소를 읽을 때마다 해줘야하므로 첫 번째 방식이 더 자주 사용됩니다. 하지만\n(E가 Object가 아닌 한) 배열의 런타임 타입이 컴파일타임 타입과 달라 힙 오염을 일으킵니다.\n사실 제네릭 타입 안에서 리스트를 사용하는 게 항상 가능하더라도, 꼭 더 좋은 건 아닙니다. 자바가 리스트를 기본 타입으로 제공하지 않으므로 ArrayList같은 제네릭 타입도 결국은 기본 타입인 배열을 사용해 구현해야 합니다. 또한 HashMap 같은 제네릭 타입은 성능을 높일 목적으로 배열을 사용하기도 합니다.\n정리  클라이언트에서 직접 형변환해야 하는 타입보다 제네릭 타입이 더 안전하고 쓰기 편합니다. 새로운 타입을 설계할 때는 형변환 없이도 사용할 수 있도록 합시다. 기존 타입 중 제네릭이었어야 하는 게 있다면 제네릭 타입으로 변경합시다.  ","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-04/item29/","summary":"[아이템 29] 이왕이면 제네릭 타입으로 만들라. 아이템7에서 다루었던 스택 코드를 제네릭으로 변형한 코드입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  public class Stack\u0026lt;E\u0026gt; { private E[] elements; private int size = 0; private static final int DEFAULT_INITIAL_CAPACITY = 16; public Stack() { elements = (E[]) new Object[DEFAULT_INITIAL_CAPACITY]; // 경고 메세지 타입이 안전하지 않음  } public void push(E e) { ensoureCapaciy(); elements[size++] = e; } public E pop() { if (size == 0) { throw new EmptyStackException(); } E result = elements[--size]; elements[size] = null; return result; } .","title":"[아이템 29] 이왕이면 제네릭 타입으로 만들라"},{"content":"[아이템 28] 배열보다는 리스트를 사용하라. 배열과 제네릭 타입의 차이 첫번째 차이점. 배열은 공변 입니다. 어려워 보이는 단어지만 뜻은 간단합니다. Sub가 Super의 하위 타입이라면 배열 Sub[]는 배열 Super[]의 하위 타입이 됩니다.\n반면, 제네릭은 불공변입니다. 즉 서로 다른 타입 Type1과 Type2가 있을 때, List\u0026lt;Type1\u0026gt;은 List\u0026lt;Type2\u0026gt;의 하위 타입도 아니고 상위 타입도 아닙니다.\n이것만 보면 제네릭에 문제가 있다고 생각할 수 있지만, 사실 문제가 있는 건 배열 쪽입니다. 다음은 문법상 허용되는 코드입니다.\n1 2 3  // 런타임 에러 Object[] objectArray = new Long[1]; objectArray[0] = \u0026#34;타입이 달라 넣을 수 없다.\u0026#34;; // 런타임시 ArrayStoreException을 던진다   1 2  // 컴파일 에러 List\u0026lt;Object\u0026gt; ol = new ArrayList\u0026lt;Long\u0026gt;(); // 호환되지 않는 타입   어느 쪽이든 Long용 저장소에 String을 넣을 수 없습니다. 다만 배열 같은 경우 런타임에야 알 수 있고, 리스트는 컴파일 시에 알아챌 수 있어서 더 좋습니다.\n두번째 차이점. 배열은 실체화(reify)됩니다. 무슨 뜻이냐면 배열은 런타임에도 자신이 담기로 한 원소의 타입을 인지하고 확인합니다. 그래서 위 코드에서 Long배열에 String을 넣으려 하면\nArrayStoreException이 발생합니다. 반면 제네릭은 타입 정보가 런타임에는 소거(erasure)됩니다.\n원소 타입을 컴파일타임에만 검사하며 런타임에는 알 수 조차도 없다는 뜻입니다. 소거는 제네릭 지원되기 전의 레거시 코드와 제네릭 타입을 함께 사용할 수 있게 해주는 메커니즘으로, JAVA 5가 제네릭으로 순조롭게 전환될 수 있도록 해주었습니다.\n이상의 주요 차이로 인해 배열과 제네릭은 잘 어울러지지 못합니다. 예컨대 배열은 제네릭 타입, 매개변수화 타입, 타입 매개변수로 사용할 수 없습니다. 즉 코드를 new List\u0026lt;E\u0026gt;[], new List\u0026lt;String\u0026gt;[], new E[] 식으로 작성하면 컴파일할 때 제네릭 배열 생성 오류를 일으킵니다.\n제네릭 배열을 만들지 못하게 막은 이유 타입이 안전하지 않기 때문입니다. 이를 허용하면 컴파일러가 자동 생성한 형변환 코드에서 런타임에 ClassCaseException이 발생할 수 있습니다. 런타임에 ClassCaseException이 발생하는 일을 막아주겠다는 제네릭 타입 시스템의 취지에 어긋나는 것입니다.\n1 2 3 4 5 6  // 컴파일 되지 않는다. List\u0026lt;String\u0026gt;[] stingLists = new List\u0026lt;String\u0026gt;[1]; // (1) List\u0026lt;Integer\u0026gt; intList = List.of(42); // (2) Object[] objects = stingLists; // (3) Object[0] = intList; // (4) String s = stingLists[0].get(0); // (5)   제네릭 배열을 생성하는 (1)이 허용된다고 가정해봅시다. (2)는 원소 하나인 List\u0026lt;Integer\u0026gt;를 생성합니다. (3)은 (1)에서 생성한 List\u0026lt;String\u0026gt;의 배열을 Object 배열에 할당합니다.\n배열은 공변이니 아무 문제가 없습니다. (4)는 (2)에서 생성한 List\u0026lt;Integer\u0026gt;의 인스턴스를 Object 배열의 첫 원소로 저장합니다. 제네릭은 소거 방식으로 구현되어서 이 역시 성공합니다.\n즉, 런타임에는 List\u0026lt;Integer\u0026gt; 소거 방식으로 이 역시 소거됩니다. 즉 런타임에는 List\u0026lt;Integer\u0026gt;인스턴스의 타입은 단순히 List가 되고, List\u0026lt;Integer\u0026gt;[] 인스턴스의 타입은 List[]가 됩니다. 따라서 (4)에서도 ArrayStoreException을 발생시키지 않습니다.\n문제는 List\u0026lt;String\u0026gt;인스턴스만 담겠다고 선언한 stingLists 배열에는 지금 List\u0026lt;Inrteger\u0026gt; 인스턴스가 저장돼 있습니다. 결국 (5)에서 ClassCaseExceptionn이 발생하게 됩니다.\n이런 일을 방지하려면 (제네릭 배열이 생성되지 않도록) (1)에서 컴파일 오류를 발생해야 합니다.\nE, List\u0026lt;E\u0026gt;, List\u0026lt;String\u0026gt; 같은 타입을 실체화 불가 타입(non-reifiable type)이라 합니다. 쉽게 말하자면, 실체화되지 않아서 런타임에는 컴파일타임보다 타입 정보를 적게 가지는 타입입니다. 소거 메커니즘 때문에 매개변수화 타입 가운데 실체화될 수 있는 타입은 List\u0026lt;?\u0026gt;와 Map\u0026lt;?, ?\u0026gt;같은 비한정적 와일드카드 타입뿐입니다. 배열을 비한정적 와일드카드 타입으로 만들 수는 있지만, 유용하게 쓰일 일은 별로 없습니다.\n정리  배열은 공변이고 실체화가 되지만 제네릭은 불공변이고 타입 정보가 소거됩니다. 배열은 런타임에는 타입 안전하지만 컴파일타임에는 그렇지 않습니다.  ","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-04/item28/","summary":"[아이템 28] 배열보다는 리스트를 사용하라. 배열과 제네릭 타입의 차이 첫번째 차이점. 배열은 공변 입니다. 어려워 보이는 단어지만 뜻은 간단합니다. Sub가 Super의 하위 타입이라면 배열 Sub[]는 배열 Super[]의 하위 타입이 됩니다.\n반면, 제네릭은 불공변입니다. 즉 서로 다른 타입 Type1과 Type2가 있을 때, List\u0026lt;Type1\u0026gt;은 List\u0026lt;Type2\u0026gt;의 하위 타입도 아니고 상위 타입도 아닙니다.\n이것만 보면 제네릭에 문제가 있다고 생각할 수 있지만, 사실 문제가 있는 건 배열 쪽입니다. 다음은 문법상 허용되는 코드입니다.\n1 2 3  // 런타임 에러 Object[] objectArray = new Long[1]; objectArray[0] = \u0026#34;타입이 달라 넣을 수 없다.","title":"[아이템 28] 배열보다는 리스트를 사용하라"},{"content":"[아이템 27] 비검사 경고를 제거하라. 제네릭에 관련된 수 많은 컴파일 경고들이 있습니다. 비검사 형변환 경고, 비검사 메서드 호출 경고, 비검사 매개변수화 가변인수 타입 경고, 비검사 변환 경고 등이 있습니다.\n제네릭에 익숙해질 수록 마주치는 경고 수는 줄어들겠지만 새로 작성한 코드가 한 번에 깨끗하게 컴파일되리라 기대하지는 맙시다.\n대부분의 비검사 경고는 쉽게 제거할 수 있습니다. 코드를 다음처럼 잘못 작성했다고 예시를 들어봅시다.\n1  Set\u0026lt;Fruits\u0026gt; fruits = new Hashset();   그러면 컴파일러는 무엇이 잘못 됐는지 설멸해 줄 것입니다.\n(javac 명령줄 인수에 -Xlint:unchecked 옵션을 추가해야 합니다.)\n컴파일러가 알려준 대로 수정하면 경고가 사라집니다. JAVA 7부터는 컴파일러가 알려준 타입 매개변수로 명시하지 않아도 타입 추론을 지원합니다.\n1  Set\u0026lt;Fruits\u0026gt; fruits = new Hashset\u0026lt;\u0026gt;();   할 수 있는 한 모든 비검사 경고를 제거합시다. 모두 제거한다면 그 코드는 타입 안전성이 보장됩니다. 경고를 제거할 수는 없지만 타입이 안전하다고 확신이 들 때는 @SuppressWarning(\u0026quot;unchecked\u0026quot;) 애너테이션을 달아 경고를 숨깁시다. @SuppressWarning 애너테이션은 개별 지역번수 선언부터 클래스 전체까지 어떤 선언에도 달 수 있습니다. 하지만 가능한 좁은 범위에 적용하는 게 좋습니다.\n자칫 심각한 경고를 놓칠 수 있으니 절대로 클래스 전체에 적용해서는 안 됩니다. @SuppressWarning(\u0026quot;unchecked\u0026quot;) 애너테이션을 사용할 때면 그 경고를 무시해도 안전한 이유를 항상 주석으로 남겨야 합니다.\n정리  비검사 경고는 중요하니 무시하지 말자. 모든 비검사 경고는 런타임에 ClassCastException을 일으킬 수 있는 잠재적 가능성이 있습니다. 경고를 없앨 방법을 찾지 못했다면, 그 코드의 안전함을 증명하고 가능한 범위를 좁혀서 @SuppressWarning(\u0026quot;unchecked\u0026quot;) 애노테이션으로 경고를 숨깁시다.  ","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-04/item27/","summary":"[아이템 27] 비검사 경고를 제거하라. 제네릭에 관련된 수 많은 컴파일 경고들이 있습니다. 비검사 형변환 경고, 비검사 메서드 호출 경고, 비검사 매개변수화 가변인수 타입 경고, 비검사 변환 경고 등이 있습니다.\n제네릭에 익숙해질 수록 마주치는 경고 수는 줄어들겠지만 새로 작성한 코드가 한 번에 깨끗하게 컴파일되리라 기대하지는 맙시다.\n대부분의 비검사 경고는 쉽게 제거할 수 있습니다. 코드를 다음처럼 잘못 작성했다고 예시를 들어봅시다.\n1  Set\u0026lt;Fruits\u0026gt; fruits = new Hashset();   그러면 컴파일러는 무엇이 잘못 됐는지 설멸해 줄 것입니다.","title":"[아이템 27] 비검사 경고를 제거하라"},{"content":"[아이템 26] Raw 타입은 사용하지 마라. raw type이란 제네릭 타입에서에서 타입 파라미터를 전혀 사용하지 않았을 때를 말합니다.\n1 2  // raw type List list = new ArrayList();   raw type은 타입 선언에서 제네릭 타입 정보가 전부 지워진 것처럼 동작하는데, 제네릭이 도래하기 전 코드와 호환성을 위해서 주로 존재합니다.\n1 2  // 문자열을 저장하는 컬렉션 private final List names = new ArrayList();   위 코드를 사용하면 String대신 다른 타입을 넣어도 오류없이 실행됩니다. (경고 메세지를 보여주긴 합니다.)\n1 2 3  naems.add(1); // \u0026#34;Unchecked call\u0026#34; 경고를 보여줍니다.  String str = (String) names.get(0); // ClassCastException   컴파일 오류를 체크하지 못하고 런타임할 때 예외가 발생하게 됩니다. 가장 이상적인 오류는 컴파일할 때 발견하는 것이 좋습니다. 이렇게 되면 런타임에 문제를 겪는 코드와 원인을 제공한 코드가 물리적으로 상당히 떨어져 있을 가능성이 커집니다.\n제네릭을 활용하면 이 정보가 주석이 아닌 타입 선언 자체에 녹아듭니다.\n1 2  // 매개변수화된 컬렉션 타입 - 타입 안전성 확보 private final List\u0026lt;String\u0026gt; names = new ArrayList\u0026lt;\u0026gt;();   이렇게 선언하면 컴파일러는 names에는 String만 넣어야 함을 컴파일러가 인지하게 됩니다. 이제 names에 엉뚱한 타입의 인스턴스를 넣으려고하면 컴파일 오류가 발생합니다.\n1  names.add(1); // 컴파일 오류   앞에서도 얘기했듯, raw type(타입 매개변수가 없는 제네릭 타입)은 절대로 사용해서는 안 됩니다.\nraw type을 쓰면 제네릭이 안겨주는 안전성과 표현력을 모두 잃게 됩니다. raw type을 만들어놓은 이유는 호환성 때문입니다. 자바가 제네릭을 받아들이기까지 거의 10년이 걸린 탓에 제네릭 없이 짠 코드를 모두 수용하면서 제네릭을 사용하는 새로운 코드와도 맞물려 돌아가게 해야만 했습니다.\nList vs List\u0026lt;Objects\u0026gt; raw typeList는 제네릭 타입에서 완전히 발을 뺀 것이고, List\u0026lt;Object\u0026gt;는 모든 타입을 허용한다는 의사를 컴파일러에게 전달한 것입니다. 매개변수로 List를 받는 메서드에 List\u0026lt;String\u0026gt;를 넘길 수 있지만, List\u0026lt;Object\u0026gt;를 받는 메서드에는 List\u0026lt;String\u0026gt;를 넘길 수 없습니다. 이는 제네릭의 하위 타입 규칙 때문입니다.\n즉, List\u0026lt;Integer\u0026gt;는 raw type인 List의 하위타입 이지만, List\u0026lt;Object\u0026gt;의 하위타입은 아닙니다. 그 결과 List\u0026lt;Object\u0026gt;같은 매개변수화 타입을 사용할 때와 달리 List같은 raw type을 사용하면 타입 안전성을 잃게 됩니다.\n예제를 위한 코드 1 2 3  // Interger는 Number의 서브 타입입니다. List\u0026lt;Integer\u0026gt; intList = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;Number\u0026gt; numberList = intList; // 컴파일 에러   1 2  List\u0026lt;Integer\u0026gt; intList = new ArrayList\u0026lt;\u0026gt;(); List rawType = intList; // 오류가 발생하지 않지만, 안전하지 않습니다.   이쯤 되면 원소의 타입을 몰라도 되는 raw type을 쓰고 싶어질 수 있습니다. 그럴 땐 비한정적 와일드 타입(unbounded wildcard types)를 사용하는 대안이 있습니다. 이는 타입 파리머티에 ?을 작성하면 됩니다.\n1 2  // unbounded wildcard type - 타입 세이프하고 유연합니다, static int numElementsInCommon(Set\u0026lt;?\u0026gt; s1, Set\u0026lt;?\u0026gt; s2) { ... }   그렇다면 비한정적 와일드카드 타입인 Set\u0026lt;?\u0026gt;와 raw type인 Set의 차이는 무엇일까? 물음표가 무언가 멋진 일은 해주는 것일까?\n와일드 카드는 type safe하고 raw type은 그렇지 않다는 점입니다. raw type원소에는 아무 원소나 넣을 수 있으니 타입 불변식을 훼손하기 쉽습니다.\n반면 Collection\u0026lt;?\u0026gt;에는 (null 이외는) 어떤 원소도 넣을 수 없습니다. 다른 원소를 넣으려 하면 컴파일 할 때 오류 메세지를 보여줍니다. 이러한 제약을 받아들일 수 없다면 제네릭 메서드나 bounded wildcard type을 사용하면 됩니다.\nraw type을 사용하지 말라는 규칙에도 소소한 예외가 몇 개 있습니다. class 리터럴에는 raw type을 사용해야 합니다. 자바 명세는 class 리터럴에 매개변수화 타입을 사용하지 못하게 했습니다. (배열과 기본 타입은 허용합니다.)\n예를 들어 List.class.String[].class, int.class는 허용하고 List\u0026lt;String\u0026gt;.class와 List\u0026lt;?\u0026gt;.class는 허용하지 않습니다.\n두 번째 예외는 instance of 연산자와 관련이 있습니다. 런타임에는 제네릭 타입 정보가 지워지므로 instance of 정보가 지워지므로 instance of 연산자는 비한정적 와일드카드 타입 이외의 매개변수화 타입에는 적용할 수 없습니다.\n정리  raw type을 사용하면 런타임 예외가 일어날 수 있으니 사용하면 안 됩니다. raw type은 제네릭이 도입되기 이전 코드와의 호환성을 위해 제공될 뿐입니다. Set\u0026lt;Object\u0026gt;는 어떤 타입의 객체도 저장할 수 있는 매개변수화 타입입니다.  ","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-04/item26/","summary":"[아이템 26] Raw 타입은 사용하지 마라. raw type이란 제네릭 타입에서에서 타입 파라미터를 전혀 사용하지 않았을 때를 말합니다.\n1 2  // raw type List list = new ArrayList();   raw type은 타입 선언에서 제네릭 타입 정보가 전부 지워진 것처럼 동작하는데, 제네릭이 도래하기 전 코드와 호환성을 위해서 주로 존재합니다.\n1 2  // 문자열을 저장하는 컬렉션 private final List names = new ArrayList();   위 코드를 사용하면 String대신 다른 타입을 넣어도 오류없이 실행됩니다.","title":"[아이템 26] Raw 타입은 사용하지 마라"},{"content":"[아이템 25] 톱레벨 클래스는 한 파일에만 담으라 1 2 3 4 5  public class Main { public static void main(String[] args) { System.out.println(Utensil.NAME + Dessert.NAME); } }   위 코드의 소스 파일은 Main 클래스 하나를 담고 있고, Main클래스는 다른 톱레벨 클래스 2개(Utensil Dessert)를 참조합니다.\nUtensil와 Dessert 클래스가 Utensil.java라는 한 파일에 정의되어 있다고 가정해봅시다.\n1 2 3 4 5 6 7  class Utensil { static final String NAME = \u0026#34;pan\u0026#34;; } class Dessert { static final String NAME = \u0026#34;cake\u0026#34;; }   Main을 실행하면 \u0026ldquo;pancake\u0026quot;가 출력됩니다.\n이제 두 클래스를 담은 Dessert.java라는 파일을 만들었다고 가정해봅시다.\n1 2 3 4 5 6 7  class Utensil { static final String NAME = \u0026#34;pot\u0026#34;; } class Dessert { static final String NAME = \u0026#34;pie\u0026#34;; }   컴파일러는 가장 먼저 Main.java를 컴파일하고, 그 안에서 (Dessert 참조보다 먼저 나오는) Utensil 참조를 만나면 Utensil.java 파일을 살펴 Utensil과 Dessert를 모두 찾아낼 것입니다. 그런 다음 컴파일러가 두 번째 명령줄 인수로 넘어온 Dessert.java를 처리하려 할 때 같은 클래스의 정의가 이미 있음을 알게 됩니다.\n한편 javac Main.java나 javac Main.java Utensil.java명령으로 컴파일하면 Dessert.java파일을 작성하기 전처럼 \u0026ldquo;pancake\u0026quot;를 출력합니다. 그러나 javac Dessert.java Main.java명령으로 컴파일하면 \u0026ldquo;potpie\u0026quot;를 출력합니다. 이처럼 컴파일러에 어느 소스 파일을 먼저 건네느냐에 따라 동작이 달라지므로 반로 잡아야할 문제입니다. 다행히 해결책은 간단합니다. 단순힌 톱레벨 클래스들을 서로 다른 소스 파일로 분리하면 그만입니다.\n굳이 여러 톱레벨 클래스를 한 파일에 담고 싶다면 정적 멤버 클래스를 사용하는 방법을 고민해볼 수 있습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13  public class Test { public static void main(String[] args) { System.out.println(Utensil.NAME + Dessert.NAME); } private static class Utensil { static final String NAME = \u0026#34;pan\u0026#34;; } private static class Dessert { static final String NAME = \u0026#34;cake\u0026#34;; } }   ","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-03/item25/","summary":"[아이템 25] 톱레벨 클래스는 한 파일에만 담으라 1 2 3 4 5  public class Main { public static void main(String[] args) { System.out.println(Utensil.NAME + Dessert.NAME); } }   위 코드의 소스 파일은 Main 클래스 하나를 담고 있고, Main클래스는 다른 톱레벨 클래스 2개(Utensil Dessert)를 참조합니다.\nUtensil와 Dessert 클래스가 Utensil.java라는 한 파일에 정의되어 있다고 가정해봅시다.\n1 2 3 4 5 6 7  class Utensil { static final String NAME = \u0026#34;pan\u0026#34;; } class Dessert { static final String NAME = \u0026#34;cake\u0026#34;; }   Main을 실행하면 \u0026ldquo;pancake\u0026quot;가 출력됩니다.","title":"[아이템 25] 톱레벨 클래스는 한 파일에만 담으라"},{"content":"[아이템 24] 멤버 클래스는 되도록 static으로 만들어라. 중첩 클래스(nested class)는 자신을 감싼 바깥 클래스에서만 쓰어야 하며 그 이외 쓰임새가 있다면 톱레벨 클래스로 만들어야 합니다.\n중첩 클래스는 다음과 같이 네 종류로 나눌 수 있습니다.\n 정적 멤버 클래스 (비정적)멤버 클래스 익명 클래스 지역 클래스  이 중 정적 멤버 클래스를 제외한 나머지는 내부 클래스(inner class)에 해당합니다.\n정적 멤버 클래스 정적 멤버 클래스는 다른 클래스 안에 선언되고, 바깥 클래스의 private 멤버에도 접근할 수 있다는 점만 제외하고는 일반 클래스외 똑같습니다. 정적 멤버 클래스는 흔히 바깥 클래스와 함께 쓰일 때만 유용한 public 도우미 클래스로 쓰입니다.\n비정적 멤버 클래스 비정적 멤버 클래스의 인스턴스 바깥 클래스의 인스턴스와 암묵적으로 연결됩니다. 그래서 비정적 멤버 클래스의 인스턴스는 메서드에서 정규화된 this를 사용해 바깥 인스턴스의 메서드를 호출하거나 바깥 인스턴스의 참조를 가져올 수 있습니다.\n여기서 말하는 정규화된 this란 클래스명.this 형태로 바깥 클래스의 이름을 명시하는 용법을 말합니다. 따라서 바깥 인스턴스와 독립적으로 존재할 수 있다면 정적 멤버 클래스로 만들어야 합니다. 비정적 멤버 클래스는 바깥 인스턴스 없이 생성할 수 없기 때문입니다.\n바깥 클래스의 인스턴스 메서드에 비정적 멤버 클래스의 생성자를 호출할 때 자동으로 만들어지는 게 보통이지만, 드물게 직접 바깥 인스턴스의 클래스명.new MemberClass()를 호출해 수동으로 만들기도 하지만 비정적 멤버 클래스의 인스턴스 안에 만들어져 메모리 공간을 차지하며, 생성 시간도 더 걸립니다.\n비정적 멤버 클래스는 어댑터를 정의할 때 자주 사용됩니다. 즉 어떤 클래스의 인스턴스를 감싸 마치 다른 클래스의 인스턴스처럼 보이게 하는 뷰로 사용됩니다. 예컨대 Map 인터페이스의 구현체들은 보통 (keySet, entrySet메서드가 반환하는) 자신의 컬렉션 뷰를 구현할 때 비정적 멤버 클래스를 사용합니다.\n멤버 클래스에서 바깥 인스턴스에 접근할 일이 없다면 무조건 static을 붙여서 정적 멤버 클래스로 만듭시다. static을 생략하면 바깥 인스턴스로의 숨은 외부 참조를 갖게 됩니다. 이렇게 되면 시간과 공긴이 소비되고 더 심각한 문제는 가비지 컬렉션이 바깥 클래스의 인스턴스를 수거하지 못하는 메모리 누수가 생길 수 있습니다.\n익명 클래스 익명 클래스는 바깥 클래스의 멤버가 아닙니다. 멤법와 달리, 쓰이는 시점에 선언과 동시에 인스턴스로 만들어집니다. 그리고 오직 비정적인 문맥에서 사용될 때만 바깥 클래스의 인스턴스를 참조할 수 있으며 instance of검사나 클래스의 이름이 필요한 작업은 수행할 수 없습니다.\n자바가 람다를 지원하기 전에는 즉석에서 작은 함수 객체나 처리 객체(process object)를 만드는 데 만드는 데 익명 클래스를 주로 사용했으며 또 정적 팩터리 메서드를 구현할 때입니다.\n지역 클래스 지역 클래스는 네 가지 중첩 클래스 중 가장 드물게 사용됩니다. 지역 클래스는 지역 변수를 선언할 수 있는 곳이면 실직적으로 어디서든 선언할 수 있고, 유효범위도 지역변수와 같습니다.\n정리  중첩 클래스에는 네 가지가 있으며, 각각의 쓰임이 다릅니다. 메서드 밖에서도 사용해야 하거나 메서드 안에 정의하기엔 너무 길다면 멤버 클래스로 만듭니다. 멤버 클래스의 인스턴스 각각이 바깥 인스턴스를 참조한다면 비정적으로. 그렇지 않으면 정적으로 만듭시다. 중첩 클래스가 한 메서드 안에서만 사용되며 그 인스턴스를 생선하는 지점이 단 한 곳이고 해당 타입으로 쓰기에 적합한 클래스나 인터페이스가 있다면 익명 클래스로 만들고, 그렇지 않으면 지역 클래스로 만듭시다.  ","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-03/item24/","summary":"[아이템 24] 멤버 클래스는 되도록 static으로 만들어라. 중첩 클래스(nested class)는 자신을 감싼 바깥 클래스에서만 쓰어야 하며 그 이외 쓰임새가 있다면 톱레벨 클래스로 만들어야 합니다.\n중첩 클래스는 다음과 같이 네 종류로 나눌 수 있습니다.\n 정적 멤버 클래스 (비정적)멤버 클래스 익명 클래스 지역 클래스  이 중 정적 멤버 클래스를 제외한 나머지는 내부 클래스(inner class)에 해당합니다.\n정적 멤버 클래스 정적 멤버 클래스는 다른 클래스 안에 선언되고, 바깥 클래스의 private 멤버에도 접근할 수 있다는 점만 제외하고는 일반 클래스외 똑같습니다.","title":"[아이템 24] 멤버 클래스는 되도록 static으로 만들어라"},{"content":"[아이템 23] 태그 달린 클래스보다는 클래스 계층구조를 활용하자. 때때로 두 가지 이상의 의미를 표현하고 인스턴스의 특징을 알려주는 태그 필드로 나타내는 클래스를 본 적이 있을겁니다.\n안 좋은 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  public class Figure { enum Shape { RECTANGLE, CIRCLE }; // 태그 필드 - 현재 모양을 나타냅니다.  final Shape shape; // 모양이 사각형(RECTANGLE)일 때만 쓰입니다.  double length; double width; // 다음 필드 모양이 원(CIRCLE)일 때만 쓰입니다.  double radius; // 원 생성  Figure(double radius) { shape = Shape.CIRCLE; this.radius = radius; } Figure(double length, double width) { shape = Shape.RECTANGLE; this.length = length; this.width = width; } double area() { switch (shape) { case RECTANGLE: return length * width; case CIRCLE: return Math.PI * (radius * radius); default: throw new AssertionError(); } } }   태그 달린 클래스에는 단점이 많습니다. 열거 타입 선언, 태그 필드, switch문 등 잡다한 코드가 너무 많습니다. 여러 구현이 한 클래스에 있어서 구현도 나쁩니다. 인스턴스가 다른 특징에 속하는 관련없는 필드로 인해 메모리도 많이 사용하게 됩니다.\n또 다른 의미를 추가하려면 switch문을 찾아 새 의미를 처리하는 코드를 추가해야하는 데 하나라도 빠뜨리면 문제가 될 수도 있습니다. 마지막으로, 인스턴스의 타입만으로는 현재 나타내는 의미를 알 길이 없습니다.\n태그 달린 클래스는 장황하고, 오류를 내기 쉽고, 비효율적입니다.\n클래스 계층구조를 활용하는 서브타이핑을 이용해서 타입 하나로 다양한 의미의 객체를 표현할 수 있습니다. 태그 달린 클래스는 클래스 계층구조를 어설프게 흉내낸 아류일뿐입니다.\n태그달린 클래스를 클래스 계층 구조로 바꾸는 방법  계층구조의 루트가 될 추상 클래스를 정의하고, 태그 값에 따라 동작이 달라지는 메서드들을 루트 클래스의 추상 메서드로 선언합니다. 태그 값에 상관없이 동작이 일정한 메서드들을 루트 클래승 일반 메서드로 추가합니다. 모든 하위 클래스에서 공통으로 사용하는 데이터 필드들도 전부 루트 클래스로 올립니다. 루트 클래스를 확장한 구체 클래스를 의미별로 하나씩 정의합니다.  Figure 클래스에서는 태그 값과 상관없는 메서드가 하나도 없고, 모든 하위 클래스에서 사용하는 공통 데이터 필드가 없습니다. 그 결과 루트 클래스에는 추상메서드 area하나만 남게 됩니다.\n다음은 Figure 클래스를 계층구조 방식으로 구현한 코드입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  abstract class Figure { abstract double area; } public class Circle extends Figure{ final double radius; public Circle(double radius) { this.radius = radius; } @Override double area() { return Math.PI * (radius * radius); } } // Rentangle 클래스 위와 같은 방식으로 구현하면 됩니다.   태그 달린 클래스에 비교하면 쓸데 없는 코드들은 모두 제거했고, 각 의미를 독립된 클래스에 담아 관련 없던 데이터 필드를 모두 제거했습니다.\n살아 남은필드들은 모두 final이며 각 클래스의 생성자가 모든 필드를 남김없이 초기화하고 추상 메서드를 구현했는지 컴파일러가 확인해줍니다.\n정리  태그 달린 클래스를 써야 하는 상황은 거의 없습니다. 새로운 클래스를 작성할 때 태그 필드가 등자했다면 계층 구조롤 대체하는 방법을 고려해보자. 기존 클래스가 필드를 사용하고 있다면 계층구조로 리팩터링 하는 걸 고려민해보자.  ","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-03/item23/","summary":"[아이템 23] 태그 달린 클래스보다는 클래스 계층구조를 활용하자. 때때로 두 가지 이상의 의미를 표현하고 인스턴스의 특징을 알려주는 태그 필드로 나타내는 클래스를 본 적이 있을겁니다.\n안 좋은 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  public class Figure { enum Shape { RECTANGLE, CIRCLE }; // 태그 필드 - 현재 모양을 나타냅니다.","title":"[아이템 23] 태그 달린 클래스보다는 클래스 계층구조를 활용하자"},{"content":"[아이템 22] 인터페이스는 타입을 정의하는 용도로만 사용하라. 인터페이스는 자신을 구현한 클래스의 인스턴스를 참조할 수 있는 타입 역할을 합니다. 그러므로 인터페이스를 구현한 클래스는 클라이언트에게 자신의 인스턴스로 무엇을 할 수 있는지 말해주는 것입니다. 인터페이스를 다른 용도로 사용하는 것은 부적절합니다.\n이 지침에 맞지 않는 예로 소위 상수 인터페이스라는 것이 있습니다. 상수 인터페이스는 메서드가 없이, 상수를 뜻하는 static final 필드로만 가득 찬 인터페이스를 뜻합니다.\n1 2 3 4 5 6 7  public interface PhysicalConstants { static final double AVOGADROS_NUMBER = 6.022_140_857e34; static final double BOLTZMANN_CONSTANT = 1.380_648_52e-23; static final double ELECTRON_MASS = 9.109_383_56e-31; }   상수 인터페이스 안티패턴은 인터페이스를 잘못 사용한 예입니다. 클래스 내부에서 사용하는 상수는 외부 인터페이스가 아니라 내부 구현에 해당합니다. 따라서 상수 인터페이스를 구현하는 것은 이 내부 구현을 클래스의 API로 노출하는 행위입니다. 클래스가 어떤 상수 인터페이스를 사용하든 사용자에게는 아무런 의미가 없습니다. 오히려 혼란을 줄 수가 있으며, 더 심각하게는 클라이언트 코드가 내부 구현에 해당하는 이 상수들에게 종속되게 합니다.\n그래서 다음 릴리즈에서 이 상수들을 더는 쓰지 않게 되더라도 바이너리 호환성을 위해 여전히 상수 인터페이스를 구현하고 있어야 합니다. final이 아닌 클래스가 상수 인터페이스를 구현한다면 모든 하위 클래스의 네임스페이스가 그 인터페이스가 정의한 상수들로 오염되어 버립니다.\njava.io.ObjectStreamConstants 등, 자바 플랫폼 라이브러리에도 상수 인터페이스가 몇 개 있으나, 인터페이스를 잘못 활용한 예이니 따라 해서는 안 됩니다. 상수를 공개할 목적이라면 더 합당한 방법들이 있습니다.\n특정 클래스나 인터페이스와 강하게 연관된 상수라면 그 클래스나 인터페이스 자체에 추가해야합니다. 대표적으로 Integer와 Double에 선언된 MIN_VALUE와 MAX_VALUE 상수가 이런 예입니다. 열거 타입으로 나타내기 적합한 상수라면 열거 타입으로 만들면 되고 그것도 아니라면 인스턴스화 할 수 없는 유틸클래스에 담아 공개하면 됩니다.\n1 2 3 4 5 6 7 8 9  // 유틸리티 클래스  public class PhysicalConstants { private PhysicalConstants() static final double AVOGADROS_NUMBER = 6.022_140_857e34; ... 생략 }   정리  인터페이스는 타입을 정의하는 용도로만 사용해야 합니다, 실수 공개용 수단으로 사용하지 맙시다.  ","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-03/item22/","summary":"[아이템 22] 인터페이스는 타입을 정의하는 용도로만 사용하라. 인터페이스는 자신을 구현한 클래스의 인스턴스를 참조할 수 있는 타입 역할을 합니다. 그러므로 인터페이스를 구현한 클래스는 클라이언트에게 자신의 인스턴스로 무엇을 할 수 있는지 말해주는 것입니다. 인터페이스를 다른 용도로 사용하는 것은 부적절합니다.\n이 지침에 맞지 않는 예로 소위 상수 인터페이스라는 것이 있습니다. 상수 인터페이스는 메서드가 없이, 상수를 뜻하는 static final 필드로만 가득 찬 인터페이스를 뜻합니다.\n1 2 3 4 5 6 7  public interface PhysicalConstants { static final double AVOGADROS_NUMBER = 6.","title":"[아이템 22] 인터페이스는 타입을 정의하는 용도로만 사용하라"},{"content":"[아이템 21] 인터페이스는 구현하는 쪽을 생각해 설계하라. JAVA 8이전에는 기존 구현체를 깨뜨리지 않고 인터페이스에 새로운 메서드를 추가할 방법이 없었습니다. JAVA 8부터는 디폴트 메서드를 제공해서 이러한 문제점들을 해결해줬지만 위험이 완전히 사라진 것은 아닙니다.\nJAVA 8이전까지는 인터페이스에 새로운 메소드가 추가될리 없다는 암묵적인 가정으로 작성되었습니다.\n즉 디폴트 메서드는 구현한 클래스에 동의 없이 무작정 삽입되었습니다. JAVA 8에서는 핵심 컬렉션 인터페이스들에 다수의 디폴트 메서드가 추가되었습니다. 주로 람다를 활용하기 위해서입니다.\n자바라이브러리의 디폴트 메서드는 코드 품질이 높고 범용적이라 대부분 잘 작동하지만, 생각할 수 있는 모든 상황에서 불변식을 해치지 않는 디폴트 메서드를 작성하기란 어려운 법입니다.\n1 2 3 4 5 6 7 8 9 10 11 12  default boolean removeIf(Predicate\u0026lt;? super E\u0026gt; filter) { Objects.requireNonNull(filter); boolean removed = false; final Iterator\u0026lt;E\u0026gt; each = iterator(); while (each.hasNext()) { if (filter.test(each.next())) { each.remove(); removed = true; } } return removed; }   자바 8 Collection 인터페이스에 추가된 removeIf 메서드입니다.\n이코드보다 더 범용적으로 구현하기도 어렵겠지만, 그렇다고 해서 현존하는 모든 Collection 구현체와 잘 어우러지는 것은 아닙니다.\n대표적인 예가 org.apache.commons.collections4.collection.SynchronizedCollection입니다. 이 클래스는 java.util.Collections.synchronizedCollction 정적 팩터리 메서드가 반환하는 클래스와 비슷합니다. 아파치 버전은 클라이언트가 제공한 객체로 락을 거는 능력을 추가로 제공합니다. 즉, 모든 메서드에 주어진 락 객체로 동기화한 후 내부 컬렉션 객체에 기능을 위임하는 래퍼 클래스입니다.\n아파치의 SynchronizedCollection는 removieIf메서드를 재정의하고 있지 않습니다. 이 첵이 쓰여진 시점에는 removeIf를 재정의하고있지 않습니다. 이 클래스는 removeIf를 재정의 하고있지 않습니다. 그래서 이 클래스를 JAVA 8과 함께 사용하면 모든 메서드 호출을 알아서 동기화해주지 못합니다.\n자바 플랫폼 라이브러리에서도 이런 문제를 예방하기 위해 조치를 취했습니다. 예를 들어 구현한 인터페이스의 디폴트 메서드를 재정의하고, 다른 메서드에서는 디폴트 메서드를 호출하기 전에 필요한 작업을 수행하도록 했습니다.\n핵심은 인터페이스를 설계할 때는 세심한 주의를 기울여야 합니다. 디폴트 메서드로 기존 인터페이스에 새로운 메서드를 추가하면 커다란 위험도 딸려옵니다. 새로운 인터페이스라면 릴리즈 전에 반드시 테스트를 거쳐야 합니다.\n","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-03/item21/","summary":"[아이템 21] 인터페이스는 구현하는 쪽을 생각해 설계하라. JAVA 8이전에는 기존 구현체를 깨뜨리지 않고 인터페이스에 새로운 메서드를 추가할 방법이 없었습니다. JAVA 8부터는 디폴트 메서드를 제공해서 이러한 문제점들을 해결해줬지만 위험이 완전히 사라진 것은 아닙니다.\nJAVA 8이전까지는 인터페이스에 새로운 메소드가 추가될리 없다는 암묵적인 가정으로 작성되었습니다.\n즉 디폴트 메서드는 구현한 클래스에 동의 없이 무작정 삽입되었습니다. JAVA 8에서는 핵심 컬렉션 인터페이스들에 다수의 디폴트 메서드가 추가되었습니다. 주로 람다를 활용하기 위해서입니다.\n자바라이브러리의 디폴트 메서드는 코드 품질이 높고 범용적이라 대부분 잘 작동하지만, 생각할 수 있는 모든 상황에서 불변식을 해치지 않는 디폴트 메서드를 작성하기란 어려운 법입니다.","title":"[아이템 21] 인터페이스는 구현하는 쪽을 생각해 설계하라"},{"content":"[아이템 20] 추상 클래스보다는 인터페이스를 우선하라. 자바가 제공하는 다중 구현 메커니즘은 인터페이스와 추상 클래스가 있습니다. 자바8 부터는 인터페이스에서 defualt moethod를 제공할 수 있게 되어서 두 메커니즘 모두 인스턴스 메서드를 구현 형태로 제공할 수 있습니다.\n추상 클래스와 인터페이스의 큰 차이점은 추상 클래스의 정의한 타입을 구현 클래스는 반드시 서브클래스가 된다는 점입니다. 자바에서는 단일 상속만 지원하기 때문에 이런 제약은 새로운 타입을 정의하는데 커다란 제약이 됩니다.\n반면 인터페이스의 준수 사항을 잘 지키고 모든 메서드를 구현한 클래스는 어느 계층에 있든 인터페이스를 구현할 수 있습니다. 기존 클래스에도 손쉽게 새로운 인터페이스를 구현해 넣을 수 있습니다. 그저 인터페이스가 요구하는 메서드를 (아직 없다면) 추가하고, 클래스 선언에 implements 구문을 추가하면 됩니다.\n반면 일반적으로 기존 클래스에 새로운 추상 클래스를 끼워넣는 일은 매우 간단합니다. 만약 두 클래스로 하나의 추상 클래스를 상속하길 원한다면, 그 추상 클래스는 계층구조상 두 클래스의 공통 조상이어야합니다. 이러한 방식은 클래스 계층구조에 커다란 혼란을 야기할 수 있습니다. 적절하지 않은 상황에서도 강제로 새로 추가된 추상 클래스의 모든 자손이 이를 상속하게 되는 것입니다.\n인터페이스는 믹스인(mixin) 정의에 안성맞춤입니다. 믹스인이란 클래스가 구현할 수 있는 타입으로, 믹스인을 구현한 클래스에 원래의 \u0026lsquo;주된 타입\u0026rsquo;외에도 특정 선택적 행위를 제공한다고 선언하는 효과를 줍니다.\n예컨대 Comparable은 자신을 구현한 클래스의 인스턴스들끼리는 순서를 정할 수 있다고 선언하는 믹스인 인터페이스입니다. 이처럼 대상 타입의 주된 기능에 선택적 기능을 \u0026lsquo;혼합(mixed in)\u0026lsquo;한다고 해서 믹스인이라고 불립니다.\n반면 추상 클래스로는 믹스인을 정의할 수 없습니다. 기존 클래스에 덧씌울 수 없기 때문입니다. 클래스는 두 부모를 섬길 수 없고, 클래스 계층구조에는 믹스인을 삽입하기엔 합리적인 위치가 없기 때문입니다.\n인터페이스는 계층구조가 없는 타입 프레임워크 만들 수 있습니다. 1 2 3 4 5 6  public interface Singer { AudioClip sing(Song s); } public interface Songwriter { Song compose(int chartPosition); }   현실에는 계층을 엄격히 구분하기 어려운 개념이 있습니다. 위 코드처럼 타입을 인터페이스로 정의하면 가수 클래스가 Singer와 SongWriter 모두를 구현해도 전혀 문제가 되지 않습니다.\n1 2 3  public interface SingerSongWriter extends Singer, Songwriter { AudioClip strum(); }   이런식으로 Singer와 Songwriter모두를 확장하고 새로운 메서드까지 추가한 제3의 인터페이스도 정의할 수 있습니다. 같은 구조를 클래스로 만드려면 속성이 n개라면 지원해야 할 조합의 수는 2^n개가 됩니다 이러한 현상을 조합 폭발(combinatorial explosion)이라고 부릅니다.\n인터페이스의 메서드 중 구현 방법이 명백한 것이 있다면, 그 구현을 디폴트 메서드로 제공하는 것도 방법입니다. 하지만 디폴트 메서드에도 제약이 있습니다. 많은 인터페이스가 equals와 hashCode같은 Object의 메서드를 정의하고 있지만, 이들은 디폴트 메서드로는 제공해서는 안 됩니다.\n또한 인터페이스는 인스턴스 필드를 가질 수 없고 public이 아닌 정적멤버도 가질 수 없습니다. 마지막으로 여러분들이 만들지 않은 인터페이스에는 디폴트 메서드를 추가할 수 없습니다.\n정리   일반적으로 다중 구현용 타입으로는 인터페이스가 적합합니다. 복잡한 인터페이스라면 구현하는 수고를 덜어주는 골격 구현을 함께 제공하는 방법도 고려하는걸 추천합니다.   ","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-03/item20/","summary":"[아이템 20] 추상 클래스보다는 인터페이스를 우선하라. 자바가 제공하는 다중 구현 메커니즘은 인터페이스와 추상 클래스가 있습니다. 자바8 부터는 인터페이스에서 defualt moethod를 제공할 수 있게 되어서 두 메커니즘 모두 인스턴스 메서드를 구현 형태로 제공할 수 있습니다.\n추상 클래스와 인터페이스의 큰 차이점은 추상 클래스의 정의한 타입을 구현 클래스는 반드시 서브클래스가 된다는 점입니다. 자바에서는 단일 상속만 지원하기 때문에 이런 제약은 새로운 타입을 정의하는데 커다란 제약이 됩니다.\n반면 인터페이스의 준수 사항을 잘 지키고 모든 메서드를 구현한 클래스는 어느 계층에 있든 인터페이스를 구현할 수 있습니다.","title":"[아이템 20] 추상 클래스보다는 인터페이스를 우선하라"},{"content":"[아이템 19] 상속을 고려해 설계하고 문서화하라. 그렇지 않았다면 상속을 금지하라. 여기서 말하는 외부란 프로그래머의 통제권 밖에 있어서 언제 어떤식으로 변경될지 모른다는 뜻입니다.\n상속을 고려한 문서화  상속용 클래스는 재정의할 수 있는 메서드들은 내부적으로 어떻게 이용하는지 문서로 남겨야 합니다. 클래스의 내부 동작 과정 중간에 끼어들 수 있는 훅(hook)을 잘 선별하여 protected메서드 형태로 공개하는 것도 고려해보는 것도 좋습니다. (한편으로 너무 적게 노출해서 상속으로 얻는 이점을 없애지 않도록 주의해야 합니다.) 상속용으로 설계한 클래스는 배포 전에 반드시 하위 클래스를 만들어 검증 해야 합니다.  상속을 허용하는 클래스가 지켜야 할 제약 상속용 클래스의 생성자는 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안 됩니다.\n상위 클래스의생성자가 하위 클래스의 생성자보다 먼저 실행되므로 하위 클래스에서 재정의한 메서드가 하위 클래스의 생성자보다 먼저 호출됩니다.\n상속을 금지하는 방법에는 두 가지 방법이 있습니다. 첫 번째는 클래스를 final으로 선언하는 것과 두번째는 모든 생성자를 private나 package-private로 선언하고 public 정적 팩터리를 만들어주는 방법입니다.\n정리  상속을 하려면 문서화를 해야 하며, 문서화 한 것은 반드시 지켜야 합니다. 클래스를 확장해야 할 명확한 이유가 없으면 아이템17에서 다뤘던 방식으로 상속을 금지합시다.  ","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-03/item19/","summary":"[아이템 19] 상속을 고려해 설계하고 문서화하라. 그렇지 않았다면 상속을 금지하라. 여기서 말하는 외부란 프로그래머의 통제권 밖에 있어서 언제 어떤식으로 변경될지 모른다는 뜻입니다.\n상속을 고려한 문서화  상속용 클래스는 재정의할 수 있는 메서드들은 내부적으로 어떻게 이용하는지 문서로 남겨야 합니다. 클래스의 내부 동작 과정 중간에 끼어들 수 있는 훅(hook)을 잘 선별하여 protected메서드 형태로 공개하는 것도 고려해보는 것도 좋습니다. (한편으로 너무 적게 노출해서 상속으로 얻는 이점을 없애지 않도록 주의해야 합니다.) 상속용으로 설계한 클래스는 배포 전에 반드시 하위 클래스를 만들어 검증 해야 합니다.","title":"[아이템 19] 상속을 고려해 설계하고 문서화하라. 그렇지 않았다면 상속을 금지하라"},{"content":"[아이템 18] 상속보다는 컴포지션을 사용하라. 우선 이번 아이템에서 다루는 상속은 클래스가 다른 클래스를 확장하는 것을 말합니다.\n상속 같은 경우 상위 클래스가 구현 방식에 따라 하위 클래스 동작에 영향을 미칠 수 있습니다.\n예제를 위한 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  public class CustomHashSet\u0026lt;E\u0026gt; extends HashSet\u0026lt;E\u0026gt; { private int addCount = 0; public CustomHashSet() { } @Override public boolean add(E e) { addCount++; System.out.println(\u0026#34;hello\u0026#34;); return super.add(e); } @Override public boolean addAll(Collection\u0026lt;? extends E\u0026gt; c) { addCount += c.size(); return super.addAll(c); } public int getAddCount() { return addCount; } }   1 2 3  CustomHashSet\u0026lt;String\u0026gt; set = new CustomHashSet\u0026lt;\u0026gt;(); set.addAll(Arrays.asList(\u0026#34;가\u0026#34;,\u0026#34;나\u0026#34;,\u0026#34;다\u0026#34;)); System.out.println(set.getAddCount());   원소를 3개 삽입했지만 getAddCount를 출력하면 결과값은 6이 나옵니다.\n디버깅을 해본 결과 상위 클래스에서 addAll메서드에서 add를 호출하는데 여기서 add는 오버라이딩 된 add메서드를 결과적으로 3번 더 호출하게 됐습니다.\n추가로 다음 릴리즈에서 상위 클래스에 새로운 메서드를 추가했는데, 하필 하위 클래스에 추가한 메서드와 시그니처가 같고 반환 타입이 다를 경우 컴파일조차 되지 않습니다.\n이러한 문제점들은 컴포지션을 통해서 쉽게 피해갈 수 있습니다. 컴포지션은 기존 클래스를 확장하는 대신 새로운 클래스를 만들고 private필드로 기존 클래스의 인스턴스를 참조해서 이용할 수 있습니다.\n상속은 클래스 B가 클래스 A와 is-a 관계일 때만 클래스 A를 상속해야 합니다.\n클래스 B가 A를 상속하기 전에 B가 A인가? 자문해보고 \u0026ldquo;그렇다\u0026quot;라는 확신이 들지 않으면 컴포지션(has-a) 을 이용하는 게 좋습니다.\n컴포지션을 써야 할 상황에서 상속을 사용하는 건 내부 구현을 불필요하게 노출하는 꼴입니다.\n그 결과 API가 내부 구현에 묶이고 그 클래스의 성능도 영원히 제한됩니다. 더 심각한 문제는 클라이언트가 노출된 내부에 직접 접근 할 수 있다는 점입니다.\n컴포지션 대신 상속을 사용하기로 결정하면 마지막으로 자문해야 될 질문이 있습니다.\n\u0026ldquo;확장하려는 클래스의 API에 아무런 결함이 없는가\u0026rdquo; 결함이 있다면, 이 결함이 여러분 클래스의 API까지 전파돼도 괜찮은가?\n상속은 상위 클래스의 API를 그 결함까지도 그대로 승계합니다.\n정리  상속은 강력하지만 캡슐화를 해친다는 단점이 있습니다. 상속은 상위 클래스와 하위클래스가 순수한 is-a 관계일 때만 사용해야합니다. 상속의 단점을 피하려면 컴포지션을 활용합시다.  ","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-03/item18/","summary":"[아이템 18] 상속보다는 컴포지션을 사용하라. 우선 이번 아이템에서 다루는 상속은 클래스가 다른 클래스를 확장하는 것을 말합니다.\n상속 같은 경우 상위 클래스가 구현 방식에 따라 하위 클래스 동작에 영향을 미칠 수 있습니다.\n예제를 위한 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  public class CustomHashSet\u0026lt;E\u0026gt; extends HashSet\u0026lt;E\u0026gt; { private int addCount = 0; public CustomHashSet() { } @Override public boolean add(E e) { addCount++; System.","title":"[아이템 18] 상속보다는 컴포지션을 사용하라"},{"content":"[아이템 17] 변경 가능성을 최소화하라. 불변 클래스(Immutable Class)란 말 그대로 객체가 생성된 후에 더이상 값을 변경할 수 없는 것을 의미합니다. 자바에서는 대표적으로 String, Integer, Float,Long 등이 있습니다.불변 클래스의 장점\n클래스를 불변으로 만들기 위한 규칙  객체의 상태를 변경하는 메서드를 제공하지 않습니다. 클래스를 확장할 수 없도록 합니다. 모든 필드를 private final으로 선언합니다. 생성자 관리를 잘할 것 (밑에서 설명) 자신 외에는 내부에 가변 컴포넌트에 접근할 수 없도록 합니다.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  public final class Calculator { private final int x; private final int y; public Calculator(int x, int y) { this.x = x; this.y = y; } public Calculator plus(Calculator c) { return new Calculator(x + c.x, y + c.y); } public Calculator minus(Calculator c) { return new Calculator(x - c.x, y - c.y); } ... 생략 }   여기서 주목할 점은 메서드들이 인스턴스 자신을 수정하지 않고 새로운 Calculator 인스턴스를 만들어 반화하는 것입니다.\n불변 객체의 장점  불변 객체는 Thread-Safe 하므로 멀티 쓰레드 환경에서 안전하게 사용할 수 있습니다. 불변 객체는 하나의 상태만을 갖고 있으므로 데이터를 신뢰할 수 있습니다.  따라서 불변 클래스라면 한번 만든 인스턴스를 최대한 재활용 하길 추천합니다. 재활용 하기 가장 쉬운 방법은 자주 쓰이는 값들을 상수로 제공하는 것입니다.\n1 2  public static final Calculator ONE = new Calculator(1, 0); ...   이 방식을 더 살펴보면 불변 클래스는 자주 사용되는 인스턴스를 캐싱하여 같은 인스턴스를 중복 생성하지 않게 해주는 정적 팩터리를 제공할 수 있습니다. 대표적으로 박싱된 기본 타입 클래스가 있습니다.이런 정적 팩터리를 사용하면 여러 클라이언트가 인스턴스를 공유하여 메모리 사용량과 가비지 컬렉션 비용이 줄어듭니다. 하지만 붋변 객체에도 단점이 있습니다.값이 다르면 반드시 독립된 객체로 만들어야 합니다. (성능 이슈)\n불변 클래스를 만드는 설계 방법 클래스가 불변임을 보장하려면 자신을 상속하지 못하게 해야하는데 가장 쉬운 방법은 final으로 선언해주는 것입니다. 하지만 이것보다 더 유연한 방법이 있습니다. 모든 생성자를 private 혹은 package-private으로 만들고 public 정적 펙터리를 제공하는 방법입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  public final class Calculator { private final int x; private final int y; private Calculator(int x, int y) { this.x = x; this.y = y; } public static Calculator valueOf(int x, int y) { return new Calculator(x, y); } ... }   정적 팩토리 방식으로 다수의 구현 클래스를 활용해 유연성을 제공하고, 객체 캐싱 기능을 추가해 성능을 끌어올리 수 있습니다.BigInteger와 BigDecimal의 주의점 두 클래스를 설계할 당시 불변 객체가 final이어야 한다는 인식이 없었습니다. 그래서 두 클래스의 메서드들은 모두 재정의할 수 있게 설계 되었고 하위 호환성이 발목을 잡아 지금까지도 이 문제를 고치지 못했습니다. 그러므로 신뢰할 수 없는 클라이언트로부터 BigInteger와 BigDecimal의 인스턴스를 인수로 받는다면 주의해야 합니다.\n1 2 3 4  public static BigInteger safeInstance(BingInteger val) { return val.getClass() == BigInteger.class ? val : new BigInteger(val.toByteArray()); }   ","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-03/item17/","summary":"[아이템 17] 변경 가능성을 최소화하라. 불변 클래스(Immutable Class)란 말 그대로 객체가 생성된 후에 더이상 값을 변경할 수 없는 것을 의미합니다. 자바에서는 대표적으로 String, Integer, Float,Long 등이 있습니다.불변 클래스의 장점\n클래스를 불변으로 만들기 위한 규칙  객체의 상태를 변경하는 메서드를 제공하지 않습니다. 클래스를 확장할 수 없도록 합니다. 모든 필드를 private final으로 선언합니다. 생성자 관리를 잘할 것 (밑에서 설명) 자신 외에는 내부에 가변 컴포넌트에 접근할 수 없도록 합니다.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  public final class Calculator { private final int x; private final int y; public Calculator(int x, int y) { this.","title":"[아이템 17] 변경 가능성을 최소화하라"},{"content":"[아이템 16] public 클래스에서는 public 필드가 아닌 접근 메서드를 사용하라. 1 2 3 4 5  // 부적적한 코드 public class Point { public int x; public int y; }   위 코드는 객체지향의 특징 중 하나인 캡슐화를 살리지 못했습니다.다음과 같이 추상화의 이점을 살려서 코드를 수정할 수 있습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  public class Point { public int x; public int y; public Point(int x, int y) { this.x = x; this.y = y; } public int getX() { return x; } public int getY() { return y; } public void setX(int x) { this.x = x; } public void setY(int y) { this.y = y; } }   외부에서 접근할 수 있는 클래스라면 접근자를 제공함으로써 클래스 내부 표현 방식을 변경할 수 있는 유연성을 얻을 수 있습니다. public 클래스의 불변이라면 직접 노출할 때의 단점이 줄어들지만 여전히 문제점은 있습니다. API를 변경하지 않고는 표현 방식을 바꿀 수 없고, 필드를 읽을 때 부수 작업을 수행할 수 없다는 단점이 있습니다. 하지만 불변식은 보장할 수 있습니다.\n정리  public 클래스의 가변 필드는 절대 노출해서는 안 됩니다. 불변 필드라면 위험은 덜 하지만 완전히 안심할 수는 없습니다. 하지만 package-private 클래스나 private 중첩 클래스에서는 필드를 노출하는 편이 나을 때도 있습니다.\n ","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-03/item16/","summary":"[아이템 16] public 클래스에서는 public 필드가 아닌 접근 메서드를 사용하라. 1 2 3 4 5  // 부적적한 코드 public class Point { public int x; public int y; }   위 코드는 객체지향의 특징 중 하나인 캡슐화를 살리지 못했습니다.다음과 같이 추상화의 이점을 살려서 코드를 수정할 수 있습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  public class Point { public int x; public int y; public Point(int x, int y) { this.","title":"[아이템 16] public 클래스에서는 public 필드가 아닌 접근 메서드를 사용하라"},{"content":"[아이템 15] 클래스와 멤버의 접근 권한을 최소화하라. 잘 설계된 컴포넌트와 그렇지 못한 컴포넌트의 가장 큰 차이는 클래스 내부 데이터와 내부 구현 정보를 외부 컴포넌트로부터 얼마나 잘 숨겼느냐입니다. 설계가 잘 된 컴포넌트는 모든 내부 구현을 숨겨, 구현과 API를 깔끔하게 분리합니다.\n정보 은닉(캡슐화)의 장점  시스템 개발 속도를 높입니다. (여러 컴포넌트를 병렬로 개발할 수 있기 때문에) 시스템 관리 비용을 낮춥니다. (각 컴포넌트를 더 빨리 파악하여 디버깅할 수 있고, 다른 컴포넌트로 교체하는 비용도 적기 때문에) 성능 최적화에 도움을 줍니다. (다른 컴포넌트에 영향을 주지 않고 특정 컴포넌트만 최적화 할 수 있어서) 재사용성을 높입니다. (독자적으로 동작하는 컴포넌트는 다른 환경에서도 쓰일 수 있기 때문에)  접근 제어자를 잘 활용하는 것이 정보 은닉의 핵심입니다.가본 원칙은 모든 클래스와 멤버의 접근성을 가능한 좁혀야 합니다. 즉 애플리케이션이 제대로 동작하는 한 항상 가장 낮은 접근 수준을 부여해야 합니다.톱레벨(가장 바깥) 클래스와 인터페이스에 부여할 수 있는 접근 제어자는 public과 package-private(default) 두 가지 입니다.\npublic으로 선언하면 공개 API가 되므로 패키지 외부에서 쓸 일이 없다면 package-private로 선언하는 걸 권장합니다.한 클래스에서만 사용하는 package-private 톱레벨 클래스나 인터페이스는 이를 사용하는 클래스 안에 private static으로 중첩시켜봅시다. 이렇게 하면 바깥 클레스 하나에서만 접근할 수 있습니다.\n멤버(필드, 메섣, 중첩 클래스, 중첩 인터페이스)에 사용할 수 있는 접근제한자\n private: 멤버를 선언한 톱레벨 클래스에서만 접근 가능합니다. package-private: 멤버가 소속된 패키지안에 모든 클래스에서 접근 가능합니다 protected: package-private + 하위 클래스 public: 모든 곳에서 접근할 수 있습니다.  public 클래스의 인스턴스 필드는 가능한 public이 아니어야 합니다. 필드가 가변 객체를 참조하거나, final이 아닌 인스턴스필드를 public으로 선언하면 필드의 내용이 수정될 수 있으므로 불변을 보장할 수 없게 되므로 유의해야 합니다. 필드가 final이면서 불변 객체를 참조해도 문제는 있습니다. 내부 구현을 바꾸고 싶어도 public 필드를 없애는 방식으로는 리팩터링 할 수 없게 됩니다.정적 필드 같은 경우 추상 개념을 완성하는데 꼭 필요한 구성요소로써의 상수라면 public static final필드로 공개해도 좋으나 반드시 primitive type이나 불변 객체를 참조해야 합니다. 가변 객체를 참조한다면 참조는 변경하지 못하나 객체 값은 수정될 수 있으므로 주의해야 합니다.정리  프로그램의 접근 제어자는 가능한 최소한으로 합시다. 꼭 필요한 것만 public API를 설계하고 그 외에는 의도치 않게 API로 공개되는 일이 없도록 해야 합니다. public클래스는 public static final 필드 외에는 어떠한 public 메서드도 가져서는 안 됩니다. 또한 public static final 필드가 참조하는 객체가 불변인지 확인합시다.\n ","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-03/item15/","summary":"[아이템 15] 클래스와 멤버의 접근 권한을 최소화하라. 잘 설계된 컴포넌트와 그렇지 못한 컴포넌트의 가장 큰 차이는 클래스 내부 데이터와 내부 구현 정보를 외부 컴포넌트로부터 얼마나 잘 숨겼느냐입니다. 설계가 잘 된 컴포넌트는 모든 내부 구현을 숨겨, 구현과 API를 깔끔하게 분리합니다.\n정보 은닉(캡슐화)의 장점  시스템 개발 속도를 높입니다. (여러 컴포넌트를 병렬로 개발할 수 있기 때문에) 시스템 관리 비용을 낮춥니다. (각 컴포넌트를 더 빨리 파악하여 디버깅할 수 있고, 다른 컴포넌트로 교체하는 비용도 적기 때문에) 성능 최적화에 도움을 줍니다.","title":"[아이템 15] 클래스와 멤버의 접근 권한을 최소화하라"},{"content":"[아이템 14] Comparable를 구현할지 고려하라 자바에서는 Comparable과 Comparator이라는 정렬 인터페이스를 제공합니다. Comparable은 기본 정렬기준을 구현하는 데 사용하고, Comparator은 기본 정렬기준 외에 다른 기준으로 정렬하고자 할 때 사용합니다. 여기서는 Comparable의 하나 밖에 없는 compareTo메서드에 대해서 알아봅시다.\nComparable을 구현했다는 것은 그 클래스의 인스턴스들에는 natural order가 있음을 의미합니다.\n그래서 Comparable을 구현한 객체들의 배열은 다음과 같이 정렬할 수 있습니다.\n1  Arrays.sort(a);   compareTo 메서드의 규약 이 객체가 주어진 객체(매개변수로 받는)보다 작으면 음의 정수를, 같으면 0을, 크면 양의 정수를 반환합니다. 이 객체와 비교할 수 없는 타입이면 ClassCastException을 던집니다.\n다음 설명에서는 sgn(표현식) 표기는 수학에서 말하는 부호 함수를 뜻하며, 표현식의 값이 음수, 0, 양수일 때 -1, 0, 1을 반환하도록 정의했습니다.\n  Comparable을 구현한 클래스는 모든 x, y에 대해,\nsgn(x.comparaTo(y)) == -sgn(y.comparaTo(x))여야 합니다.\n따라서 sgn(x.comparaTo(y))는 -sgn(y.comparaTo(x))가 예외를 던질 때에 한해 예외를 던져야 합니다.\n  Comparable을 구현한 클래스는 추이성을 보장해야 합니다.\nx.comparaTo(y) \u0026gt; 0 \u0026amp;\u0026amp; y.comparaTo(z) \u0026gt; 0이면 x.compareTo(z) \u0026gt; 0입니다.\n  Comparable을 구현한 클래스는 모든 z에 대해 x.compareTo(y) == 0이면 sgn(x.compareTo(z)) == sgn(y.compareTo(z))입니다.\n  이번 권고가 필수는 아니지만 꼭 지키는 게 좋습니다. (x.compareTo(y) == 0) == (x.equals(y))여야 합니다.\n  hashCode 규약을 지키지 못하면 해시를 사용하는 클래스에서 오작동이 날 수 있듯이 compareTo 규약을 지키지 못하면 TreeSet, TreeMap과 같이 비교를 활용하는 클래스에서 오작동이 날 수 있습니다.\nCompareble 인터페이스은 타입 인수를 받는 제네릭 인터페이스므로 compareTo 메서드의 인수 타입은 컴파일타임에 정해집니다. 즉 매개변수 타입이 잘못 됐다면 컴파일 자체가 되지 않으므로 형변환 할 필요가 없다는 뜻입니다.\n객체 참조 필드를 비교하려면 compareTo 메서드를 재귀적으로 호출합니다. Compareble을 구현하지 않은 필드나 표준이 아닌 순서로 비교해야 한다면 Comparator를 사용하면 됩니다.\n클래스의 핵심 필드가 여러개라면 가장 핵심적인 필드부터 비교하는 것을 추천드립니다. 비교 결과가 0이 아니라면 순서는 거기서 셜정되기 떄문입니다.\nJAVA 8에서 compareTo 메서드를 구현하기\n1 2 3 4 5 6 7 8 9 10 11  List\u0026lt;Student\u0026gt; students = Arrays.asList( new Student(30, \u0026#34;kim\u0026#34;), new Student(50, \u0026#34;jake\u0026#34;), new Student(50, \u0026#34;foo\u0026#34;) ); students.sort( Comparator.comparingInt(Student::getAge) .thenComparing(Student::getName) ); // 이뿐만 아니라 다양한 방식으로 정렬을 할 수 있습니다.   위와 같이 코드를 간결하게 짤 수 있습니다. 대신 약간의 성능 저하가 있습니다.\n","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-02/item14/","summary":"[아이템 14] Comparable를 구현할지 고려하라 자바에서는 Comparable과 Comparator이라는 정렬 인터페이스를 제공합니다. Comparable은 기본 정렬기준을 구현하는 데 사용하고, Comparator은 기본 정렬기준 외에 다른 기준으로 정렬하고자 할 때 사용합니다. 여기서는 Comparable의 하나 밖에 없는 compareTo메서드에 대해서 알아봅시다.\nComparable을 구현했다는 것은 그 클래스의 인스턴스들에는 natural order가 있음을 의미합니다.\n그래서 Comparable을 구현한 객체들의 배열은 다음과 같이 정렬할 수 있습니다.\n1  Arrays.sort(a);   compareTo 메서드의 규약 이 객체가 주어진 객체(매개변수로 받는)보다 작으면 음의 정수를, 같으면 0을, 크면 양의 정수를 반환합니다.","title":"[아이템 14] Comparable를 구현할지 고려하라"},{"content":"[아이템 13] clone 재정의는 주의해서 진행하라. 실무에서 Cloneable을 구현한 클래스는 clone 메서드를 public으로 제공하며, 사용자는 당연히 복제가 제대로 이뤄지리라 기대합니다.\n하지만 clone 메서드의 일반 규약은 허술한 부분이 있습니다. 다음은 Object 명세에서 가져온 설명입니다.\n이 객체의 복사본을 생성해 반환합니다. \u0026lsquo;복사\u0026rsquo;의 정확한 뜻은 그 객체를 구현한 클래스에 따라 다를 수 있지만 일반적은 의도는 다음과 같습니다. 어떤 객체 x에 대해 다음 식은 참입니다.\n x.clone() != x x.clone.getClass() = x.getClass() x.clone().equals(x)  clone을 사용하는 방법은 굉장히 쉽습니다. Cloneable인터페이스를 구현하고 super.clone을 호출하면 됩니다. 이렇게 얻은 객체는 원본의 모든 필드랑 똑같은 값을 가지게 됩니다.\n1 2 3 4 5 6 7 8  @Override public PhoneNumber clone() { try{ return (PhoneNumber) super.class(); } catch (CloneNotSupportedException e) { throw new AssertionsError(); } }   Obejct의 clone은 Object를 반환하지만 공변 반환 타입을 이용해서 PhoneNumber로 반환했습니다. 이 방식으로 사용하는 클라이언트는 형변환을 따로 해줄 필요가 없습니다.\n간단했던 앞서의 구현이 클래스가 가변 객체를 참조하는 순간 문제점이 발생합니다.\n1 2 3 4 5 6 7 8 9 10 11  public class Stack { private Object[] elements; private int size = 0; private static final int DEFAULT_INITIAL_CAPACITY = 16; public Stack() { this.elements = new Object[DEFAULT_INITIAL_CAPACITY]; } ... 생략 }   clone 메서드가 단순히 super.clone의 결과를 그대로 반환하면 Stack인스턴스의 size 필드는 올바른 값을 갖겠지만, elements필드는 원본 Stack 인스턴스와 똑같은 배열을 참조하게 되는 상황이 발생합니다.\nclone메서드는 사실상 생성자와 같은 효과를 냅니다. 즉 clone은 원본 객체에 아무런 변화가 없는 동시에 복제된 객체의 불변식을 보장해야 합니다.\n1 2 3 4 5 6 7 8 9 10 11  // 가변 상태를 참조하는 클래스용 clone 메서드 @Override public PhoneNumber clone() { try{ Stack result = (Stack) super.clone(); result.elements = elements.clone(); return result; } catch (CloneNotSupportedException e) { throw new AssertionsError(); } }   ","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-02/item13/","summary":"[아이템 13] clone 재정의는 주의해서 진행하라. 실무에서 Cloneable을 구현한 클래스는 clone 메서드를 public으로 제공하며, 사용자는 당연히 복제가 제대로 이뤄지리라 기대합니다.\n하지만 clone 메서드의 일반 규약은 허술한 부분이 있습니다. 다음은 Object 명세에서 가져온 설명입니다.\n이 객체의 복사본을 생성해 반환합니다. \u0026lsquo;복사\u0026rsquo;의 정확한 뜻은 그 객체를 구현한 클래스에 따라 다를 수 있지만 일반적은 의도는 다음과 같습니다. 어떤 객체 x에 대해 다음 식은 참입니다.\n x.clone() != x x.clone.getClass() = x.getClass() x.clone().equals(x)  clone을 사용하는 방법은 굉장히 쉽습니다.","title":"[아이템 13] clone 재정의는 주의해서 진행하라"},{"content":"[아이템 12] toString을 항상 재정의하라. toString을 오버라이딩 하지 않으면 기본적으로 클래스_이름@16진수로_표현한_해시코드를 반환합니다.\n이렇게 되면 객체의 특성을 알아볼 수 있으므로 toString을 재정의 할 필요가 있습니다.\n1 2  Student student = new Student(\u0026#34;kim\u0026#34;, 16); System.out.println(student);   위 코드를 실행하면 Student@abcd같은 형태로 콘솔에 출력되므로 객체의 특성을 파악하기가 힘듭니다.\ntoString 재정의하는 좋은 방법.  객체가 가진 가진 주요 정보를 모두 반환하는 게 좋습니다. toString을 구현하면 반환값의 포맷을 문서화할지 정해야 합니다.  규칙이 명확해지는 장점이 있지만, 한번 명시하면 그 포맷에 얽매이게 됩니다. 이러한 문제는 롬복으로 해결할 수 있습니다.   포맷을 명시하든 아니든 여러분의 의도는 명확하게 밝혀져야합니다. toString이 반환한 값에 포함된 정보를 얻어올 수 있는 API를 제공합시다.  정리 객체의 정보를 출력할 일이 있으면 toString을 재정의 합시다. toString을 재정의하면 사용자가 보기 편하고 디버깅을 쉽게 해줍니다. toString은 객체에 관해 명확하고 정보를 읽기 좋은 형태로 반환해야합니다.\n","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-02/item12/","summary":"[아이템 12] toString을 항상 재정의하라. toString을 오버라이딩 하지 않으면 기본적으로 클래스_이름@16진수로_표현한_해시코드를 반환합니다.\n이렇게 되면 객체의 특성을 알아볼 수 있으므로 toString을 재정의 할 필요가 있습니다.\n1 2  Student student = new Student(\u0026#34;kim\u0026#34;, 16); System.out.println(student);   위 코드를 실행하면 Student@abcd같은 형태로 콘솔에 출력되므로 객체의 특성을 파악하기가 힘듭니다.\ntoString 재정의하는 좋은 방법.  객체가 가진 가진 주요 정보를 모두 반환하는 게 좋습니다. toString을 구현하면 반환값의 포맷을 문서화할지 정해야 합니다.  규칙이 명확해지는 장점이 있지만, 한번 명시하면 그 포맷에 얽매이게 됩니다.","title":"[아이템 12] toString을 항상 재정의하라"},{"content":"[아이템 11] equals를 재정의하려거든 hashCode도 재정의하라. equals와 hasoCode를 재정의 하지 않으면 HashMap이나 HashSet에서 같은 원소를 사용할 때 문제가 발생합니다.\n equals 비교에 사용되는 정보가 변경되지 않는다면, 애플리케이션이 실행되는 동안 객체의 hashCode메서드는 여러번 호출해도 일관된 값을 반환해야 합니다. equals가 두 객체를 같다고 판단하면 hashCode 또한 같은 값을 반환해야 합니다. equals가 두 객체를 다르다고 판단해도, 두 객체의 hashCode가 서로 다른 값을 반환할 필요는 없습니다. 단, 다른 객체에 대해서는 다른 값을 반환해야 해시테이블의 성능이 좋아집니다.  서로 다른 인스턴스에 대해서 모두 다른 해시코드를 반환하면 좋겠지만 hashCode는 int형이므로 2^32만큼의 경우의 수로 제한되어 있기 때문에 비둘기 집의 원리로 예외가 생길 수 있습니다.\n다음은 hashCode를 작성하는 요령입니다.\n  int 변수 result를 선언한 후 값 c로 초기화 합니다. 이때 c는 해당 객체의 첫번째 해시 필드를 2-a 방식으로 계산한 해시코드입니다.\n  나머지 개개의 필드 f 각각에 대해서 다음 작업을 수행합니다.\na. 해당 필드의 해시코드 c를 계산합니다.\n 기본 타입 필드라면, Type.hashCode(f)를 수행합니다. 여기서 Type은 해당 기본 타입의 박싱 클래스입니다. 참조 타입 필드면서 이 클래스의 equals 메서드가 이 필드의 equals를 재귀적으로 호출해 비교한다면, 이 필드의 hashCode를 재귀적으로 호출합니다. 필드가 배열이라면, 원소 각각을 별도 필드처럼 다룹니다. 이상의 규칙을 재귀적으로 적용해 각 핵심 원소의 해시코드를 계산한 다음, 2.b방식으로 갱신합니다. 배열에 핵심 원소가 하나도 없다면 단순 상수를 사용하고 모든 원소가 핵심 원소라면 Arrays.hashCode를 사용합니다.  b. 2.a에서 계산한 해시코드 c로 result를 갱신합니다.\n result = 31 * result + c;\n    result를 반환합니다.\nequals 비교에서 사용되지 않는 필드는 반드시 제외해야 합니다. 그렇지 않으면 맨 처음에 언급했던 두 번째 규약을 어기게됩니다.\n  숫자를 곱하는 이유는 만약 곱셉 없는 hahCode를 구현하게 되면 모든 아나그램의 해시코드가 같아집니다. 그리고 31을 선택한 이유는 홀수이면서 소수이기 때문입니다.\n1 2 3 4 5 6 7 8  // 전형적인 hashCode 메서드 @Override public int hashCode() { int result = Short.hashCode(areaCode); result = 31 * result + Short.hashCode(prefix); result = 31 * result + Short.hashCode(lineNum); return result; }   1 2 3 4 5  // 한 줄짜리 hasoCode 메서드 - 성능이 살짝 아쉽습니다. @Override public int hashCode(){ return Objects.hash(lineNum, prefix, areaCode); }   정리 equals를 재정의 할 때는 hashCdoe도 재정의해야 합니다. 그렇지 않으면 프로그래밍이 제대로 동작하지 않을 수 있습니다. 서로 다른 인스턴스라면 되도록 해시코드도 서로 다르게 구현해야 합니다.\n","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-02/item11/","summary":"[아이템 11] equals를 재정의하려거든 hashCode도 재정의하라. equals와 hasoCode를 재정의 하지 않으면 HashMap이나 HashSet에서 같은 원소를 사용할 때 문제가 발생합니다.\n equals 비교에 사용되는 정보가 변경되지 않는다면, 애플리케이션이 실행되는 동안 객체의 hashCode메서드는 여러번 호출해도 일관된 값을 반환해야 합니다. equals가 두 객체를 같다고 판단하면 hashCode 또한 같은 값을 반환해야 합니다. equals가 두 객체를 다르다고 판단해도, 두 객체의 hashCode가 서로 다른 값을 반환할 필요는 없습니다. 단, 다른 객체에 대해서는 다른 값을 반환해야 해시테이블의 성능이 좋아집니다.","title":"[아이템 11] equals를 재정의하려거든 hashCode도 재정의하라"},{"content":"[아이템 10] equals는 일반 규약을 지켜 재정의하라. equals 메서드를 오버라이딩 하는 경우는 논리적인 동치성을 확인하기 위해서입니다.여기서 말하는 논리적 동치성은 쉽게 말하자면 참조값을 비교하는 게 아닌 객체의 값이 같은지 비교하기 위함이라고 할 수 있습니다.\nequals메서드를 오버라아딩 할 때는 다음의 규약을 따라야 합니다.\n반사성(reflexivity)  null이 아닌 모든 참조 값 x에 대해, x.equals(x)는 true입니다.  대칭성(symmetry)  null이 아닌 모든 참조 값 x, y에 대해 x.equals(y)는 y.equals(x)입니다.  잘못된 코드 - 대칭성 위반\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  public class CaseInsensitiveString { private String str; ... 생략 @Override public boolean equals(Object o) { if (o instanceof CaseInsensitiveString) { return str.equalsIgnoreCase(((CaseInsensitiveString) o).str); } if (o instanceof String) { return str.equalsIgnoreCase((String) o); } return false; } }   1 2  CaseInsensitiveString cis = new CaseInsensitiveString(\u0026#34;String\u0026#34;); String str = \u0026#34;string\u0026#34;;   cis.equals(str)는 true를 반환하고 str.equals(cis)는 false를 반환하게 되므로 대칭성에 위반됩니다.\n추이성(transitivity)  null이 아닌 모든 참조 값 x, y, z에 대해 x.equals(y)가 true고 y.equals(z)도 true입니다.  일관성(consistency)  null이 아닌 모든 참조 값 x, y에 대해 x.equals(y)를 반복해서 호출하면 항상 true를 반환하거나 항상 false를 반환해야 합니다.  null-아님  null이 아닌 모든 참조 값 x에 대해 x.equals(null)은 false다  이제 상위 클래스에 없는 필드를 하위 클래스에 추가하는 상황을 생각해봅시다. 여기서부터 신경써야 할 부분들이 많아집니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  public class Point { private int x; private int y; ... 생략 @Override public boolean equals(Object o) { if (!(o instanceof Point)) { return false; } Point p = (Point) o; return this.x == p.x \u0026amp;\u0026amp; this.y == p.y; } }   Point클래스를 확장해봅시다.\n1 2 3 4 5 6 7 8 9 10 11 12 13  public class CirclePoint extends Point{ private int x; private int y; private int z; public CirclePoint(int x, int y, int z) { super(x, y); this.z = z; } ... 생략 }   이대로 사용하면 Point의 구현이 상속되어 x, y만 비교하게 되므로 생각했던 결과랑 실제 결과값이 다르게 나오는 상황이 발생합니다.객체 지향의 추상화의 이점을 포기하지 않는 이상 아쉽게도 이러한 문제점들을 모두 완전하게 해결할 수 있는 방법은 없습니다.\n양질의 equals메서드 구현 단계  == 연산자를 사용해 입력이 자기 자신의 참조인지 확인합니다. insetanceof 연산자로 입력이 올바른 타입인지 확인합니다. 입력을 올바른 타입으로 형변환 합니다. 입력받은 객체와 자기 자신의 대응되는 필드들이 모두 일치하는지 검사합니다.  어떤 필드를 먼저 비교하느냐에 따라 성능의 차이도 생깁니다. 값이 다를 가능성이 크거나 비교하는 비용이 싼 필드를 먼저 비교하면 성능상 이점을 얻을 수 있습니다.(틀리면 다음 로직을 실행하지 않기에)\n","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-02/item10/","summary":"[아이템 10] equals는 일반 규약을 지켜 재정의하라. equals 메서드를 오버라이딩 하는 경우는 논리적인 동치성을 확인하기 위해서입니다.여기서 말하는 논리적 동치성은 쉽게 말하자면 참조값을 비교하는 게 아닌 객체의 값이 같은지 비교하기 위함이라고 할 수 있습니다.\nequals메서드를 오버라아딩 할 때는 다음의 규약을 따라야 합니다.\n반사성(reflexivity)  null이 아닌 모든 참조 값 x에 대해, x.equals(x)는 true입니다.  대칭성(symmetry)  null이 아닌 모든 참조 값 x, y에 대해 x.equals(y)는 y.equals(x)입니다.  잘못된 코드 - 대칭성 위반","title":"[아이템 10] equals는 일반 규약을 지켜 재정의하라"},{"content":"[아이템 9] try-finally보다는 try-with-resources를 사용하라 자바 라이브러리에는 InputStream, OutputStream, java.sql.Connection과 같이 직접 close를 해야 하는 자원들 있습니다. 클라이언트는 실수로 자원을 닫아주지 않는 경우 예상치 못한 성능 문제로 이어질 수 있습니다.\n1 2 3 4 5 6 7 8 9  static String firstLineOfFile(String path) throws IOException { BufferedReader br = new BufferedReader(new FileReader(path)); try { return br.readLine(); } finally { br.close(); } } }   나쁘진 않지만 자원을 더 사용하게 되면 살수가 나올 가능성이 큽니다.\n위 예제 같은 경우 try 블록과 finally 블록 모두에서 발생할 수 있는데, 예컨데 기기에 물리적 문제가 생긴다면 firstLineOfFile 메서드 안의 readLine 메서드가 예외를 던지고, 같은 이유로 close 메서드도 실패합니다. 이런 상황이라면 두 번째 예외가 첫 번째 예외를 완전히 집어삼키게 됩니다. (첫 번째 예외는 정보가 남지 않게 됩니다.)\n이러한 문제점들을 고안해서 JAVA 7부터는 try-with-resources으로 해결할 수 있습니다. 이 구조를 사용하려면 해당 자원이 AutoCloseable 인터페이스를 구현해야 합니다.\n자바 라이브러리와 서드파티 라이브러리들의 수많은 클래스와 인터페이스가 이미 Autocloseable을 구현하거나 확정했습니다.\ntry-with-resources를 사용한 코드\n1 2 3 4 5  static String firstLineOfFile(String path) throws IOException { try (BufferedReader br = new BufferedReader(new FileReader(path))) { return br.readLine(); } }   try-with-resources에서도 catch 절을 사용할 수 있습니다.\n1 2 3 4 5 6 7  static String firstLineOfFile(String path) { try (BufferedReader br = new BufferedReader(new FileReader(path))) { return br.readLine(); } catch (IOException e) { return defaultVal; } }   ","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-01/item9/","summary":"[아이템 9] try-finally보다는 try-with-resources를 사용하라 자바 라이브러리에는 InputStream, OutputStream, java.sql.Connection과 같이 직접 close를 해야 하는 자원들 있습니다. 클라이언트는 실수로 자원을 닫아주지 않는 경우 예상치 못한 성능 문제로 이어질 수 있습니다.\n1 2 3 4 5 6 7 8 9  static String firstLineOfFile(String path) throws IOException { BufferedReader br = new BufferedReader(new FileReader(path)); try { return br.readLine(); } finally { br.close(); } } }   나쁘진 않지만 자원을 더 사용하게 되면 살수가 나올 가능성이 큽니다.","title":"[아이템 9] try-finally보다는 try-with-resources를 사용하라"},{"content":"[아이템 8] finalizer와 cleaner 사용을 피하라 자바에서는 두 가지 객체 소멸자를 제공합니다. 바로 finalizer와 cleaner입니다. finalizer는 예측 불가능하며 일반적으로 불필요하며 오작동 낮은 성능과 같은 문제점들이 있습니다. 자바 9부터는 사용 자제(deprecated) API로 지정했습니다.\ncleaner는 finalizer보다 덜 위험하지만 이 역시 예측 불가능하고, 느리고 일반적으로 불필요합니다.\n단점 언제 실행되는지 알 수가 없다 finalizer와 cleaner는 즉시 실행된다는 보장이 없습니다. 즉 제때 실행되어야 하는 작업을 절대 할 수 없다는 뜻입니다.\nfinalizer는 굉장히 lazy 합니다 여기서 lazy하다는 뜻은 인스턴스의 자원 회수가 멋대로 지연될 수 있다는 뜻입니다. finalizer 쓰레드는 우선 순위가 낮아서 실행될 기회를 제대로 얻지 못하는 경우들도 생깁니다.\n수행 여부가 보장되지 않습니다 자바 언어 명세는 finalizer와 cleaner의 수행 시점과 수행 여부조차 보장하지 않습니다.\n따라서 상태를 수정하는 작업에는 절대 finalizer나 cleaner에 의존해서는 안 됩니다.\n예외가 무시됩니다. finalizer가 동작하면서 발생한 예외는 무시되며 처리할 작업이 남아있더라도 그 순간 종료됩니다. finalzer같은 경우 예외가 발생해도 추적을 할 수 없으며 이는 디버깅하는데 큰 문제가 됩니다.\n성능상 이슈 Autocloseable 객체를 만들고 가비지 컬렉터가 수거하기 전까지 12ns가 걸린 반면, finalizer를 사용하면 550ns가 소요 됐습니다. finalizer가 가비지 컬렉터의 효율을 떨어뜨리기 때문입니다.\n뿐만 아니라 다양한 이슈들로 인해 finalizer와 cleaner의 사용을 추천하고 있지 않습니다.\n","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-01/item8/","summary":"[아이템 8] finalizer와 cleaner 사용을 피하라 자바에서는 두 가지 객체 소멸자를 제공합니다. 바로 finalizer와 cleaner입니다. finalizer는 예측 불가능하며 일반적으로 불필요하며 오작동 낮은 성능과 같은 문제점들이 있습니다. 자바 9부터는 사용 자제(deprecated) API로 지정했습니다.\ncleaner는 finalizer보다 덜 위험하지만 이 역시 예측 불가능하고, 느리고 일반적으로 불필요합니다.\n단점 언제 실행되는지 알 수가 없다 finalizer와 cleaner는 즉시 실행된다는 보장이 없습니다. 즉 제때 실행되어야 하는 작업을 절대 할 수 없다는 뜻입니다.\nfinalizer는 굉장히 lazy 합니다 여기서 lazy하다는 뜻은 인스턴스의 자원 회수가 멋대로 지연될 수 있다는 뜻입니다.","title":"[아이템 8] finalizer와 cleaner 사용을 피하라"},{"content":"[아이템 7] 다 쓴 객체 참조를 해제하라 메모리 누수가 일어나는 예제 코드\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  public class Stack { private Object[] elements; private int size = 0; private static final int DEFAULT_INITIAL_CAPACITY = 16; public Stack() { elements = new Object[DEFAULT_INITIAL_CAPACITY]; } public void push(Object e) { ensureCapacity(); elements[size++] = e; } public Object pop() { if (size == 0) throw new EmptyStackException(); return elements[--size]; // 주의  } private void ensureCapacity() { if (elements.length == size) elements = Arrays.copyOf(elements, 2 * size); } }   스택에서 데이터를 pop을 실행해도 메모리는 줄어들지 않습니다. 왜냐면 size를 감소 시키지만 배열에서 여전히\u001d 레퍼런스는 그대로 갖고있기 때문입니다.\n다음과 같이 코드를 수정할 수 있습니다.\n1 2 3 4 5 6 7 8 9  public Object pop() { if (size == 0) { throw new EmptyStackException(); } Object value = this.elements[--size]; this.elements[size] = null; return value; }   size를 감소시킬 뿐만 아니라 실제로 해당 참조를 null로 처리한 방법입니다.\n하지만 객체 처리를 null로 처리하는 건 예외적인 경우여야 합니다. 다 쓴 참조를 해제하는 가장 좋은 방법은 다 쓴 참조를 담은 변수를 특정한 스코프 안에서만 사용하는 것입니다.\n캐시를 사용할 때도 메모리 누수에 유의해야 합니다.\n 외부에서 키를 참조하는 동안만 엔트리가 살아있는 캐시가 필요하다면 WeakHashMap을 사용합니다. 시간이 지날 수록 엔티리의 가치를 떨어뜨리는 방식.  ","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-01/item7/","summary":"[아이템 7] 다 쓴 객체 참조를 해제하라 메모리 누수가 일어나는 예제 코드\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  public class Stack { private Object[] elements; private int size = 0; private static final int DEFAULT_INITIAL_CAPACITY = 16; public Stack() { elements = new Object[DEFAULT_INITIAL_CAPACITY]; } public void push(Object e) { ensureCapacity(); elements[size++] = e; } public Object pop() { if (size == 0) throw new EmptyStackException(); return elements[--size]; // 주의  } private void ensureCapacity() { if (elements.","title":"[아이템 7] 다 쓴 객체 참조를 해제하라"},{"content":"[아이템 6] 불피요한 객체를 생성을 피하라 기능이 똑같은 객체를 매번 생성하기 보다는 객체를 재사용하는 것이 적절합니다. 특히 불변 객체는 항상 재사용할 수 있습니다.\n문자열 생성 방법 객체 생성 방식 - 피해야되는 예시 1  String str = new String(\u0026#34;hello\u0026#34;);   이 방식을 이용하면 똑같은 문자열을 생성하더라도 항상 새로운 객체를 생성하므로 낭비가 됩니다.\n리터럴 방식 1  String str = \u0026#34;hello\u0026#34;;   리터럴 방식을 사용하면 JVM에서 동일한 문자열이 존재한다면 그 리터럴을 재사용합니다.\n생성 비용이 비싼 객체 생성 비용이 비싼 객체들 같은 경우 캐싱해서 재사용할 수 있는 방법을 고려해보는 게 좋습니다.\n불필요한 객체 생성 1 1 2 3 4  static boolean isRomanNumeral(String s) { return s.matches(\u0026#34;^(?=.)M*(C[MD]|D?C{0,3})\u0026#34; + \u0026#34;(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$\u0026#34;); }   정규표현식의 예제로 문자열이 로마 숫자인지 확인하는 코드입니다.\nString.matches는 내부에서 만드는 Pattern객체를 만들어서 사용하는데, 이 메서드에서는 한 번 쓰고 버려져서 곧바로 가비지 컬렉션 대상이 됩니다. 입력받은 정규표현식에 해당하는 유한 상태 머신을 만들기 때문에 생성 비용이 비쌉니다.\n해결책 1 2 3 4 5 6 7 8 9  public class RomanNumber { private static final Pattern ROMAN = Pattern.compile(\u0026#34;^(?=.)M*(C[MD]|D?C{0,3})(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$\u0026#34;); static boolean isRomanNumeral(String s) { return ROMAN.matcher(s).matches(); } }   성능을 개선한 코드 수정입니다.Pattern인스턴스 클래스 초기화 과정에서 직접 생성하고 캐싱해두었다가 해당 isRomanNumeral가 호출될 때마다 인스턴스를 재사용합니다. isRomanNumeral가 여러변 호출되는 상황에서 성능을 상당히 끌어올릴 수 있습니다.\n어댑터 어댑터는 인터페이스를 통해서 다른 객체의 연결해주는 객체라 여러개 만들 필요가 없습니다.\n대표적으로 Map 인터페이스에 있는 keySet 메서드는 호출 될 때마다 새로운 객체가 나오는 게 아니라 같은 객체를 반환하기 때문에 리턴받은 Set 타입의 객체를 변경하면, 결국 그 뒤에 있는 Map 인터페이스도 변경되는 것입니다.\n","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-01/item6/","summary":"[아이템 6] 불피요한 객체를 생성을 피하라 기능이 똑같은 객체를 매번 생성하기 보다는 객체를 재사용하는 것이 적절합니다. 특히 불변 객체는 항상 재사용할 수 있습니다.\n문자열 생성 방법 객체 생성 방식 - 피해야되는 예시 1  String str = new String(\u0026#34;hello\u0026#34;);   이 방식을 이용하면 똑같은 문자열을 생성하더라도 항상 새로운 객체를 생성하므로 낭비가 됩니다.\n리터럴 방식 1  String str = \u0026#34;hello\u0026#34;;   리터럴 방식을 사용하면 JVM에서 동일한 문자열이 존재한다면 그 리터럴을 재사용합니다.","title":"[아이템 6] 불피요한 객체를 생성을 피하라"},{"content":"[아이템 5] 자원을 직접 명시하지 말고 의존객체를 주입을 사용하여라. 대부분의 클래스는 하나 이상의 리소스에 의존합니다. 이번 예제에서는 SpellChecker가 Lexicon를 의존하고 있는 모습입니다.\n부적절한 구현 정적 유틸리티를 잘못 사용한 예 - 유연하지 않고 테스트 할 수 없다 1 2 3 4 5 6 7 8 9  public class SpellChecker { private static final Lexicon dictionary = ...; private SpellChecker() { } public static boolean isValid(String word) { ... } public static List\u0026lt;String\u0026gt; suggestions(String typo) { } }   싱글턴을 잘못 사용한 예 - 유연하지 않고 테스트하기 어렵다 1 2 3 4 5 6 7 8 9 10  public class SpellChecker { private final Lexicon dictionary = ...; private SpellChecker() { } public static SpellChecker INSTANCE = new SpellChecker(); public static boolean isValid(String word) { ... } public static List\u0026lt;String\u0026gt; suggestions(String typo) { ... } }   여기서 말하는 유연함이란 구현체를 변경하는 용이성을 말합니다.\n사용하는 리소스에 따라 행동을 다르게 해야하는 클래스는 위에 말한 두 방식을 사용하는 것은 부적절합니다. 이러한 불편 사항들을 해결하기 위해서는 인스턴스를 생성할 때 생성자에 자원을 넘겨주는 방식이 있습니다.\n적절한 구현 의존 객체 주입은 유연성과 테스트 용이성을 높입니다. 1 2 3 4 5 6 7 8 9 10 11 12  public class SpellChecker { private final Lexicon dictionary; public SpellChecker(Lexicon dictionary) { this.dictionary = dictionary; } public static boolean isValid(String word) { ... } public static List\u0026lt;String\u0026gt; suggestions(String typo) { } }   흔히 생성자 주입 방식이라고 부르고 이러한 방식은 불변을 보장하며 원하면 하위 타입 인스턴스의 다양한 구현체를 주입할 수 있습니다.\n위와 같이 의존성을 주입하는 방식은 유연함과 테스트 용이함을 크게 향상시켜 주지만, 의존성이 많아질 경우 코드가 장황해질 수 있습니다.\n하지만 이 점은 스프링 같은 프레임워크로 해결할 수 있습니다. 요약하자면 의존하는 리소스에 따라 행동을 달리하는 클레스를 사용할 때는 싱글턴이나 스태틱 유틸클래스를 사용하지말고\n리소스를 생성자를 통해 의존성을 주입받는 걸 추천합니다.\n","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-01/item5/","summary":"[아이템 5] 자원을 직접 명시하지 말고 의존객체를 주입을 사용하여라. 대부분의 클래스는 하나 이상의 리소스에 의존합니다. 이번 예제에서는 SpellChecker가 Lexicon를 의존하고 있는 모습입니다.\n부적절한 구현 정적 유틸리티를 잘못 사용한 예 - 유연하지 않고 테스트 할 수 없다 1 2 3 4 5 6 7 8 9  public class SpellChecker { private static final Lexicon dictionary = ...; private SpellChecker() { } public static boolean isValid(String word) { ... } public static List\u0026lt;String\u0026gt; suggestions(String typo) { } }   싱글턴을 잘못 사용한 예 - 유연하지 않고 테스트하기 어렵다 1 2 3 4 5 6 7 8 9 10  public class SpellChecker { private final Lexicon dictionary = .","title":"[아이템 5] 자원을 직접 명시하지 말고 의존객체를 주입을 사용하여라"},{"content":"[아이템 4] 인스턴스를 막으려거든 private 생성자를 사용하라 java.lang.Math와 java.util.Arrays와 같이 static 메서드와 static 필드만을 담을 클래스는 인스턴스화를 하는 건 낭비가 됩니다.\n매개변수 없는 생성자를 만들지 않으면 기본생성자가 생성이 되는데 이것을 방치하면 클라이언트 입장에서는 정적 멤버만 담은 유틸리티 클래스인지 알 수 없으므로 인스턴스화를 시킬 가능성이 있습니다. 이를 방지하기 위해 private 생성자를 만들어서 인스턴스화를 막을 수 있습니다.\n1 2 3 4 5  public class UtilityClass { private UtilityClass() { } }   private 생성자이므로 상속을 시도하려는 클래스에서는 생성자를 호출할 수 없기 때문에 상속도 불가능 합니다.\n","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-01/item4/","summary":"[아이템 4] 인스턴스를 막으려거든 private 생성자를 사용하라 java.lang.Math와 java.util.Arrays와 같이 static 메서드와 static 필드만을 담을 클래스는 인스턴스화를 하는 건 낭비가 됩니다.\n매개변수 없는 생성자를 만들지 않으면 기본생성자가 생성이 되는데 이것을 방치하면 클라이언트 입장에서는 정적 멤버만 담은 유틸리티 클래스인지 알 수 없으므로 인스턴스화를 시킬 가능성이 있습니다. 이를 방지하기 위해 private 생성자를 만들어서 인스턴스화를 막을 수 있습니다.\n1 2 3 4 5  public class UtilityClass { private UtilityClass() { } }   private 생성자이므로 상속을 시도하려는 클래스에서는 생성자를 호출할 수 없기 때문에 상속도 불가능 합니다.","title":"[아이템 4] 인스턴스를 막으려거든 private 생성자를 사용하라"},{"content":"[아이템 3] private 생성자나 열거 타입으로 싱글턴임을 보증하라 싱글턴(singletone)이란 인스턴스를 오직 하나만 생성할 수 있는 클래스를 말합니다. 즉 객체를 호출할 때마다 new해서 새로 생성하지 않고 하나의 인스턴스를 계속 사용하는 것입니다.\n싱글턴을 만드는 방식은 보통 둘 중 하나입니다.\npublic static 멤버가 final인 방식 1 2 3 4 5 6 7 8 9  public class Elvis { public static final Elvis INSTANCE = new Elvis(); private void Elvis() { ... } private void leaveTheBuilding() { ... } }   public이나 protected 생성자가 없으므로 Elvis 클래스가 초기화 될 때 만들어진 인스턴스는 하나 뿐입니다. 단 권한이 있는 클라이언트는 리플렉션 API인 AccessibleObject.setAccessible을 사용해 private 생성자를 호출할 수 있습니다. public 필드 방식의 첫번째 장점은 해당 클래스가 싱글턴임이 API에 명백히 드러나는 것입니다.\n두 번째 장점은 간결하다는 것입니다.\n이 점은 생성자를 수정하여 두 번째 객체가 생성되려고 하면 예외를 단지면 됩니다.\n싱글턴을 만드는 두 번째 방법에는 정적 팩토리 메서드를 public static 멤버로 제공합니다.\n정적 팩토리 방식의 싱글톤 1 2 3 4 5 6 7 8 9 10 11  public class Elvis { private static final Elvis INSTANCE = new Elvis(); private void Elvis() { ... } public static Elvis getInstance() { return INSTANCE; } private void leaveTheBuilding() { ... } }   이 역시 리플렉션을 통한 예외는 똑같이 적용됩니다.\n장점\n API를 바꾸지 않고 싱글턴이 아니게 변경할 수 있습니다. 유일한 인스턴스를 반환하던 팩터리 메서드가 호출하는 스레드별로 다른 인스턴스를 넘겨주게 할 수 있습니다. 정적 팩토리 메서드 참조를 공급자(supplier)로 사용할 수 있습니다.  위에서 살펴본 두 방법 모두 직렬화하려면 모든 인스턴스 필드를 일시적(transient)이라고 선언하고 readResolve 메서드를 다음과 같이 제공해야 합니다.\n1 2 3  private Object readResolve() { returm INSTANCE; }   이렇게 하지 않으면 역직렬화 할때마다 새로운 인스턴스가 생성됩니다.\n열거 타입의 방식의 싱글턴 1 2 3 4 5  public enum Elvis { INSTANCEl public void leaveTheBuilding() { ... } }   직렬화 상황 그리고 리플렉션 공격에서도 싱글턴임을 보장할 수 있습니다. 대부분 상황에서는 원소가 하나뿐인 열거 타입이 싱글턴을 만드는 가장 좋은 방법입니다.\n하지만 이 방법은 Enum 외의 클래스를 상속해야한다면 사용할 수 없습니다.(인터페이스를 구현할 수는 있습니다)\n","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-01/item3/","summary":"[아이템 3] private 생성자나 열거 타입으로 싱글턴임을 보증하라 싱글턴(singletone)이란 인스턴스를 오직 하나만 생성할 수 있는 클래스를 말합니다. 즉 객체를 호출할 때마다 new해서 새로 생성하지 않고 하나의 인스턴스를 계속 사용하는 것입니다.\n싱글턴을 만드는 방식은 보통 둘 중 하나입니다.\npublic static 멤버가 final인 방식 1 2 3 4 5 6 7 8 9  public class Elvis { public static final Elvis INSTANCE = new Elvis(); private void Elvis() { ... } private void leaveTheBuilding() { .","title":"[아이템 3] private 생성자나 열거 타입으로  싱글턴임을 보증하라"},{"content":"[아이템 2] 생성자에 매개변수가 많다면 빌더를 고려해라. 매개변수가 많아질 경우 정적 팩토리 메서드와 생성자는 사용하기 불편해집니다.\n첫번째 대안: 생성자를 이용할 경우 1  Nutritionfact cocaCola = new Nutritionfact(240, 8, 100, 0, 35);   이렇게 생성자를 만들 수 있지만 어떤 속성 값을 설정했는지 알기 힘듭니다. 매개변수의 수가 늘어날 수록 코드를 작성하거나 읽기 힘들어집니다. 문제는 매개변수 타입이 같은 상황에서 실수로 순서를 바꿔 입력할 경우 컴파일 시점에서 알 수 없고 런타임에 엉뚱하게 동작하게 됩니다.\n두번째 대안: 자바빈 또 다른 대안으로는 매개변수가 없는 생성자를 만든 뒤 setter를 통해서 값을 설정한는 방법입니다.\n1 2 3 4 5 6  Nutritionfact cocaCola = new Nutritionfact(); cocaCola.setServingSize(240); cocaCola.setServings(8); cocaCola.setCalories(100); .. 반복   생성자를 이용한 방식보다 가독성이 훨씬 올라갔습니다. 하지만 객체가 완전히 생성되기 전까지는 중간에 사용할 수도 있으므로 일관성을 유지할 수 없습니다. 또한 불변 클래스로 만들 수 없다는 단점도 있으며(쓰레드 세이프하지 않습니다) 이를 해결하려면 추가 작업을 해줘야 합니다.\n세번째 대안: 빌더 발더 패턴은 필요한 매개변수만 전달할 수 있고 자바빈즈 패턴의 가독성을 모두 겸비한 대안입니다. 필수 매개변수만으로 생성자(혹은 정적팩토리)를 호출해 빌더 객체를 얻습니다.그 후 빌더 객체가 제공하는 일종의 세터 메서드들로 원하는 선택 매개변수를 설정합니다.\n마지막으로 매개변수가 없는build메서드를 호출하여 객체를 생성합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55  // 예제에서 사용한 Builder패턴  public class NutritionFacts { private final int servingSize; private final int servings; private final int calories; private final int fat; private final int sodium; public static class Builder { // 필수 매개변수  private final int servingSize; private final int servings; // 선택 매개변수 - 기본값으로 초기화 한다.  private int calories = 0; private int fat = 0; private int sodium = 0; public Builder(int servingSize, int servings) { this.servingSize = servingSize; this.servings = servings; } public Builder calories(int val) { calories = val; return this; } public Builder fat(int val) { fat = val; return this; } public Builder carbohydrate(int val) { sodium = val; return this; } public NutritionFacts build() { return new NutritionFacts(this); } } private NutritionFacts(Builder builder) { this.servingSize = builder.servingSize; this.servings = builder.servings; this.calories = builder.calories; this.fat = builder.fat; this.sodium = builder.sodium; } }   1 2 3 4 5  NutritionFacts cocaCola = new NutritionFacts.Builder(240, 8) .calories(100) .sodium(35) .carbohydrate(27) .build();   아까보다 가독성도 좋아지고 NutritionFacts 클래스는 불변이 되었습니다. 추상 클래스는 추상 빌더를 갖게하고 구체 클래스는 구체 빌더를 갖게 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  public abstract class Pizza { public enum Topping { HAM, MUSHROOM, ONION, PEPPER, SAUSAGE } final Set\u0026lt;Topping\u0026gt; toppings; abstract static class Builder\u0026lt;T extends Builder\u0026lt;T\u0026gt;\u0026gt; { EnumSet\u0026lt;Topping\u0026gt; toppings = EnumSet.noneOf(Topping.class); public T addTopping(Topping topping) { toppings.add(Objects.requireNonNull(topping)); return self(); } abstract Pizza build(); // Pizza를 상속한 인스턴스를 반환하기만 하면 된다.  // 하위 클래스는 이 메서드를 재정의 하여 \u0026#34;this\u0026#34;를 반환하도록 해야 한다.  protected abstract T self(); } Pizza(Builder\u0026lt;?\u0026gt; builder) { toppings = builder.toppings.clone(); } }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  public class NyPizza extends Pizza { public enum Size { SMALL, MEDIUM, LARGE } private final Size size; public static class Builder extends Pizza.Builder\u0026lt;Builder\u0026gt; { private final Size size; public Builder(Size size) { this.size = Objects.requireNonNull(size); } @Override Pizza build() { return new NyPizza(this); } @Override protected Builder self() { return this; } } private NyPizza(Builder builder) { super(builder); size = builder.size; }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  public class Calzone extends Pizza { private final boolean sauceInside; public static class Builder extends Pizza.Builder\u0026lt;Builder\u0026gt; { private boolean sauceInside = false; public Builder sauceInde() { sauceInside = true; return this; } @Override public Calzone build() { return new Calzone(this); } @Override protected Builder self() { return this; } } private Calzone(Builder builder) { super(builder); sauceInside = builder.sauceInside; } }   build 메서드는 하위 클래스 어떤 걸 반환해도 상관 없습니다. 하위 메서드가 상위 클래스의 메서드 정의한 반환 타입이 아닌, 그 하위 타입을 반환하는 기능을 공반환 타이핑이라 합니다.\n1 2 3 4 5  Pizza pizza = new Builder(SMALL) .addTopping(SAUSAGE).addTopping(ONION).build(); Calzone calzone = new Calzone.Builder() .addTopping(HAM).sauceInde().build();   빌더는 다양한 방식으로 객체를 생생할 수 있으므로 생성자와 정적 팩토리 메서드 방식보다 상당히 유연합니다.\n단점으로는 객체를 생성하려면 Builder()를 생성해야하는데 성능에 민감한 상황에서는 이 점이 문제가 될 수 있습니다.그리고 생성자에 비해서 코드가 장황에 질 수 있으므로 현재 필요한 매개변수와 확장성을 고려해서 잘 판단하면 될 거 같습니다.\n","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-01/item2/","summary":"[아이템 2] 생성자에 매개변수가 많다면 빌더를 고려해라. 매개변수가 많아질 경우 정적 팩토리 메서드와 생성자는 사용하기 불편해집니다.\n첫번째 대안: 생성자를 이용할 경우 1  Nutritionfact cocaCola = new Nutritionfact(240, 8, 100, 0, 35);   이렇게 생성자를 만들 수 있지만 어떤 속성 값을 설정했는지 알기 힘듭니다. 매개변수의 수가 늘어날 수록 코드를 작성하거나 읽기 힘들어집니다. 문제는 매개변수 타입이 같은 상황에서 실수로 순서를 바꿔 입력할 경우 컴파일 시점에서 알 수 없고 런타임에 엉뚱하게 동작하게 됩니다.","title":"[아이템 2] 생성자에 매개변수가 많다면 빌더를 고려하라"},{"content":"[Iteam 1] 생성자 대신 정적 팩토리 메서드를 고려하라 일반적으로 사용하는 public 생성자 대신, 별도로 정적 팩토리 메소드를 이용할 수 있다. Boolean 클래스에서 발췌한 예제 코드\n1 2 3  public static Boolean valueOf(boolean b) { return b ? Boolean.TRUE : Booelan.FALSE; }   장점 1. 이름을 가질 수 있다. 생성자에 넘기는 매개변수만으로 반활된 객체의 특성을 제대로 설명하지 못합니다.\n반면 정적 팩터리 메서드는 이름을 잘 지으면 반환될 객체의 특성을 쉽게 묘사할 수 있습니다.\n하나의 시그니처로는 생성자를 하나만 만들 수 있으며 입력 매개변수들의 순서를 다르게 한 생성자를 추가하는 식으로 이 제한을 피할 수는 있지만,이 역시 객체의 특성을 살리기 힘들고 좋지 않은 방식입니다.\n정적 팩토리 메소드는 이러한 제약이 없으며 시그니처가 같은 생성자가 여러 개 필요할 거 같으면\n생성자를 정적 팩터리 메서드로 바꾸고 각각의 차이를 잘 드러내는 이름을 지어내는 방법을 사용할 수 있습니다.\n2. 호출될 때마다 인스턴스를 새로 생성하지 않아도 된다. 불변 클래스(immutable class)는 미리 만들어 놓거나 새로 생성한 인스턴스를 캐싱하여 재활용하는 식으로 불필요한 객체 생성을 피할 수 있습니다. 따라서 객체가 자주 요청되는 상황이라면 성능을 상당히 끌어 올릴 수 있습니다. Boolean.valueOf(boolean) 메소드도 그 경우에 해당됩니다.\n3. 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다. 반환할 객체의 클래스를 선택할 수 있는 유연함이 있습니다. 리턴 타입의 하위 타입의 인스턴스를 반환할 수 있으므로 가능합니다. API를 만들때 유연성을 이용하여 구현 클래스를 공개하지 않고도 그 객체를 반환할 수 있어 API를 작게 유지할 수 있습니다. 자바 컬렉션 프레임워크는 핵심 인터페이스들에 수정 불가나 동기화 등의 기능을 덧붙인\n총 45개의 유틸리티구현체를 제공하는데, 이 구현체는 대부분 단 하나의 인스턴스화 불가 클래스인java.util.Collections에서 정적 팩터리 메소드를 통해 얻도록 했습니다. 컬렉션 프레임워크는 이 45개의 클래스를 공개하지 않기 때문에 API의 외견을 훨씬 작게 만들 수 있었습니다.\n여기서 무게는 프로그래머가 API를 사용하기 위해 익혀야하는 개념의 수와 난이도를 맗합니다.\n클라이언트가 구현체가 아닌 인터페이스를 다루게 되므로 역할과 구현이 나눠지므로 결합도가 낮출 수 있습니다.\n4. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다. 장점 3에서 말했듯이 하위 타입이기만 하면 어떤 클래스의 객체를 반환하던 상관 없습니다.\n가령 EumSet 클래스는 public 생성자 없이 오직 정적 펙토리 메서드만 제공합니다. nonOf 등..\nnonOf 메서드를 살펴보면 원소 수에 따라 RegularEnumSet 이나 JumbEnumSet 인스턴스를 반환 합니다.\n1 2 3 4 5 6 7 8 9 10  public static \u0026lt;E extends Enum\u0026lt;E\u0026gt;\u0026gt; EnumSet\u0026lt;E\u0026gt; noneOf(Class\u0026lt;E\u0026gt; elementType) { Enum\u0026lt;?\u0026gt;[] universe = getUniverse(elementType); if (universe == null) throw new ClassCastException(elementType + \u0026#34; not an enum\u0026#34;); if (universe.length \u0026lt;= 64) return new RegularEnumSet\u0026lt;\u0026gt;(elementType, universe); else return new JumboEnumSet\u0026lt;\u0026gt;(elementType, universe); }   5. 정적 팩토리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다. 대표적인 프레워크로는 JDBC가 있습니다. 구현체들은 클라이언트에 제공하는 역할을 프레임워크가 통제하여, 클라이언트를 구현체로부터 분리해줍니다.\n서비스 제공자 프레임워크는 3개의 핵심 컴포넌트로 이루어집니다. (제공자는 서비스의 구현체를 의미합니다)\n 서비스 인터페이스 (구현체의 동작을 정의) 제공자 등록 API (제공자가 구현체를 등록할 때 사용) 서비스 접근 API (클라이언트가 서비스의 인스터스를 얻을 때 사용)  서비스 접근 API를 사용할 때 원하는 구현체의 조건을 명시할 수 있습니다. 조건을 명시하지 않으면 기본 구현체를 반화하거나 지원하는 구현체들을 하나씩 돌아가면서 반환합니다.\n단점 1. 상속을 하려면 public이나 protected 생성자가 필요하니 정적 팩토리 메서드만 제공하면 하위 클래스를 만들 수 없다 이 제약은 상속보다is-a 컴포지션을has-a 사용하도록 유도하고 불변 타입으로 만들려면 이 제약을 지켜야 한다는 점에서 오히려 장점으로 받아들일 수도 있습니다.\n2. 정적 팩토리 메서드는 프로그래머가 찾기 어렵다. 생성자처럼 API설명에 명확히 드러나지 않으므로 사용자는 정적 팩토리 메서드 사용 방식 클래스를 인스턴스화 시킬 방법을 알아내야 합니다. 그러므로 API 문서를 잘 정리하고 메서드 이름도 널리 알려진 규약을 따르는 게 좋습니다.\n","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-01/item1/","summary":"[Iteam 1] 생성자 대신 정적 팩토리 메서드를 고려하라 일반적으로 사용하는 public 생성자 대신, 별도로 정적 팩토리 메소드를 이용할 수 있다. Boolean 클래스에서 발췌한 예제 코드\n1 2 3  public static Boolean valueOf(boolean b) { return b ? Boolean.TRUE : Booelan.FALSE; }   장점 1. 이름을 가질 수 있다. 생성자에 넘기는 매개변수만으로 반활된 객체의 특성을 제대로 설명하지 못합니다.\n반면 정적 팩터리 메서드는 이름을 잘 지으면 반환될 객체의 특성을 쉽게 묘사할 수 있습니다.","title":"[아이템 1] 생성자 대신 정적 팩토리 메서드를 고려하라"},{"content":"[아이템 34] int 상수 대신 열거 타입을 사용하라. 열거 타입이란 일정 개수의 상수 값을 정의하고 그 이외 값들은 허용하지 않는 타입입니다. 대표적으로 사계절, 요일, 태양계의 행성 등이 있습니다.\n열거 타입을 지원하기 전 코드 1 2 3 4 5  // 정수 열거 패턴 - 상당히 취약하다. public static final int EAST = 0; public static final int WEST = 1; public static final int SOUTH = 2; public static final int NORTH = 3;   이 코드는 타입의 안전성을 보장할 수 없고 표현력도 좋지 않습니다. 정수 열거 패턴을 사용한 프로그램은 깨지기가 쉽습니다. 단지 상수를 나열한 것 뿐이라 컴파일하면 그 값이 클라이언트 파일에 그대로 새겨집니다. 따라서 상수의 값이 바뀌면 클라이언트도 수정해줘야 합니다. 정수 상수는 그 값을 출력하거나 디버거로 살펴보면 특별한 의미를 나타내는 것이 아니라 단지 숫자로만 보여서 썩 도움이 되지 않습니다. 정수 대신 문자열 상수를 사용하는 방법도 있지만 이 변형 역시 단점이 많습니다. 상수의 의미를 내포할 수 있지만, 문자열 값 그대로 하드코딩 해야하기 때문에 힘듭니다. 이렇게 힘들게 하드코딩한 문자열이 오타가 있어도 컴파일러는 확인할 수 없습니다.열거 타입 1 2  // 단순한 열거 타입 public enum DIRECTION { EAST, WEST, SOUTH, NORTH }   열거 타입 자체는 클래스이며, 상수 하나당 자신의 인스턴스를 하나씩 만들어 public static final 필드로 공개합니다. 열거 타입은 컴파일 타임 타입 안전성을 제공합니다. DIRECTION 열거 타입을 매개변수로 받는 메서드를 선언 했다면, 건네받은 참조는 null 혹은 DIRECTION의 네 가지 값 중 하나 입니다. 다른 타입의 값을 넘기려 하면 컴파일 오류가 납니다.\n1  DIRECTION south = \u0026#34;Sounth\u0026#34; // 컴파일 오류 !!!   열거타입에 상수를 추가하거나 순서를 변경해도 다시 컴파일 하지 않아도 됩니다. 공개되는 것이 오직 필드의 이름 뿐이라, 정수 열거 패턴과 달리 상수 값이 클라이언트로 컴파일되어 각인되지 않기 때문입니다. 이처럼 열거 타입은 정수 열거 타입의 단점들을 해소해줍니다. 열거 타입에는 메서드나 필드를 추가할 수도 있고 임의의 인터페이스를 구현하게 할 수도 있습니다. Object, Comparable, Serializable을 구현 했으며, 그 직렬화 형태도 웬만큼 변형을 가해도 문제없이 동작하게끔 구현해놨습니다.\n메서드와 필드를 추가한 enum 예제 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  public enum Planet { MERCURY(3.302e+23, 2.439e6), VENUS(4.869e+24, 6.052e6), EARTH(5.975e+24, 6.378e6), MARS(6.419e+23, 3.393e6), JUPITER(1.899e+27, 7.149e7), SATURN(5.685e+26, 6.027e7), URANUS(8.683e+25, 2.556e7), NEPTUNE(1.024e+26, 2.477e7); private final double mass; // 질량(단위: 킬로그램)  private final double radius; // 반지름(단위: 미터)  private final double surfaceGravity; // 표면 중력(단위: m / s^2)  // 중력 상수(단위: m^3 / kg s^2)  private static final double G = 6.67300E-11; // Constructor  Planet(double mass, double radius) { this.mass = mass; this.radius = radius; surfaceGravity = G * mass / (radius * radius); } public double mass() { return mass; } public double radius() { return radius; } public double surfaceGravity() { return surfaceGravity; } public double surfaceWeight(double mass) { return mass * surfaceGravity; // F = ma  } }   열거 타입을 선언한 클래스 혹은 그 패키지에서만 유용한 기능은 private이나 package-private 메서드로 구현하는 게 좋습니다. 일반 클래스와 마찬가지로, 그 기능을 클라이언트에 노출해야 할 합당한 이유가 없다면 private 혹은 package-private으로 선언하라(Item 15)랑 같습니다.\n추천하지 않는 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  public enum Operation { PLUS, MINUS, TIMES, DIVIDE; // 상수가 뜻하는 연산을 수행한다.  public double apply(double x, double y) { switch (this) { case PLUS: return x + y; case MINUS: return x - y; case TIMES: return x * y; case DIVIDE: return x / y; } throw new AssertionError(\u0026#34;알 수 없는 연산: \u0026#34; + this); } }   동작은 하지만 맹점이 있습니다. 예컨대 새로운 상수를 추가하면 해당 case 문도 추가해야 합니다. 열거 타입에 apply를 이용하여 코드를 보완할 수 있습니다.\n상수별 메서드 구현을 활용한 열거 타입 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  // 상수별 메서드 구현 public enum Operation { PLUS { public double apply(double x, double y) { return x + y; } }, MINUS { public double apply(double x, double y) { return x - y; } }, TIMES { public double apply(double x, double y) { return x * y; } }, DIVIDE { public double apply(double x, double y) { return x / y; } }; public abstract double apply(double x, double y); }   보시다시피 apply 메서드가 상수 선언 바로 옆에 붙어 있으니 새로운 상수를 추가할 때 apply도 재정의해야 한다는 사실을 깜빡하기는 어려울 것입니다. 그 뿐만 아니라 apply 메서드가 추상 메서드이므로 재정의 하지 않았다면 컴파일 오류로 알려줍니다. 상수별 메서드 구현을 상수별 데이터와 결합할 수도 있습니다. 예컨대 다음은 Operation의 toString을 재정의해 해당 연산을 뜻하는 기호를 반환하도록 하는 예제 코드입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  public enum Operation { PLUS(\u0026#34;+\u0026#34;) { public double apply(double x, double y) { return x + y; } }, MINUS(\u0026#34;-\u0026#34;) { public double apply(double x, double y) { return x - y; } }, TIMES(\u0026#34;*\u0026#34;) { public double apply(double x, double y) { return x * y; } }, DIVIDE(\u0026#34;/\u0026#34;) { public double apply(double x, double y) { return x / y; } }; private final String symbol; Operation(String symbol) { this.symbol = symbol; } @Override public String toString() { return symbol; } public abstract double apply(double x, double y); }   열거 타입에는 상수 이름을 입력받아 그 이름에 해당하는 상수를 반환하는 valueOf(String) 메서드가 자동 생성됩니다. 상수별 메서드 구현에는 열거 타입 상수끼리 코드를 공유하기 어렵다는 단점이 있습니다. 다음은 급명세서에서 쓸 요일을 표현하는 로직을 포함한 열거 타입 예제입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  // 위험한 코드  enum PayrollDay { MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY(PayType.WEEKEND), SUNDAY(PayType.WEEKEND); private final PayType payType; PayrollDay(PayType payType) { this.payType = payType; } PayrollDay() { this(PayType.WEEKDAY); } // Default  int pay(int minutesWorked, int payRate) { return payType.pay(minutesWorked, payRate); } // The strategy enum type  private enum PayType { WEEKDAY { int overtimePay(int minsWorked, int payRate) { return minsWorked \u0026lt;= MINS_PER_SHIFT ? 0 : (minsWorked - MINS_PER_SHIFT) * payRate / 2; } }, WEEKEND { int overtimePay(int minsWorked, int payRate) { return minsWorked * payRate / 2; } }; abstract int overtimePay(int mins, int payRate); private static final int MINS_PER_SHIFT = 8 * 60; int pay(int minsWorked, int payRate) { int basePay = minsWorked * payRate; return basePay + overtimePay(minsWorked, payRate); } } }   하지만 기존 열거 타입에 상수별 동작을 혼합해 넣을 때는 switch 문이 좋은 선택이 될 수도 있습니다.\n1 2 3 4 5 6 7 8 9 10  // switch문을 이용해 원래 열거 타입에 없는 기능을 수행 public static Operation inverse(Operation op) { switch(op) { case PLUS: return Operation.MINUS; case MINUS: return Operation.PLUS; case TIMES: return Operation.DIVIDE; case DIVIDE: return Operation.TIMES; default: thrownewAssertionError(\u0026#34;알 수 없는 연산: \u0026#34;+op); } }   추가하려는 메서드가 의미상 열거 타입에 속하지 않는다면 이 방식을 적용하는 게 좋습니다. 열거 타입은 메모리에 올라가는 공간과 초기화하는 시간이 좀 들긴 하지만 크게 체감될 정도는 아닙니다.\n","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-05/item34/","summary":"[아이템 34] int 상수 대신 열거 타입을 사용하라. 열거 타입이란 일정 개수의 상수 값을 정의하고 그 이외 값들은 허용하지 않는 타입입니다. 대표적으로 사계절, 요일, 태양계의 행성 등이 있습니다.\n열거 타입을 지원하기 전 코드 1 2 3 4 5  // 정수 열거 패턴 - 상당히 취약하다. public static final int EAST = 0; public static final int WEST = 1; public static final int SOUTH = 2; public static final int NORTH = 3;   이 코드는 타입의 안전성을 보장할 수 없고 표현력도 좋지 않습니다.","title":""},{"content":"[아이템 35] ordinal 메서드 대신 인스턴스 필드를 사용하라 대부분 열거 타입 상수는 자연스럽게 하나의 정숫값에 대응됩니다. 모든 엵 ㅓ타입은 해당 상수가 그 열거 타입에서 몇 번째 위치인지를 반환하는 ordinal 이라는 메서드를 제공합니다.\n1 2 3 4 5 6 7 8 9 10  // ordinal을 잘못 사용한 예 public enum FRUITS { APPLE, BANANA, ORANGE; public int numberOfFruits() { return ordinal() + 1; } }   상수 선언 순서를 바꾸는 순간 numberOfFruits는 오작동하며 이미 사용중인 정수와 값이 같은 상수는 추가할 수 없고 중간에 값을 비울 수도 없습니다.해결책은 매우 간단합니다. ordinal 메서드를 이용하지 않고 인스턴스 필드에 저장하면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13  public enum FRUITS { APPLE(1), BANANA(2), ORANGE(3); private final int numberOfFruits; FRUITS(int size) { this.numberOfFruits = size; } public int getNumberOfFruits() { return numberOfFruits; } }   Enum의 API 문서에는 ordinal에 대해서 \u0026ldquo;대부분 프로그래머는 이 메서드를 쓸 일이 없습니다. 이 메서드는 EnumSet과 EnumMap 같이 열거 타입 기반의 범용 자료구조에 쓸 목적으로 설계되었습니다.\u0026rdquo;\n","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-05/item35/","summary":"[아이템 35] ordinal 메서드 대신 인스턴스 필드를 사용하라 대부분 열거 타입 상수는 자연스럽게 하나의 정숫값에 대응됩니다. 모든 엵 ㅓ타입은 해당 상수가 그 열거 타입에서 몇 번째 위치인지를 반환하는 ordinal 이라는 메서드를 제공합니다.\n1 2 3 4 5 6 7 8 9 10  // ordinal을 잘못 사용한 예 public enum FRUITS { APPLE, BANANA, ORANGE; public int numberOfFruits() { return ordinal() + 1; } }   상수 선언 순서를 바꾸는 순간 numberOfFruits는 오작동하며 이미 사용중인 정수와 값이 같은 상수는 추가할 수 없고 중간에 값을 비울 수도 없습니다.","title":""},{"content":"[아이템 36] 비트 필드 대신 EnumSet을 사용하라. 열거한 값들이 집합으로 사용될 경우, 예전에는 상수에 서로 다른 2의 거듭제곱 값을 할당한 정수 열거 패턴을 사용해왔습니다.\n1 2 3 4 5 6 7 8 9 10  // 비트 필드 열거 상수 - 구닥다리 기법  public class Text { public static final int STYLE_BOLD = 1 \u0026lt;\u0026lt; 0; // 1  public static final int STYLE_ITALIC = 1 \u0026lt;\u0026lt; 1; // 2  public static final int STYLE_UNDERLINE = 1 \u0026lt;\u0026lt; 2; // 4  public static final int STYLE_STRIKETHROUGH = 1 \u0026lt;\u0026lt; 3; // 8  // 매개변수 styles는 0개 이상의 STYLE_ 상수를 비트별 OR한 값입니다.  public void applyStyles(int styles) { ... } }   다음과 같은 식으로 비트별 OR를 사용해 여러 상수를 하나의 집합으로 모을 수 있으며, 이렇게 만들어진 집합을 비트 필드라고 합니다.\n1  text.applyStyles(Text.STYLE_BOLD | Text.STYLE_ITALIC);   비트 필드를 사용하면 비트별 연산을 사용해 집합 연산을 효율적으로 사용할 수 있지만, 정수 열거 상수와 같은 단점을 지니고 있으며 추가로 다음과 같은 단점들이 있습니다.\n 비트 필드 값이 그대로 출력되면 정수 열거 상수를 출력할 때보다 해석하기가 훨씬 어렵습니다. 비트 필드 하나에 녹아 있는 모든 원소를 순회하기도 까다롭습니다. 최대 몇 비트가 필요한지를 API 작성 시 미리 예측하여 적절한 타입을 선택해야 합니다. API를 수정하지 않고는 비트 수를 더 늘릴 수 없기 때문입니다.\nEnumSet을 이용하면 이러한 단점을 보완하여 사용할 수 있습니다. EnumSet의 내부는 비트 벡터로 구현되어있고, 원소가 총 64개 이하라면 EnumSet 전체를 long 변수 하나로 표현하여 비트 필드에 비견되는 성능을 보여줍니다.  1 2 3 4 5 6  public class Text { public enum Style { BOLD, ITALIC, UNDERLINE, STRIKETHROUGH } // 어떤 Set을 넘겨도 됩지만 EnumSet이 가장 좋습니다.  public void applyStyles(Set\u0026lt;Style\u0026gt; styles) { ... } }   EnumSet을 이용한 클라이언트 코드\n1  text.applyStyles(EnumSet.of(Style.BOLD, Style.ITALIC));   정리  열거할 수 있는 타입을 모아 집합 형태로 사용한다고 해도 비트 필드를 사용할 이유는 없습니다. 비트 필드의 단점이 보완되는 EnumSet을 활용합시다.  ","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-05/item36/","summary":"[아이템 36] 비트 필드 대신 EnumSet을 사용하라. 열거한 값들이 집합으로 사용될 경우, 예전에는 상수에 서로 다른 2의 거듭제곱 값을 할당한 정수 열거 패턴을 사용해왔습니다.\n1 2 3 4 5 6 7 8 9 10  // 비트 필드 열거 상수 - 구닥다리 기법  public class Text { public static final int STYLE_BOLD = 1 \u0026lt;\u0026lt; 0; // 1  public static final int STYLE_ITALIC = 1 \u0026lt;\u0026lt; 1; // 2  public static final int STYLE_UNDERLINE = 1 \u0026lt;\u0026lt; 2; // 4  public static final int STYLE_STRIKETHROUGH = 1 \u0026lt;\u0026lt; 3; // 8  // 매개변수 styles는 0개 이상의 STYLE_ 상수를 비트별 OR한 값입니다.","title":""},{"content":"[아이템 37] ordinal 인덱싱 대신 EnumMap을 사용하라. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  public class Plant { enum LifeCycle { ANNUAL, PERENNIAL, BIENNIAL } final String name; final LifeCycle lifeCycle; Plant(String name, LifeCycle lifeCycle) { this.name = name; this.lifeCycle = lifeCycle; } @Override public String toString() { return name; } }   식물을 간단히 나타낸 코드입니다. 이들을 생애주기 별로 묶어봅시다.생애주기별로 총 3개의 집합을 만들고 정원을 한 바퀴 돌며 식물을 해당 집합에 집어넣습니다.\n1 2 3 4 5 6 7  Map\u0026lt;Plant.LifeCycle, Set\u0026lt;Plant\u0026gt;\u0026gt; plantsByLifeCycle = new EnumMap\u0026lt;\u0026gt;(Plant.LifeCycle.class); for (Plant.LifeCycle lc : Plant.LifeCycle.values()) plantsByLifeCycle.put(lc, new HashSet\u0026lt;\u0026gt;()); for (Plant p : garden) plantsByLifeCycle.get(p.lifeCycle).add(p); System.out.println(plantsByLifeCycle);   EnumMap은 열거타입 키를 사용하도록 설계한 아주 빠른 Map 구현체 입니다. EnumMap의 생성자가 받는 키 타입의 Class 객체는 한정적 타입 토큰으로 런타임 제네릭 타입 정보를 제공합니다. 스트림을 사용해 맵을 관리하면 코드를 더 줄일 수 있습니다.\n1 2  System.out.println(Arrays.stream(garden) .collect(groupingBy(p -\u0026gt; p.lifeCycle)));   이 코드는 EnumMap이 아닌 고유한 맵 구현체를 사용했기 때문에 EnumMap을 써서 얻은 공간과 성능 이점이 사라진다는 단점이 있습니다. 좀 더 자세히 살펴보면\n매개변수 3개짜리 Collectors.groupingBy 메서드는 mapFactory 매개변수에 원하는 맵 구현체를 명시해 호출할 수 있습니다.\n1 2 3 4  // EnumMap을 이용해 데이터 열거 타입과 매핑  System.out.println(Arrays.stream(garden) .collect(groupingBy(p -\u0026gt; p.lifeCycle, () -\u0026gt; new EnumMap\u0026lt;\u0026gt;(LifeCycle.class), toSet())));   맵을 빈번히 사용하는 프로그램에는 도움이 될 것입니다.스트림을 사용하면 EnumMap만 사용했을 때와는 다른 점이 있습니다. EnumMap 버전은 언제나 식물의 생애주기당 하나씩의 중첩 맵을 만들지만, 스트림 버전은 해당 생애주기에 속하는 식물이 있을 떄만 만듭니다.\n","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-05/item37/","summary":"[아이템 37] ordinal 인덱싱 대신 EnumMap을 사용하라. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  public class Plant { enum LifeCycle { ANNUAL, PERENNIAL, BIENNIAL } final String name; final LifeCycle lifeCycle; Plant(String name, LifeCycle lifeCycle) { this.name = name; this.lifeCycle = lifeCycle; } @Override public String toString() { return name; } }   식물을 간단히 나타낸 코드입니다. 이들을 생애주기 별로 묶어봅시다.","title":""},{"content":"[아이템 38] 확장할 수 있는 열거 타입이 필요하면 인터페이스를 사용하라. 열거 타입은 확장할 수 없게 설계 되었습니다. 확장한 타입의 원소는 기반 타입의 원소로 취급하지만 그 반대는 성립하지 않는다면 어폐가 있고 기반 타입과 확장된 타입들의 원소를 모두를 순회할 방법도 마땅치 않으며 확장성을 높이려면 고려할 요소가 늘어나 설계와 구현이 더 복잡해지기 때문입니다.\n그러나 연산 코드는 확장할 수 있는 열거 타입과 어울립니다. API가 제공하는 기본 연산 외에 사용자가 확장 연산을 추가할 수 있도록 열어줘야 할 때가 있습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  package com.example.jpatest.t; public interface Operation { double apply(double x, double y); } public enum BasicOperation implements Operation { PLUS(\u0026#34;+\u0026#34;) { public double apply(double x, double y) { return x + y; } }, MINUS(\u0026#34;-\u0026#34;) { public double apply(double x, double y) { return x - y; } }, TIMES(\u0026#34;*\u0026#34;) { public double apply(double x, double y) { return x * y; } }, DIVIDE(\u0026#34;/\u0026#34;) { public double apply(double x, double y) { return x / y; } }; private final String symbol; BasicOperation(String symbol) { this.symbol = symbol; } @Override public String toString() { return symbol; } }   Operation인터페이스를 구현하여 구현체가 다른 열거 타입을 이용할 수 있습니다.\n1 2 3 4 5 6 7 8 9 10  // 구현체를 메서드에 명시해서 사용하는 방식 public static void main(String[] args) { double x = Double.parseDouble(args[0]); double y = Double.parseDouble(args[1]); test(ExtendedOperation.class, x, y); } private static \u0026lt;T extends Enum\u0026lt;T\u0026gt; \u0026amp; Operation\u0026gt; void test( Class\u0026lt;T\u0026gt; opEnumType, double x, double y) { for (Operation op : opEnumType.getEnumConstants()) System.out.printf(\u0026#34;%f %s %f = %f%n\u0026#34;, x, op, y, op.apply(x, y)); }   여기서 class 리터럴은 한정적 타입토큰 역할을 합니다.\n1 2 3 4 5 6 7 8 9 10  // 두 번째 방법 public static void main(String[] args) { double x = Double.parseDouble(args[0]); double y = Double.parseDouble(args[1]); test(Arrays.asList(ExtendedOperation.values()), x, y); } private static void test(Collection\u0026lt;? extends Operation\u0026gt; opSet, double x, double y) { for (Operation op : opSet) System.out.printf(\u0026#34;%f %s %f = %f%n\u0026#34;,x, op, y, op.apply(x, y)); }   여러 구현 타입의 연산을 조합해 호출할 수 있게 되므로 더 유연해졌습니다 하지만 특정 연산에서는 EnumMap과 EnumSet을 사용하지 못합니다.인터페이스를 활용하는 방법에는 사소한 문제가 있습니다. 열거 타입끼리 구현을 상속할 수 없다는 점입니다. 아무 상태에도 의존하지 않는 경우에는 디폴트 구현을 이용해 인터페이스에 추가하는 방방이 있습니다. 하지만 모든 구현체에 공유해야 하므로 공유하는 기능이 많다면 그 부분을 별도의 도우미 클래스나 정적 도우미 메서드로 분리하는 방식으로 코드 중복을 없앨 수 있습니다.\n한 줄 요약: 열거 타입 자체는 확장할 수 없지만 인터페이스와 인터페이스를 구현하는 열거 타입을 함께 사용하면 같은 효과를 낼 수 있습니다.\n","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-05/item38/","summary":"[아이템 38] 확장할 수 있는 열거 타입이 필요하면 인터페이스를 사용하라. 열거 타입은 확장할 수 없게 설계 되었습니다. 확장한 타입의 원소는 기반 타입의 원소로 취급하지만 그 반대는 성립하지 않는다면 어폐가 있고 기반 타입과 확장된 타입들의 원소를 모두를 순회할 방법도 마땅치 않으며 확장성을 높이려면 고려할 요소가 늘어나 설계와 구현이 더 복잡해지기 때문입니다.\n그러나 연산 코드는 확장할 수 있는 열거 타입과 어울립니다. API가 제공하는 기본 연산 외에 사용자가 확장 연산을 추가할 수 있도록 열어줘야 할 때가 있습니다.","title":""},{"content":"[아이템 39] 명명 패턴보다 애너테이션을 사용하라. 명명 패턴의 대표적인 예로 JUnit 3까지는 테스트 메서드 이름을 test로 시작하지 않으면 이 메서드를 그냥 지나쳤서 테스트를 통과했다고 오해하는 경우도 있었습니다.JUnit 4부터는 이러한 문제점을 해결하기 위해 애너테이션을 전면 도입했습니다. 이번 예제에서는 자동으로 수행되는 간단한 테스트용 애너테이션으로, 예외가 발생하면 해당 테스트를 실패로 처리합니다.\n1 2 3 4 5 6 7 8  /** * 테스트 메서드임을 선언하는 애너테이션 * 매개변수 없는 정적 메서드 전용 */ @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.METHOD) public @interface Test { }   @Retention, @Target과 같이 애너테이션 선언에 다는 애너테이션을 메타애너테이션이라 합니다. 쉽게 설명하면 메타 애너테이션은 애너테이션을 위한 애너테이션이라고 생각하시면 됩니다.@Retention은 애너테이션이 유지되는 기간이며 @Retention(RetentionPolicy.RUNTIME)은 런타임까지 존재한다는 뜻입니다.@Target은 적용 대상을 지정할 때 사용하며 @Target(ElementType.METHOD)은 메서드 선언에만 사용할 수 있다는 뜻입니다. 위 코드에서 \u0026ldquo;매개변수 없는 정적 메서드 전용\u0026quot;라고 주석을 작성했는데, 적절한 애너테이션 처리기를 직접 구현하지 않으면 컴파일 오류 없이 잘 작동합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  public class Sample { @Test public static void m1() {} // 성공해야 한다  public static void m2() {} @Test public static void m3() { // 실패해ㅑ 한다  throw new RuntimeException(\u0026#34;Boom\u0026#34;); } public static void m4() {} @Test public void m5() {} // 잘못 사용: 정적 메서드가 아님  @Test public static void m7() { // 실패해야 한다  throw new RuntimeException(\u0026#34;Crash\u0026#34;); } public static void m8() {} }   @Test 애너테이션은 Sample클래스에 직접적인 영향을 주지 않습니다. 그저 이 애너테이션에 관심 있는 프로그램에게 추가 정보를 제공할 뿐입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  // 마커 애너테이션을 처리하는 코드 public class RunTest { public static void main(String[] args) throws Exception { int tests = 0; int passed = 0; Class\u0026lt;?\u0026gt; testClass = Class.forName(args[0]); for (Method m : testClass.getDeclaredMethods()) { if (m.isAnnotationPresent(Test.class)) { tests++; try { m.invoke(null); passed++; } catch (InvocationTargetException wrappedExc) { Throwable exc = wrappedExc.getCause(); System.out.println(m + \u0026#34; failed: \u0026#34; + exc); } catch (Exception exc) { System.out.println(\u0026#34;Invalid @Test: \u0026#34; + m); } } } System.out.printf(\u0026#34;Passed: %d, Failed: %d%n\u0026#34;, passed, tests - passed); } }   @Test 애너테이션이 달린 메서드를 차례로 호출합니다. isAnnotationPresent메서드가 실행할 메서드를 찾아줍니다. InvocationTargetException외의 예외가 발생한다면 @Test 애너테이션을 잘못 사용했다는 뜻입니다.인스턴스 메서드, 매개변수가 있는 메서드, 호출할 수 없는 메서드 등에 사용했다는 뜻입니다. 이번에는 특정 예외를 던져야만 성공하는 테스트를 지원하도록 해봅시다.\n1 2 3 4 5 6 7 8  /** * 명시한 예외를 던져야면 성공하는 테스트 메서드용 에너테이 */ @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.METHOD) public @interface ExceptionTest { Class\u0026lt;? extends Throwable\u0026gt; value(); }   Throwable을 확장한 클래스의 Class 객체라는 뜻이며, 따라서 모든 예외,오류 타입을 수용합니다. 이는 한정적 타입 토큰을 활용한 사례입니다. 다음은 이 애너테이션을 실제 활용한 모습입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  public class Sample2 { @ExceptionTest(ArithmeticException.class) public static void m1() { int i = 0 / 0; } @ExceptionTest(ArithmeticException.class) public static void m2() { int[] a = new int[0]; // 실패해야 한다. (다른 예외 발생)  int i = a[1]; } @ExceptionTest(ArithmeticException.class) public static void m3() { } // 실패해야 한다. (예외 발생 x) }   이제 이 애너테이션을 다룰 수 있는 코드를 작성해봅시다. (앞서 작성한 코드의 일부분을 수정했습니다)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  if (m.isAnnotationPresent(ExceptionTest.class)) { tests++; try { m.invoke(null); System.out.printf(\u0026#34;테스트 %s 실패: 예외를 던지지 않음%n\u0026#34;, m); } catch (InvocationTargetException wrappedEx) { Throwable exc = wrappedEx.getCause(); Class\u0026lt;? extends Throwable\u0026gt; excType = m.getAnnotation(ExceptionTest.class).value(); if (excType.isInstance(exc)) { passed++; } else { System.out.printf( \u0026#34;테스트 %s 실패: 기대한 예외 %s, 발생한 예외 %s%n\u0026#34;, m, excType.getName(), exc); } } catch (Exception exc) { System.out.println(\u0026#34;잘못 사용한 @ExceptionTest: \u0026#34; + m); } }   문제 없이 컴파일이 되면애너테이션 매개변수가 가리키는 예외가 올바르단 뜻입니다. 예외를 하나가 아닌 여러개를 명시하고 그 중 하나가 발생하면 성공하게 만들 수도 있습니다.\n1 2 3 4 5  @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.METHOD) public @interface ExceptionTest { Class\u0026lt;? extends Throwable\u0026gt;[] value(); }   1 2 3 4 5  @ExceptionTest({ IndexOutOfBoundsException.class, NullPointerException.class }) public static void doSomething() { ... }   다음은 클라이언트 코드를 수정한 모습입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  if (m.isAnnotationPresent(ExceptionTest.class)) { tests++; try { m.invoke(null); System.out.printf(\u0026#34;테스트 %s 실패: 예외를 던지지 않음%n\u0026#34;, m); } catch (Throwable wrappedExc) { Throwable exc = wrappedExc.getCause(); int oldPassed = passed; Class\u0026lt;? extends Throwable\u0026gt;[] excTypes = m.getAnnotation(ExceptionTest.class).value(); for (Class\u0026lt;? extends Throwable\u0026gt; excType : excTypes) { if (excType.isInstance(exc)) { passed++; break; } } if (passed == oldPassed) { System.out.printf(\u0026#34;테스트 %s 실패: %s %n\u0026#34;, m, exc); } } }   자바 8에서는 여러 개의 값을 받는 애너테이션을 다른 방식으로 만들 수 있습니다. 배열 매개변수를 사용하는 대신 애너테이션에 @Repeatabl 메타 애너테이션을 다는 방식입니다.@Repeatabl를 사용 할 때 주의사항이 있습니다. @Repeatable을 단 애너테이션을 반환하는 \u0026lsquo;컨테이너 애너테이션\u0026rsquo;을 하나 더 정의하고, @Repeatable에 컨테이너 애너테이션에 class객체를 매개변수로 전달해야 합니다. 또 컨테이션 애너테이션은 내부 애너테이션 타입의 배열을 반환하는 value 메서드를 정의해아 합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.METHOD) @Repeatable(ExceptionTestContainer.class) public @interface ExceptionTest { Class\u0026lt;? extends Throwable\u0026gt; value(); } // 컨테이너 애너테이션 @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.METHOD) public @interface ExceptionTestContainer { ExceptionTest[] value(); } @ExceptionTest(IndexOutOfBoundsException.class) @ExceptionTest(NullPointerException.class) public static void doSomething() { ... }   다음은 RunTests 프로그램이 @ExceptionTest의 반복 가능 버전을 사용하도록 수정한 코드입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  if (m.isAnnotationPresent(ExceptionTest.class) || m.isAnnotationPresent(ExceptionTestContainer.class)) { tests++; try { m.invoke(null); System.out.printf(\u0026#34;Test %s failed: no exception%n\u0026#34;, m); } catch (Throwable wrappedExc) { Throwable exc = wrappedExc.getCause(); int oldPassed = passed; ExceptionTest[] excTests = m.getAnnotationsByType(ExceptionTest.class); for (ExceptionTest excTest : excTests) { if (excTest.value().isInstance(exc)) { passed++; break; } } if (passed == oldPassed) { System.out.printf(\u0026#34;Test %s failed: %s %n\u0026#34;, m, exc); } }   이번 Test예제에서는 애노테이션으로 할 수 있는 일들 중 극히 일부 입니다. 하지만 일반적으로 프로그래머가 애너테이션을 직접 정의할 일은 드뭅니다. 하지만 자바 프로그래머라면 자바가 제공하는 애너테이션 타입들은 사용할 줄 알아야합니다.\n","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-05/item39/","summary":"[아이템 39] 명명 패턴보다 애너테이션을 사용하라. 명명 패턴의 대표적인 예로 JUnit 3까지는 테스트 메서드 이름을 test로 시작하지 않으면 이 메서드를 그냥 지나쳤서 테스트를 통과했다고 오해하는 경우도 있었습니다.JUnit 4부터는 이러한 문제점을 해결하기 위해 애너테이션을 전면 도입했습니다. 이번 예제에서는 자동으로 수행되는 간단한 테스트용 애너테이션으로, 예외가 발생하면 해당 테스트를 실패로 처리합니다.\n1 2 3 4 5 6 7 8  /** * 테스트 메서드임을 선언하는 애너테이션 * 매개변수 없는 정적 메서드 전용 */ @Retention(RetentionPolicy.","title":""},{"content":"[아이템 40] @Override 애너테이션을 일관되게 사용하여라. @Override애너테이션은 상위 타입 메서드를 재정의 했다는 뜻으로 메서드 선언에 달 수 있습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  // 버그를 찾아보자  public class Bigram { private final char first; private final char second; public Bigram(char first, char second) { this.first = first; this.second = second; } public boolean equals(Bigram b) { return b.first == first \u0026amp;\u0026amp; b.second == second; } public int hashCode() { return 31 * first + second; } public static void main(String[] args) { Set\u0026lt;Bigram\u0026gt; s = new HashSet\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; 10; i++) { for (char ch = \u0026#39;a\u0026#39;; ch \u0026lt;= \u0026#39;z\u0026#39;; ch++) { s.add(new Bigram(ch, ch)); } } System.out.println(s.size()); } }   Set은 중복이 허용되지 않아서 26을 출력할 거 같지만 실제로 260이 출력됐습니다. 어디가 잘못 됐을까요?\n정답은 equals를 \u0026lsquo;재정의\u0026rsquo; 한 게 아니라 \u0026lsquo;다중정의\u0026rsquo;를 해서 그렇습니다. Object의 equals를 재정의 하려면 매개변수 타입을 Object로 해야하는데 다른 타입을 지정해서 새로운 equals를 만들게 된 것입니다. 따라서 Hash를 사용할 때 원하는 데로 결과값을 도출할 수 없었던 것입니다.\n1 2 3 4  @Override public boolean equals(Bigram b) { return b.first == first \u0026amp;\u0026amp; b.second == second; }   이런식으로 애너테이션을 달면 컴파일 오류가 발생하므로 쉽게 오류를 수정할 수 있습니다. 그러니 상위 클래스의 메서드를 재정의할 때는 @Override 애너테이션을 달도록 합시다. 예외적으로 구체 클래스에서 상위 클래스의 추상 메서드를 재정의 할 때는 굳이 사용하지 않아도 되긴 합니다. 구체 클래스인데 아직 구현하지 않은 추상 메서드가 남아 있다면 컴파일러가 알려주기 떄문입니다. 그래도 일관성과 가시성을 위해 달아주는 게 좋습니다.\n","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-05/item40/","summary":"[아이템 40] @Override 애너테이션을 일관되게 사용하여라. @Override애너테이션은 상위 타입 메서드를 재정의 했다는 뜻으로 메서드 선언에 달 수 있습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  // 버그를 찾아보자  public class Bigram { private final char first; private final char second; public Bigram(char first, char second) { this.","title":""},{"content":"[아이템 41] 정의하려는 것이 타입이라면 마커 인터페이스를 사용하라. 마커 인터페이스란 메서드 선언을 포함하지 않고, 단지 구현하는 클래스\u0008의 특정 속성을 표시해주는 것입니다. 대표적으로 Serializable인터페이스가 있습니다.마커 애너테이션이 등장하면서 마커 인터페이스가 구식이 되었다는 얘기가 있는데, 이는 사실이 아닙니다. 마커 인터페이스는 마커 애너테이션 보다 좋은 점도 있습니다.첫 째로 마커 인터페이스는 이를 구현한 클래스의 인스턴스들을 구분하는 타입을 쓸 수 있지만, 마커 애너테이션은 그렇지 않습니다. 마커 인터페이스는 타입이고 마커 애너테이션을 사용하면 런타임에야 발견할 수 있습니다.자바의 직렬화는 Serializable 마커 인터페이스를 보고 그 대상이 직렬화를 할 수 있는 타입인지 확인합니다. 예를들어 ObjectOutputStream.writeObject 메서드는 당연히 인수로 받은 객체가 Serializable를 구현 했을 거라고 가정합니다. 하지만 이 메서드는 Object 객체를 받도록 설계되어서 직렬화할 수 없는 객체를 넘겨도 런타임에야 확인할 수 있습니다. 이는 마커 인터페이스의 이점을 살리지 못한 것입니다.\n두 번째는 적용 대상을 더 정밀하게 지정할 수 있다는 것입니다. 특정 인터페이스를 구현한 클래스에만 적용하고 싶으먼 그 클래스에 마커 인터페이스를 구현하기만 하면 됩니다.반대로 마커 애너테이션이 마커 인터페이스보다 좋은 점은 거대한 애너테이션 시스템의 지원을 받을 수 있다는 점입니다. 둘 중 어느것을 사용해야될지 모르는 경우 확실한 건 클래스와 인터페이스 외의 프로그램요소(모듈, 패키지, 필드 등)에 마킹해야 되는 경우 애너테이션을 사용할 수 밖에 없습니다. 마커 인터페이스를 적용해야 한다면 \u0026ldquo;마킹이 된 객체를 매개변수로 받는 메서드를 작성할 일이 있을까?\u0026ldquo;라고 자문해보는 게 좋습니다. 만약 그렇다라고 결론이 날 경우 마커 인터페이스를 사용하고 그렇지 않으면 마커 애너테이션을 사용하는 것이 더 나은 선택이 될 것입니다.\n","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-05/item41/","summary":"[아이템 41] 정의하려는 것이 타입이라면 마커 인터페이스를 사용하라. 마커 인터페이스란 메서드 선언을 포함하지 않고, 단지 구현하는 클래스\u0008의 특정 속성을 표시해주는 것입니다. 대표적으로 Serializable인터페이스가 있습니다.마커 애너테이션이 등장하면서 마커 인터페이스가 구식이 되었다는 얘기가 있는데, 이는 사실이 아닙니다. 마커 인터페이스는 마커 애너테이션 보다 좋은 점도 있습니다.첫 째로 마커 인터페이스는 이를 구현한 클래스의 인스턴스들을 구분하는 타입을 쓸 수 있지만, 마커 애너테이션은 그렇지 않습니다. 마커 인터페이스는 타입이고 마커 애너테이션을 사용하면 런타임에야 발견할 수 있습니다.자바의 직렬화는 Serializable 마커 인터페이스를 보고 그 대상이 직렬화를 할 수 있는 타입인지 확인합니다.","title":""},{"content":"[아이템 42] 익명 클래스보다는 람다를 사용하라. 자바 8부터는 함수형 프로그래밍을 지원합니다. 추상 메서드가 하나인(Single Abstract Method)인터페이스를 함수형 인터페이스라고 부르며 람다식을 사용해 만들 수 있습니다. 람다는 익명클래스에 비해 코드가 간결하고 가독성이 좋다는 장점이 있습니다.\n1 2 3 4 5 6 7  // 익명 클래스 방식 Collections.sort(words, new Comparator\u0026lt;String\u0026gt;() { @Override public int compare(String s1, String s2) { return Interget.compare(s1.length(), s2.length()); } });   1 2 3  // 람다 활용 Collections.sort(words, (s1, s2) -\u0026gt; Integer.compare(s1.length(), s2.length()));   컴파일러가 타입을 추론해주기 때문에 타입을 명시해야 코드가 더 명확해질 때만 제외하고는, 람다의 매개변수 타입은 생략해줍시다. 혹시 컴파일러가 타입을 추론하지 못할경우에 명시해주면 됩니다.람다 자리에 메서드 참조를 활용하면 코드를 더 간결하게 만들어 줄 수 있습니다.\n 문법:클래스이름::메소드이름또는참조변수이름::메소드이름\n 1  Collections.sort(words, comparing(String::length));   더 나아가 자바 8 때 List 인터페이스에 추가된 sort 메서드를 이용하면 더욱 짧아집니다.\n1  words.sort(comparing(String::length));   람다를 사용해서 코드 자체로 동작이 명확히 설명되지 않거나, 코드가 더 장황해질 경우 람다를 사용하지 말아야 합니다. 람다는 세 줄안에 끝내는 게 좋습니다.람다가 길거나 읽기 불편하면 리팩터링을 시도하길 추천합니다.\n람다는 함수형 인터페이스에서만 쓰입니다. 예컨대 인터페이스의 추상메서드가 한 개가 넘어가면 람다를 사용할 수 없습니다. 또 람다는 자신을 참조할 수 없습니다. 람다에서 this 키워드는 바깥 인스턴스를 가리킵니다.\n","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-06/item42/","summary":"[아이템 42] 익명 클래스보다는 람다를 사용하라. 자바 8부터는 함수형 프로그래밍을 지원합니다. 추상 메서드가 하나인(Single Abstract Method)인터페이스를 함수형 인터페이스라고 부르며 람다식을 사용해 만들 수 있습니다. 람다는 익명클래스에 비해 코드가 간결하고 가독성이 좋다는 장점이 있습니다.\n1 2 3 4 5 6 7  // 익명 클래스 방식 Collections.sort(words, new Comparator\u0026lt;String\u0026gt;() { @Override public int compare(String s1, String s2) { return Interget.compare(s1.length(), s2.length()); } });   1 2 3  // 람다 활용 Collections.","title":""},{"content":"[아이템 43] 람다보다는 메서드 참조를 사용하라. 메서드 참조를 이용하면 람다보다 간단하게 코드를 작성할 수 있습니다.\n 문법 클래스이름::메소드이름또는참조변수이름::메소드이름\n 다음의 예제 코드는 키가 맵에 없다면 키와 숫자 1을 매핑하고, 이미 있다면 기존 매핑 값에 1을 증가시킵니다.\n1  map.merger(key, 1, (count, incr) -\u0026gt; count + incr);   위 코드는 Integer의 sum메서드를 이용해서 대체할 수 있으며 메서드 참조를 이용해 간결하게 표현할 수 있습니다.\n1  map.merger(key, 1, Integer::sum);   메서드 참조를 이용하면 코드가 간결해지며 가독성이 좋아지는 경우가 있지만 때로는 람다에서는 매개변수의 이름으로 가이드를 할 수도 있고 메서드 참조보다 더 읽기 쉽고 가독성이 더 좋아지는 경우가 있습니다.메서드 참조 유형은 다섯가지가 있습니다. 가장 흔한 유형은 앞에서 사용했던 정적 메서드를 가리키는 메서드 참조입니다. 먼저 인스턴스 메서드를 참조하는 유형이 두 가지가 있습니다. 그 중 하나는 수신 객체(receiving object; 참조 대상 인스턴스)를 특정하는 한정적(bound) 인스턴스 참조이고, 다른 하나는 수신 객체를 특정하지 않는 비한정적(unbound) 인스턴스 메서드 참조압니다. 한정적 참조는 함수 객체가 받는 인수와 참조되는 메서드가 받는 인수와 똑같습니다. 비한정적 참조에서는 함수 객체를 적용하는 시점에 수신 객체를 알려줍니다. 이를 위해 수신 객체 전달용 매개변수가 매개변수의 목록의 첫 번째로 추가되며, 그 뒤로는 참조되는 메서드 선언에 정의된 매개변수들이 뒤따릅니다. 비한정적 참조는 스트림 파이프라인에서의 매핑과 필터 함수에 주로 사용됩니다.\n","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-06/item43/","summary":"[아이템 43] 람다보다는 메서드 참조를 사용하라. 메서드 참조를 이용하면 람다보다 간단하게 코드를 작성할 수 있습니다.\n 문법 클래스이름::메소드이름또는참조변수이름::메소드이름\n 다음의 예제 코드는 키가 맵에 없다면 키와 숫자 1을 매핑하고, 이미 있다면 기존 매핑 값에 1을 증가시킵니다.\n1  map.merger(key, 1, (count, incr) -\u0026gt; count + incr);   위 코드는 Integer의 sum메서드를 이용해서 대체할 수 있으며 메서드 참조를 이용해 간결하게 표현할 수 있습니다.\n1  map.merger(key, 1, Integer::sum);   메서드 참조를 이용하면 코드가 간결해지며 가독성이 좋아지는 경우가 있지만 때로는 람다에서는 매개변수의 이름으로 가이드를 할 수도 있고 메서드 참조보다 더 읽기 쉽고 가독성이 더 좋아지는 경우가 있습니다.","title":""},{"content":"[아이템 44] 표준 함수형 인터페이스를 사용하라. java.util.function 패키지에 다양한 용도의 표준 함수형 인터페이스가 정의되어 있으므로 용도에 맞는 게 있다면 직접 구현하지 말고 표준 함수형 인터페이스를 활용합시다. 일관성을 높일 수 있고 디폴트 메서드를 많이 제공하므로 다른 코드와의 상호운용성도 증가할 것입니다. java.util.function에는 총 43개의 인터페이스가 있지만 기본 인터페이스 6개만 기억하면 나머지는 충분히 유추할 수 있으며 나머지는 필요할 때마다 찾아서 사용하면 됩니다.\n표준 함수형 인터페이스 대부분은 기본 타입만 지원합니다. 그렇다고 기본 함수형 인터페이스에 박싱된 기본 타입을 넣어서 사용하지 맙시다. 동작은 하지만 계산량이 많을 때 성능 이슈가 생길 수 있습니다.표준 함수형 인터페이스 중 필요한 용도에 맞는 게 없다면 물론 함수형 인터페이스를 직접 작성해야 합니다. 다만 주의할 점이 함수형 인터페이스에는 항상 @FunctionalInterface 애너테이션을 사용해야 합니다. 누군가 실수로 추상 메서드를 하나 더 만드는 것을 방지해줄 수 있기 때문입니다.\n","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-06/item44/","summary":"[아이템 44] 표준 함수형 인터페이스를 사용하라. java.util.function 패키지에 다양한 용도의 표준 함수형 인터페이스가 정의되어 있으므로 용도에 맞는 게 있다면 직접 구현하지 말고 표준 함수형 인터페이스를 활용합시다. 일관성을 높일 수 있고 디폴트 메서드를 많이 제공하므로 다른 코드와의 상호운용성도 증가할 것입니다. java.util.function에는 총 43개의 인터페이스가 있지만 기본 인터페이스 6개만 기억하면 나머지는 충분히 유추할 수 있으며 나머지는 필요할 때마다 찾아서 사용하면 됩니다.\n표준 함수형 인터페이스 대부분은 기본 타입만 지원합니다. 그렇다고 기본 함수형 인터페이스에 박싱된 기본 타입을 넣어서 사용하지 맙시다.","title":""},{"content":"[아이템 45] 스트림은 주의해서 사용하라. 스트림이 제공하는 핵심 개념 중 핵심은 두 가지로 나눌 수 있습니다.\n 스트림은 데이터 원소의 유한 혹은 무한 시퀀스를 뜻합니다. 스트림 파이프라인은 이 원소들로 수행하는 연산 단계를 표현하는 개념입니다.  스트림은 소스 스트림으로 시작해서 종단(최종) 연산(terminal operation)으로 끝나며, 그 사이에 하나 이상의 중간 연산자가 있을 수 있습니다. 중간 연산자는 어떠한 방식으로 변환(transform) 합니다. 최종 연산은 원소를 정렬해 컬렉션에 담거나, 특정 원소 하나를 선택하거나, 모든 원소를 출력하는 식입니다.\n스트림 파이프 라인은 lazy합니다. 최종 연산자가 호출 되기 전까지 실행하지 않습니다. 최종 연산에 쓰이지 않는 데이터 원소는 계산에 쓰이지 않습니다. 이러한 지연 평가는 무한 스트림을 다룰 수 있게 해줍니다. 최종 연산이 없는 스트림은 아무일도 하지 않으니(NOP) 빼먹는 일이 없도록 합시다.\n스트림 API는 파이프라인 하나를 구성하는 모든 호출을 연결하여 단 하나의 표현식으로 완성할 수 있습니다. 스트림을 이용해서 다양한 기능을 구사할 수 있지만, 잘못 사용하면 읽기 어려워지고 유지보수 하기도 힘들어집니다. 스트림을 ㅊ처음 사용하면 모든 반복문을 스트림으로 바꾸고 싶겠지만, 신중하게 생각해봐야 합니다. 가독성과 유지보수, 메모리 측면에서 손해를 볼 수 있기 때문입니다.\n스트림 파이프라인에서 계산을 함수 객체로 표현하는데 함수 객체로는 할 수 없지만 코드 블록으로 할 수 있는 일들이 있습니다.\n 코드 블록에서는 범위 안의 지역변수를 읽고 수정할 수 있습니다. 하지만 람다에서는 final이거난 effective final만 읽을 수 있고, 지역변수를 수정할 수 없습니다. 코드 블록에서는 return문을 사용해 메서드에서 빠져나가거나, break나 continue 문으로 블록 바깥의 반복문을 종료하거나 반복문을 한 번 건너뛸 수 있습니다. 또한 메서드 선언에 명시된 검사 예외를 던질 수 있습니다. 하지만 람다로는 이 중 어떤것도 할 수 없습니다.  계산 로직에서 이상의 일들을 수행을 한다면 스트림과는 맞지 않는 것입니다. 다음은 스트림과 안성 맞춤인 일들 입니다.\n 원소들의 시퀀스를 일관되게 변환한다. 원소들의 시퀀스를 필터링한다. 원소들의 시퀀스를 하나의 연산을 사용해 결합한다. 원소들의 시퀀스를 컬렉션에 모은다. 원소들의 시퀀스에서 ㅌ특정 조건을 만족하는 원소를 찾는다.  ","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-06/item45/","summary":"[아이템 45] 스트림은 주의해서 사용하라. 스트림이 제공하는 핵심 개념 중 핵심은 두 가지로 나눌 수 있습니다.\n 스트림은 데이터 원소의 유한 혹은 무한 시퀀스를 뜻합니다. 스트림 파이프라인은 이 원소들로 수행하는 연산 단계를 표현하는 개념입니다.  스트림은 소스 스트림으로 시작해서 종단(최종) 연산(terminal operation)으로 끝나며, 그 사이에 하나 이상의 중간 연산자가 있을 수 있습니다. 중간 연산자는 어떠한 방식으로 변환(transform) 합니다. 최종 연산은 원소를 정렬해 컬렉션에 담거나, 특정 원소 하나를 선택하거나, 모든 원소를 출력하는 식입니다.","title":""},{"content":"[아이템 46] 스트림에서는 부작용이 없는 함수를 사용하라. 스트림 패러다임의 핵심은 계산을 일련의 변환으로 재구성하는 부분입니다. 이때 각 변환 단계는 가능한 한 이전 단계의 결과를 받아 처리하는 순수 함수여야 하는데, 순수 함수란 입력만이 결과에 영향을 주는 함수를 말합니다. 즉 다른 가변 상태를 참조하지 않고, 함수 스스로도 다른 상태를 변경하지 않습니다.다음은 텍스트 파일에서 단어별 수를 세어 빈도표를 만드는 코드입니다.\n1 2 3 4 5 6 7  // 스트림을 이해하지 못한 코드 - 따라 하지 말 것 Map\u0026lt;String, Long\u0026gt; freq = new HashMap\u0026lt;\u0026gt;(); try (Stream\u0026lt;String\u0026gt; words = new Scanner(file).tokens()) { words.forEach(word -\u0026gt; { freq.merge(word.toLowerCase(), 1L, Long::sum) }); }   스트림 API의 이점을 살리지 못한 코드입니다. 같은 기능의 반복 코드보다 읽기 어렵고, 유지 보수도 어렵습니다. 심지어 forEach에서는 람다가 상태를 수정하기도 합니다.\n1 2 3 4 5 6  // 스트림을 제대로 할용한 예 Map\u0026lt;String, Long\u0026gt; freq = new HashMap\u0026lt;\u0026gt;(); try (Stream\u0026lt;String\u0026gt; words = new Scanner(file).tokens()) { freq = words .collect(groupingBy(String::toLowerCase, counting())); }   forEach 연산은 스트림 결과를 보고할 때만 사용하고, 계산할 때는 사용하지 맙시다.\n다음 코드는 빈도표에서 가장 흔한 단어 10개를 뽑아내는 파이프라인 입니다.\n1 2 3 4 5  // Collectors 정적 임포트를 활용해 코드가 짧아지고 가독성을 향상시켰습니다. List\u0026lt;String\u0026gt; toTen = freq.keySet().stream() .sorted(comparing(freq::get).reversed()) .limit(10) .collect(toList());   이번엔 Collectors의 메서드 기능을 알아보겠습니다. 가장 간단한 맵 수집기로 toMap(keyMapper, valueMapper)가 있습니다.\n1 2  Map\u0026lt;String, String\u0026gt; listToMap = books.stream() .collect(toMap(Book::getIsbn, Book::getName));   다수의 키가 존재한다면 IllegalStateException을 던지며 종료합니다.인수를 3개 받는 toMap은 어떤 키와 그 키에 연관된 연관된 원소들 중 하나를 골라 연관짓는 맵을 만들때 유용합니다. 다음 코드는 음악가와 그 음악가의 베스트 앨범을 연관짓고 싶은 일을 수행합니다.\n1 2 3  Map\u0026lt;Artist, Album\u0026gt; toHits = albums.collect( toMap(Album::artist, artist -\u0026gt; artist, maxBy(Comparing(Album::sales))); )   인수 3개를 받는 toMap도 있습니다. 어떤 키와 그 키에 연관된 원소들 중 하나를 골라 연관짓는 맵을 만들때 유용합니다. 다음 코드는 음악가의 베스트 앨범을 연관짓는 Map을 만드는 코드입니다.\n1 2 3  Map\u0026lt;Artist, Album\u0026gt; toHits = albums.collect( toMap(Album::airtst, a -\u0026gt; a, maxBy(comparing(Album::sales))); )   groupingBy 메서드는 입력으로 분류 함수(classifier)를 받고 출력으로는 원소들을 카테고리별로 모아놓은 맵을 담은 수집기를 반환합니다. 분류 함수는 입력받은 원소가 속하는 카테고리를 반환합니다. groupingBy 함수의 가장 간단한 것은 분류 함수 하나를 인수로 받아 맵으로 반환하는 것입니다.\n1 2 3  // ISBN을 key값으로 갖는 맵의 형태입니다. Map\u0026lt;String, List\u0026lt;Book\u0026gt;\u0026gt; collect = books.stream() .collect(groupingBy(Book::getIsbn));   인수를 두개 갖는 groupingBy함수는 다운스트림 수집기도 함께 명시해야 합니다. 다운 스트림 수집기의 역할은 해당 카테고리의 모든 원소를 담은 스트림으로 부터 값을 생성하는 것입니다. 그 다음 인수를 3개 받는 메서드도 있는데 맵 팩터리도 지정할 수 있습니다.\n","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-06/item46/","summary":"[아이템 46] 스트림에서는 부작용이 없는 함수를 사용하라. 스트림 패러다임의 핵심은 계산을 일련의 변환으로 재구성하는 부분입니다. 이때 각 변환 단계는 가능한 한 이전 단계의 결과를 받아 처리하는 순수 함수여야 하는데, 순수 함수란 입력만이 결과에 영향을 주는 함수를 말합니다. 즉 다른 가변 상태를 참조하지 않고, 함수 스스로도 다른 상태를 변경하지 않습니다.다음은 텍스트 파일에서 단어별 수를 세어 빈도표를 만드는 코드입니다.\n1 2 3 4 5 6 7  // 스트림을 이해하지 못한 코드 - 따라 하지 말 것 Map\u0026lt;String, Long\u0026gt; freq = new HashMap\u0026lt;\u0026gt;(); try (Stream\u0026lt;String\u0026gt; words = new Scanner(file).","title":""},{"content":"[아이템 47] 반환 타입으로는 스트림보다 컬렉션이 낫다. 사실 Stream 인터페이스 Iterable 인터페이스가 정의한 추상 메서드를 전부 포함하고 Iterable 인터페이스가 정의한 방식대로 동작합니다. 하지만 for-each로 스트림을 반복할 수 없는 이유는 Stream이 Iterable을 확장하지 않아서입니다.\nCollection인터페이스는 Iterable의 하위 타입이고 stream의 메서드도 제공하니 반복과 스트림을 동시에 지원합니다. 따라서 원소 시퀀수를 공개하는 공개 API의 반환타입에는 Collection이나 그 하위 타입을 사용하는게 일반적으로 좋습니다.\n정리  원소 시퀀스를 반환하는 메서드를 작성할 때는, 이를 스트림으로 처리하길 원하는 사용자와 반복으로 처리하길 원하는 사용자가 모두 있을 수 있음을 고려하라 컬렉션을 반환할 수 있다면 그렇게 하고 반환 전부터 이미 원소들을 컬렉션에 관리하고 있거나 컬렉션을 하나 더 만들어도 될 정도로 원소 개수가 적다면 ArrayList같은 표준 컬렉션에 담아 반환하라.  ","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-06/item47/","summary":"[아이템 47] 반환 타입으로는 스트림보다 컬렉션이 낫다. 사실 Stream 인터페이스 Iterable 인터페이스가 정의한 추상 메서드를 전부 포함하고 Iterable 인터페이스가 정의한 방식대로 동작합니다. 하지만 for-each로 스트림을 반복할 수 없는 이유는 Stream이 Iterable을 확장하지 않아서입니다.\nCollection인터페이스는 Iterable의 하위 타입이고 stream의 메서드도 제공하니 반복과 스트림을 동시에 지원합니다. 따라서 원소 시퀀수를 공개하는 공개 API의 반환타입에는 Collection이나 그 하위 타입을 사용하는게 일반적으로 좋습니다.\n정리  원소 시퀀스를 반환하는 메서드를 작성할 때는, 이를 스트림으로 처리하길 원하는 사용자와 반복으로 처리하길 원하는 사용자가 모두 있을 수 있음을 고려하라 컬렉션을 반환할 수 있다면 그렇게 하고 반환 전부터 이미 원소들을 컬렉션에 관리하고 있거나 컬렉션을 하나 더 만들어도 될 정도로 원소 개수가 적다면 ArrayList같은 표준 컬렉션에 담아 반환하라.","title":""},{"content":"[아이템 48] 스트림 병렬화는 주의해서 적용하라. 자바 8에 추가된 parallel 메서드는 파이프라인을 병렬 실행할 수 있습니다. 동시성 프로그래밍을 할 때는 안전성과 응답 가능 상태를 유지하기 위해 주의를 기울여야합니다. 데이터 소스가 Stream.iterate거나 중간 연산으로 limit를 쓰면 파이프라인 병렬화로 성능 개선을 기대할 수 없습니다. 대체로 스트림 소스가 ArrayList, HashMap, HashSet, ConcurrentHashMap의 인스턴스거나 배열, int 범위, long 범위일 때 병렬화의 효과가 가장 좋습니다. 이 자료구조들은 데이터를 원하는 크기로 정확하고 손쉽게 나눌 수 있어서 다수의 스레드에 분배하기 좋다는 특성이 있습니다. 나누는 작업은 Spliterator가 담당하고 Spliterator 객체는 Stream이나 Iterable의 spliterator 메서드로 얻어올 수 있습니다. 또한 원소들을 순차적으로 실행할 때 참조 지역성(locality of reference) 가 뛰어납니다.참조 지역성이란 이웃한 원소의 참조들이 메모르에 연속해서 저장되어 있다는 뜻입니다. 만일 참조들이 가리키는 실제 객체가 메모르에 서로 떨어져 있을 경우 참조 지역성이 나빠집니다. 참조 지역성이 낮으면 스레드는 데이터가 주 메모르에서 캐시 메모리로 전송되어 오기를 기다리며 시간을 보내게 됩니다. 참조 지역성이 가장 뛰어난 자료구조는 기본 타입의 배열인데 이는 데이터 자체가 메모리에 연속해서 저장되기 때문입니다.스트림 파이프라인의 최종 연산의 동작 역시 병렬 수행 효율에 영향을 줍니다. 최종 연산 중 병렬화에 가장 적합한 것은 축소입니다. Stream의 reduce 메서드 중 하나 혹은 min, max, sum, count 같이 완성된 형태로 제공되는 메서드를 선택해 수행합니다. anyMatch, allMatch, noneMath처럼 조건에 맞으면 바로 반환되는 메서드도 병렬화에 적합합니다. 반면 가변 축소를 수행하는 Stream의 collect 메서드는 병렬화에 적합하지 안흔데 이는 컬렉션들을 합치는 부담이 크기 때문입니다.\n스트림을 잘못 정렬화하면 결과 자체가 달라지거나 예상치 못한 동작이 발생할 수 있습니다. 이를 안전 실패라 부릅니다. 안전 실패는 스트림 파이프라인에서 사용하는 mapper, filters 혹은 프로그래머가 제공한 다른 함수 객체가 명세대로 동작하지 않을 때 벌어질 수 있습니다.\n","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-06/item48/","summary":"[아이템 48] 스트림 병렬화는 주의해서 적용하라. 자바 8에 추가된 parallel 메서드는 파이프라인을 병렬 실행할 수 있습니다. 동시성 프로그래밍을 할 때는 안전성과 응답 가능 상태를 유지하기 위해 주의를 기울여야합니다. 데이터 소스가 Stream.iterate거나 중간 연산으로 limit를 쓰면 파이프라인 병렬화로 성능 개선을 기대할 수 없습니다. 대체로 스트림 소스가 ArrayList, HashMap, HashSet, ConcurrentHashMap의 인스턴스거나 배열, int 범위, long 범위일 때 병렬화의 효과가 가장 좋습니다. 이 자료구조들은 데이터를 원하는 크기로 정확하고 손쉽게 나눌 수 있어서 다수의 스레드에 분배하기 좋다는 특성이 있습니다.","title":""},{"content":"매개변수가 유효한지 검사하라. 메서드와 생성자는 대부분 특정 조건의 입력 매개변수에 특정 조건을 만족하기를 바랍니다. 만일 잘못된 값이 들어올 경우 보통 예외를 던지거나 컴파일 오류를 잡아내긴 하지만, 오류는 가능한 빨리 잡아내는 게 좋습니다. 그렇지 않으면 감지하기 어려워지고 감지하더라도 찾아내기 힘들어지는 경우도 있습니다.이러한 경우를 방지하기 위해 매개변수를 미리 확인한다면 즉각적이고 깔끔한 방식으로 예외를 처리할 수 있습니다.\n하지만 반드시 메서드를 실행하기 전에 매개변수 유효성 검사를 해야하는 것만은 아닙니다. 유효성 검사 비용이 지나치게 높거나 실용적이지 않을 때는 다시 고려를 해봐야 합니다.이번 아이템의 핵심은 \u0026ldquo;매개변수에 제약을 두는 게 좋다\u0026quot;라는 것이 아닙니다. 메서드는 최대한 범용적으로 설계해야 합니다. 메서드가 건네 받은 값으로 어떠한 제대로 된 일을 할 수 있다면 제약이 적을 수록 좋습니다. 이러한 요소들을 잘 고려해서 상황에 맞게 사용해야합니다.\n","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-07/item49/","summary":"매개변수가 유효한지 검사하라. 메서드와 생성자는 대부분 특정 조건의 입력 매개변수에 특정 조건을 만족하기를 바랍니다. 만일 잘못된 값이 들어올 경우 보통 예외를 던지거나 컴파일 오류를 잡아내긴 하지만, 오류는 가능한 빨리 잡아내는 게 좋습니다. 그렇지 않으면 감지하기 어려워지고 감지하더라도 찾아내기 힘들어지는 경우도 있습니다.이러한 경우를 방지하기 위해 매개변수를 미리 확인한다면 즉각적이고 깔끔한 방식으로 예외를 처리할 수 있습니다.\n하지만 반드시 메서드를 실행하기 전에 매개변수 유효성 검사를 해야하는 것만은 아닙니다. 유효성 검사 비용이 지나치게 높거나 실용적이지 않을 때는 다시 고려를 해봐야 합니다.","title":""},{"content":"[Item50] 적시에 방어적 복사본을 만들라 이번 아이템에서는 지난 Item17에 다루었던 불변에 대한 주제가 포함되어있습니다. 어떤 객체든 객체의 허락 없이는 외부에서 함부로 내부를 수정하게 하는 일이 없아야 합니다. 하지만 주의를 기울이지 않으면 자신도 모르게 내부를 수정하도록 코드를 짜는 경우가 생길 수 있습니다.\n다음은 부주의로 일어날 수 있는 상황을 예시로 든 코드입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  public final class Period { private final Date date; private final Date end; public Period(Date start, Date end) { if (start.compareTo(end) \u0026gt; 0) { throw new IllegalArgumentException(start + \u0026#34;가\u0026#34; + end + \u0026#34;보다 늦다.\u0026#34;); } this.start = start; this.end = end; } public Date start() { return start; } public Date end() { return end; } }   불변을 의도하고 설계한 코드입니다. 하지만 Date가 mutable 하다는 사실을 이용하여 이 불변을 쉽게 깨뜨릴 수 있습니다.\n1 2 3 4  Date start = new Date(); Date end = new Date(); Period p = new Period(start, end); end.setYear(100); // p의 내부를 수정했다   이러한 문제점을 해결하기 위해 자바 8에서는 java.time 패키지를 지원합니다. 하지만 기존 레거시 프로젝트에 Date는 여전히 많이 남아있습니다. 이번에 소개해드릴 방법은 이러한 레거시 코드들을 대처하기 위함입니다. 외부로부터 Period 인스턴스의 내부를 보호하려면 생성자에게 받은 가변 매개변수 각각을 방어적으로 복사해야합니다. 그런 다음 Period 인스턴스 안에서는 원본이 아닌 복사본을 사용해야 합니다.\n1 2 3 4 5 6 7 8 9  // 수정한 생성자 - 매개변수의 방어적 복사본을 만듦 public Period(Date start, Date end) { this.start = new Date(start.getTime()); this.end = new Date(end.getTime()); if (this.start.compareTo(this.end) \u0026gt; 0) { throw new IllegalArgumentException(start + \u0026#34;가\u0026#34; + end + \u0026#34;보다 늦다.\u0026#34;); } }   이 방법을 이용하면 방금의 방식으로 값을 바꾸려고하는 걸 막을 수 있습니다. 매개변수의 유효성을 검하기 전에 방어적 복사본을 만들고, 이 복사본으로 유혀성을 검사한다는 점에 주목해야합니다. 하지만 아직도 Period 객체는 변경 가능합니다. 접근자 메서드가 내부의 가변 정보를 직접 드러내기 떄문입니다.\n1 2 3 4  Date start = new Date(); Date end = new Date(); Period p = new Period(start, end); p.end().setYear(100); // p의 내부를 변경했다.   이 공격을 막아내려면 단순히 접근자가 가변 필드의 방어적 본사본을 반환하거나 setter를 제공하지 않으면 됩니다.\n1 2 3 4 5 6 7  public Date start() { return new Date(start.getTime()); } public Date end() { return new Date(end.getTime()); }   이제 Period는 완벽한 불변으로 거듭납니다. 메서드든 생성자든 클라이언트가 제공한 객체의 참조를 내부의 자료구조에 보관해야 할 때면 항시 그 객체가 잠재적으로 변경될 수 있는지를 생각해야합니다. 방어적 복사에는 성능 저하가 따른다는 것도 명심해야하고 되도록 불변 객체들을 조합해 객체를 구성해야 방어적 복사를 할 일이 줄어듭니다.\n","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-07/item50/","summary":"[Item50] 적시에 방어적 복사본을 만들라 이번 아이템에서는 지난 Item17에 다루었던 불변에 대한 주제가 포함되어있습니다. 어떤 객체든 객체의 허락 없이는 외부에서 함부로 내부를 수정하게 하는 일이 없아야 합니다. 하지만 주의를 기울이지 않으면 자신도 모르게 내부를 수정하도록 코드를 짜는 경우가 생길 수 있습니다.\n다음은 부주의로 일어날 수 있는 상황을 예시로 든 코드입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  public final class Period { private final Date date; private final Date end; public Period(Date start, Date end) { if (start.","title":""},{"content":"[아이템 51] 메서드 시그니처를 신중히 설계하라. 메서드 이름을 신중히 짓자. 항상 표준 명명 규칙을 따라야합니다. 이름만 보고 이해할 수 있고, 일관성있게 짓는 것이 핵심입니다. 그 다음 목표는 개발자 커뮤니티에서 널리 받아들여지는 이름을 사용하는 것입니다. 되도록이면 긴 이름은 피하는 것이 좋습니다. 물론 조직내에 규율이 있다면 그 규율을 지키는 게 우선입니다.\n편의 메서드를 너무 만들지 말자. 메서드가 너무 많은 클래스는 파악하고 유지보수 하기도 힘들고 객체지향 SOLID원칙 중 Single Responsiblity Principle에 위반될 수도 있습니다.\n매개변수 목록은 짧게 유지하자. 가능한 4개 이하가 좋습니다. 물론 IDE를 이용하면 수고를 덜 수 있지만, 매개변수 수는 적은 쪽이 훨씬 낫습니다. 같은 타입의 매개변수가 여러 개 나오는 경우가 특히 해롭습니다. 실수로 순서를 바꿔서 입력해도 그대로 컴파일은 되고 실행되기 때문에 런타임 시에 오작동이 될 수 있습니다.\n다음은 매개변수 목록을 짧게 줄여줄 세 가지 기술입니다.\n 여러 메서드로 쪼갠다. 이 방법은 주의해서 사용합니다. 잘못할 경우 메서드가 너무 많아질 수가 있습니다. 하지만 잘 만들면 직교성을 높여 오히려 메서드 수를 줄여주는 효과도 있습니다. List인터페이스가 대표적인 예입니다. subList메서드와 indexOf 메서드를 적절하게 이용하면 지정된 범위의 부분리스트에서의 인덱스를 찾을 수 있습니다. 두 번째는 매개변수 여러 개를 묶어주는 도우미 클래스를 만드는 것입니다. 일반적으로 이런 도우미 클래스는 정적 멤버 클래스로 둡니다. 앞서 두 개의 기법을 혼합한 것으로 객체 생성에 사용한 빌더 패턴을 메서드 호출에 응용한다고 보면 됩니다. 먼저 모든 매개변수를 하나로 추상화한 객체를 정의하고, 클라이언트에서 이 객체의 세터 메서드를 호출해 필ㅇ한 값을 설정하게 하는 것입니다. 매개변수 타입으로는 클래스보다는 인터페이스가 더 낫습니다. 예를들어 메서드에 ArrayList을 사용하지말고 Map을 사용하는 것입니다. 이 방식을 이용하면 유용성을 얻을 수 있습니다.  ","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-07/item51/","summary":"[아이템 51] 메서드 시그니처를 신중히 설계하라. 메서드 이름을 신중히 짓자. 항상 표준 명명 규칙을 따라야합니다. 이름만 보고 이해할 수 있고, 일관성있게 짓는 것이 핵심입니다. 그 다음 목표는 개발자 커뮤니티에서 널리 받아들여지는 이름을 사용하는 것입니다. 되도록이면 긴 이름은 피하는 것이 좋습니다. 물론 조직내에 규율이 있다면 그 규율을 지키는 게 우선입니다.\n편의 메서드를 너무 만들지 말자. 메서드가 너무 많은 클래스는 파악하고 유지보수 하기도 힘들고 객체지향 SOLID원칙 중 Single Responsiblity Principle에 위반될 수도 있습니다.","title":""},{"content":"[아이템 52] 다중정의는 신중히 사용하라. 다음은 컬렉션을 집합, 리스트, 그 외로 구분하고자 만든 프로그램입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  public class CollectionClassifier { public static String classify(Set\u0026lt;?\u0026gt; s) { return \u0026#34;Set\u0026#34;; } public static String classify(List\u0026lt;?\u0026gt; lst) { return \u0026#34;List\u0026#34;; } public static String classify(Collection\u0026lt;?\u0026gt; c) { return \u0026#34;Unknown Collection\u0026#34;; } public static void main(String[] args) { Collection\u0026lt;?\u0026gt;[] collections = { new HashSet\u0026lt;String\u0026gt;(), new ArrayList\u0026lt;BigInteger\u0026gt;(), new HashMap\u0026lt;String, String\u0026gt;().values() }; for (Collection\u0026lt;?\u0026gt; c : collections) System.out.println(classify(c)); } }   \u0026ldquo;Set\u0026rdquo;, \u0026ldquo;List\u0026rdquo;, \u0026ldquo;Unknown Collection\u0026rdquo; 차례대로 출력될 거 같지만, 실제로 수행하면 \u0026ldquo;Unknown Collection\u0026quot;만 연달아 세 번 출력됩니다. 이유는 오버로딩된 세 classify 증 어느 메서드를 호출할 지가 컴파일 타임에 정해지기 때문입니다. 컴파일 타임에서 for문 안에 c타입은 항상 Collection\u0026lt;?\u0026gt;타입 입니다. 런타임 시에는 달라지지만, 호출할 메서드를 선택하는 데는 영향을 주지 못합니다.\n이처럼 직관에 어긋나는 이유는 재정의한 메서드는 동적으로 선택되고, 다중정의한 메서드는 정적으로 선택되기 때문입니다. 메서드를 재정의 한 다음 하위클래스의 인스턴스에서 그 메서드를 호출하면 재정의한 메서드가 실행됩니다. 컴파일 타임에 그 인스턴스 타입이 무엇인지는 상관 없습니다. 다음 코드는 이러한 상황을 구체적으로 보여주는 예시입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  class Wine { String name() { return \u0026#34;wine\u0026#34;; } } class SparklingWine extends Wine { @Override String name() { return \u0026#34;sparkling wine\u0026#34;; } } class Champagne extends SparklingWine { @Override String name() { return \u0026#34;champagne\u0026#34;; } } class Overriding { public static void main(String[] args) { List\u0026lt;Wine\u0026gt; wineList = Arrays.asList( new Wine(), new SparklingWine(), new Champagne()); for (Wine wine : wineList) { System.out.println(wine.name()); } } }   Wine클래스에서 정의한 name메서드를 각각 서브타입에서 재정의 했습니다. 이 코드를 실행하면 아까와는 달리 \u0026ldquo;wine\u0026rdquo;,\u0026ldquo;sparkling wine\u0026rdquo;, \u0026ldquo;champagne\u0026quot;이 차례대로 출력됩니다. 컴파일 타임 타입이 모두 Wine인 것에 무관하게 항상 가장 하위에서 재정의한 메서드가 실행됩니다.한편 다중정의된 메서드 사이에서는 객체의 런타임 타입은 전혀 중요하지 않습니다. 선택은 컴파일 타임에, 오직 매개변수의 컴파일 타임 타입에 의해 이뤄집니다. 앞서 의도대로 동작하지 않았던 classify 메서드는 하나로 합친 후 instanceof를 이용하면 원하는 데로 동작하게 변경할 수 있습니다.\n다중정의를 안전하고 보수적으로 사용하려면 매개변수 수가 같은 다중정의는 만들지 않는 게 좋습니다. 다중정의 하는 대신 메서드 이름을 다르게 지어주는 경우도 고려해볼 수 있습니다. 대표적인 예로 ObjectOutputStream클래스의 write 메서드가 그러합니다.\n자바 4까지는 기본 타입이 모든 참조 타입이랑 근본적으로 달랐지만, 자바 5에서 부터 오토박싱이 도입되면서 문제가 생긴 부분이 있습니다. 대표적으로 List 인터페이스의 remove메서드가 그러합니다. remove메서드는 int를 받는 메서드와 Object를 매개변수로 받는 메서드로 다중정의 되어 있습니다. 물론 자바 4까지는 문제가 없었지만 오토박싱이 생기면서 혼란을 안겨주고 List인터페이스가 취약해졌습니다.\n","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-07/item52/","summary":"[아이템 52] 다중정의는 신중히 사용하라. 다음은 컬렉션을 집합, 리스트, 그 외로 구분하고자 만든 프로그램입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  public class CollectionClassifier { public static String classify(Set\u0026lt;?\u0026gt; s) { return \u0026#34;Set\u0026#34;; } public static String classify(List\u0026lt;?\u0026gt; lst) { return \u0026#34;List\u0026#34;; } public static String classify(Collection\u0026lt;?\u0026gt; c) { return \u0026#34;Unknown Collection\u0026#34;; } public static void main(String[] args) { Collection\u0026lt;?","title":""},{"content":"[아이템 53] 가변인수는 신중히 사용하라. 가변인수(varargs) 메서드는 명시한 타입의 인수를 0개 이상 받을 수 있습니다. 다음 예제는 int 인자의 합을 구하는 가변인수 메서드입니다.\n1 2 3 4 5 6 7  static int sum(int... args) { int sum = 0; for (int args: args) { sum += args; } return sum; }   1개 이상의 인수가 필요한 경우도 있습니다. 다음 예제는 1개 이상의 인수를 필요료하는 가변인수 메서드의 잘못된 구현입니다.\n1 2 3 4 5 6 7 8 9 10  static int sum(int... args) { if (args.length == 0) { throw new IllegalArgumentException(\u0026#34;인수가 1개 이상 필요합니다.\u0026#34;); } int min = args[0]; for (int arg : args) if (arg \u0026lt; min) min = arg; return min; }   이 방식에는 몇 가지 문제점이 있습니다. 가장 큰 문제는 인수를 0개만 넣으면 런타임 시점에 실패한다는 것입니다. 코드도 지저분합니다.다음 코드는 매개변수를 2개를 받아서 이 문제를 해결하는 방식입니다.\n1 2 3 4 5 6 7 8  static int min(int firstArg, int... remainingArgs) { int min = firstArg; for (int arg : remainingArgs) { if (arg \u0026lt; min) min = arg } return min; }   가변인수를 사용하면서 주의할 점이 있습니다. 가변인수 메서드는 호출될 때마다 배열을 새로 하나 할당하고 초기화기 때문에 성능에 민감할 경우 조심히 주의해서 사용해야합니다. 기변인수 메서드의 유용성을 활용하고 싶고 성능에 민감할 경우 다른 방식을 이용할 수 있습니다. 예를 들어 해당 메서드 호출의 95%가 인수 3개 이하로 사용한다고 하면 다음처럼 0개인 것부터 4개인 것까지, 총 5개를 정의해서 사용할 수 있습니다.\n1 2 3 4 5  public void foo() { } public void foo(int a1) { } public void foo(int a1, int a2) { } public void foo(int a1, int a2, int a3) { } public void foo(int a1, int a2, int a3, int... rest) { }   EnumSet의 정적 팩터리도 이 기법을 사용해 열거 타입 집합 생성 비용을 최소화 합니다.\n","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-07/item53/","summary":"[아이템 53] 가변인수는 신중히 사용하라. 가변인수(varargs) 메서드는 명시한 타입의 인수를 0개 이상 받을 수 있습니다. 다음 예제는 int 인자의 합을 구하는 가변인수 메서드입니다.\n1 2 3 4 5 6 7  static int sum(int... args) { int sum = 0; for (int args: args) { sum += args; } return sum; }   1개 이상의 인수가 필요한 경우도 있습니다. 다음 예제는 1개 이상의 인수를 필요료하는 가변인수 메서드의 잘못된 구현입니다.","title":""},{"content":"[아이템 54] null이 아닌, 빈 컬렉션이나 배열을 반환하라. 1 2 3 4 5 6  // 컬렉션이 비어있으면 null을 반환 - 따라하지 말 것 private final List\u0026lt;Cheese\u0026gt; cheesesInStock = ...; public List\u0026lt;Cheese\u0026gt; getCheeses() { return cheesesInStock.isEmpty() ? null : new ArrayList\u0026lt;\u0026gt;(cheesesInStock); }   null을 반환할 경우 클라이어트는 이 null 상황을 처리하는 코드를 추가로 작성해야합니다.\n1 2 3 4  List\u0026lt;Cheese\u0026gt; cheesesInStock = shop.getCheeses(); if (cheese != null \u0026amp;\u0026amp; cheeses.contains(cheese.STILTON)) { system.out.println(\u0026#34;좋았어, 바로 그거야!\u0026#34;) }   클라이언트에서 null을 처리하는 코드를 빼먹으면 오류가 발생할 수 있으며 코드가 장황해집니다. 때로는 빈 컨테이너를 할당하는 데 비용이 드니 null을 반환하는 게 낫다는 주장도 있습니다. 하지만 이 주장은 두가지 측면에서 틀립니다.첫 번째. 성능 분석 결과 이 할당이 성능 저하의 주범이라고 확인되지 않는 한, 이 정도의 성능 차이는 신경 쓸 수준이 못됩니다. 두 번째 빈 컬렉션과 배열은 굳이 새로 할당하지 않고도 반환할 수 있습니다.\n1 2 3 4  // 빈 컬렉션을 반환하는 올바른 예 public List\u0026lt;Cheese\u0026gt; getCheese() { return new ArrayList\u0026lt;\u0026gt;(cheeseInStock); }   매번 똑같이 빈 불변 컬렉션을 반환하는 방식으로 성능 이슈도 해결할 수 있습니다. Collections.emptyList가 메서드가 대표적인 예입니다. 집합이 필요하면Collections.emptySet을, 맵이 필요하면 Collections.emptyMap을 사용하면 됩니다. 최적화가 필요하다고 판단되면 사용 전과 후를 측정해보고 사용할 것을 추천합니다.\n1 2 3  public List\u0026lt;Cheese\u0026gt; getCheese() { return cheeseInStock.isEmpty() ? Collections.emptyList() : new ArrayList\u0026lt;\u0026gt;(cheeseInStock); }   배열을 사용할 때도 마찬가지입니다. null을 반환 하지 말고 길이기 0인 배열을 반환하면 됩니다.\n1 2 3  public Cheese[] getCheeses() { return cheesesInStock.toArray(new Cheese[0]); }   이 방식에서 성능을 더 개선할 수 있는 방법이 있습니다. 길이가 0짜리 배열을 미리 선언해두고 반환하면 됩니다.\n1 2 3 4  private static final Cheese[] EMPTY_CHEESE_ARRAY = new Cheese[0]; public Cheese[] getCheeses() { return cheesesInStock.toArray(EMPTY_CHEESE_ARRAY); }   ","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-07/item54/","summary":"[아이템 54] null이 아닌, 빈 컬렉션이나 배열을 반환하라. 1 2 3 4 5 6  // 컬렉션이 비어있으면 null을 반환 - 따라하지 말 것 private final List\u0026lt;Cheese\u0026gt; cheesesInStock = ...; public List\u0026lt;Cheese\u0026gt; getCheeses() { return cheesesInStock.isEmpty() ? null : new ArrayList\u0026lt;\u0026gt;(cheesesInStock); }   null을 반환할 경우 클라이어트는 이 null 상황을 처리하는 코드를 추가로 작성해야합니다.\n1 2 3 4  List\u0026lt;Cheese\u0026gt; cheesesInStock = shop.getCheeses(); if (cheese != null \u0026amp;\u0026amp; cheeses.contains(cheese.STILTON)) { system.","title":""},{"content":"[아이템 55] 옵셔널 반환은 신중히 하라 자바 8이전에는 메서드가 특정 값을 반환할 수 없을때 취할 수 있는 선택지가 두 가지가 있었습니다. 예외를 던지거나, null을 반환하는 것입니다. 두 방법 모두 허점이 있습니다. 예외는 진짜 예외적인 상황에서만 사용해야 하며 예외를 생성할 때 스택 추적 전체를 캡쳐하므로 바용도 만만치 않습니다. null을 반환할 수 있는 메서드를 호출하면 null 처리를 별도로 해줘야합니다. null 처리를 무시하면 나중에 NPE가 발생할 수 있습니다.\n자바 8부터는 Optional을 지원했습니다. Optional\u0026lt;T\u0026gt;는 null이 아닌 T타입 참조를 하나 담거나, 아무것도 담지 않을 수 있습니다. optional을 이용하면 예외를 던지느 메서드보다 더 유연하고, null을 반환하는 메서드보다 오류 가능성이 적습니다.\n하지만 그렇다고 Optional을 남발해서는 안 됩니다. 대표적으로 컬렉션, 스트림, 배열, 옵셔널 같은 컨테이너 타입은 옵셔널로 반환하면 안 됩니다. 빈 컨테이너를 그대로 반환하면 클라이언트에 옵셔널 처리 코드를 넣지 않아도 됩니다.Optional도 새로 할당하고 초기화해야 하는 객체이고, 그 안에서 값을 꺼내는 메서드를 호출하는 단계를 추가롤 거쳐야 합니다. 박싱된 기본 타입을 감싸는 Optional같은 경우 값을 두 번이나 감싸니 기본 타입보다 훨씬 무거울 수 밖에 없습니다. 그래서 OptionalInt, OptionalLong, OptionalDouble을 제공하니 박싱된 기본 타입을 담은 Optional은 사용하는 일이 없도록 합시다.\n","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-07/item55/","summary":"[아이템 55] 옵셔널 반환은 신중히 하라 자바 8이전에는 메서드가 특정 값을 반환할 수 없을때 취할 수 있는 선택지가 두 가지가 있었습니다. 예외를 던지거나, null을 반환하는 것입니다. 두 방법 모두 허점이 있습니다. 예외는 진짜 예외적인 상황에서만 사용해야 하며 예외를 생성할 때 스택 추적 전체를 캡쳐하므로 바용도 만만치 않습니다. null을 반환할 수 있는 메서드를 호출하면 null 처리를 별도로 해줘야합니다. null 처리를 무시하면 나중에 NPE가 발생할 수 있습니다.\n자바 8부터는 Optional을 지원했습니다. Optional\u0026lt;T\u0026gt;는 null이 아닌 T타입 참조를 하나 담거나, 아무것도 담지 않을 수 있습니다.","title":""},{"content":"[아이템 56] 공개된 API 요소에는 항상 문서화 주석을 작성하라. javadocd이라는 유틸리티를 이용하면 소스코드 파일에서 문서화 주석이라는 특수한 형태로 기술된 설명을 추려 API 문서로 변환해줍니다.메서드용 문서화 주석에는 해당 메서드와 클라이어트 사이의 규약을 명료하게 기술해야 합니다. 핵심 포인트는 how가 아닌 what입니다. 무엇을 하는지에 대한 설명이 있어야 합니다. 또한 메서드를 호출하기위한 조건, 수행된 후에 만족해야 하는 사후조건, 부작용도 모두 나열되어야 합니다. 잘 쓰인 문서인지 확인하는 유일한 방법은 자바독 유틸리티가 생성한 웹페이지를 읽어보는 길뿐입니다.\n","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-07/item56/","summary":"[아이템 56] 공개된 API 요소에는 항상 문서화 주석을 작성하라. javadocd이라는 유틸리티를 이용하면 소스코드 파일에서 문서화 주석이라는 특수한 형태로 기술된 설명을 추려 API 문서로 변환해줍니다.메서드용 문서화 주석에는 해당 메서드와 클라이어트 사이의 규약을 명료하게 기술해야 합니다. 핵심 포인트는 how가 아닌 what입니다. 무엇을 하는지에 대한 설명이 있어야 합니다. 또한 메서드를 호출하기위한 조건, 수행된 후에 만족해야 하는 사후조건, 부작용도 모두 나열되어야 합니다. 잘 쓰인 문서인지 확인하는 유일한 방법은 자바독 유틸리티가 생성한 웹페이지를 읽어보는 길뿐입니다.","title":""},{"content":"[아이템 57] 지역변수의 범위를 최소화하라. 지역변수의 범위는 가능한 좁히는 게 좋습니다. 가장 좋은 방법은 선언과 동사에 초기화 해주는 것입니다. 초기화에 필요한 정보가 없다면 정보가 주어질 때까지 선언을 미루는 것입니다.. 물론 try-catch문은 이 규칙에서 예외입니다. try 블록 안에서 초기화해야하고 밖에서도 쓰일 경우 try 블록 앞에서 선언해야 합니다.\n이러한 지역변수 초기화는 대표적으로 for (for-each), while로 비교할 수 있습니다.\n1 2 3 4  // 컬렉션이나 베열을 순회하는 권장 관용구 for (Element e : c) { ... }   1 2 3 4 5  // 빈복자가 필요한 때의 관용구 for (Iterator\u0026lt;Element\u0026gt; i = c.iterator(); i.hasNext;) { Elements e = i.next(); ... }   1 2 3 4 5 6 7 8 9  Iterator\u0026lt;Element\u0026gt; i = c.iterator(); while (i.hasNext()) { // 버그  doSomething(i.next()); } // while문 실수로 버그 발생 Iterator\u0026lt;Element\u0026gt; i2 = c2.iterator(); while (i.hasNext()) { // 버그  doSomething(i2.next()); }   복사 붙여넣기를 하다가 실수로 i를 그대로 사용한 것입니다. i의 유효범위가 살아있어서 발생하는 일입니다. 이는 컴파일 오류도 잡지 못하고 런타임시 엉뚱한 결과를 초래할 수 있습니다. 이러한 일이 발생하지 않으려면 지역변수의 범위를 최소화 해야합니다.\n","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-08/item57/","summary":"[아이템 57] 지역변수의 범위를 최소화하라. 지역변수의 범위는 가능한 좁히는 게 좋습니다. 가장 좋은 방법은 선언과 동사에 초기화 해주는 것입니다. 초기화에 필요한 정보가 없다면 정보가 주어질 때까지 선언을 미루는 것입니다.. 물론 try-catch문은 이 규칙에서 예외입니다. try 블록 안에서 초기화해야하고 밖에서도 쓰일 경우 try 블록 앞에서 선언해야 합니다.\n이러한 지역변수 초기화는 대표적으로 for (for-each), while로 비교할 수 있습니다.\n1 2 3 4  // 컬렉션이나 베열을 순회하는 권장 관용구 for (Element e : c) { .","title":""},{"content":"[아이템 58] 전통적인 for 문보다는 for-each를 사용하라. for 문은 코드가 장황해질 수 있고, 요소 종류가 늘어날 수록 오류가 생길 가능성이 있습니다. for-each (정식명칭 향상된 for문)은 이러한 단점들을 해결해줄 수 있습니다.\n1 2 3  for (Element e : elements) { .... // e로 무언가를 한다. }   컬렉션을 중첩해서 사용하면 for-each 문의 이점은 더욱 커집니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13  // 버그를 찾아보자 enum Suit { CLUB, DIAMOND, HEART, SPADE } enum Rank { ACE, DEUCE, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT, NINE, TEN, JACK, QUEEN, KING } ... static Collection\u0026lt;Suit\u0026gt; suits = Arrays.asList(Suit.values()); static Collection\u0026lt;Rank\u0026gt; ranks = Arrays.asList(Rank.values()); List\u0026lt;Card\u0026gt; deck = new ArrayList\u0026lt;\u0026gt;(); for (Iterator\u0026lt;Suit\u0026gt; i = suits.iterator(); i.hasNext(); ) for (Iterator\u0026lt;Rank\u0026gt; j = ranks.iterator(); j.hasNext(); ) deck.add(new Card(i.next(), j.next()));   마지막 줄에 i에서 문제가 발생합니다. i(무늬)가 j(숫자)당 하나씩만 부여되야하는데, i랑 j과 next로 함께 순회하고 있는 것입니다. 이 케이스에너느 결국 NoSuchElementException이 발생하게 됩니다.\n이러한 문제점들은 for-each문을 이용해서 간단하게 해결할 수 있습니다.\n1 2 3 4 5  for (Suit suit : suits) for (Rank rank : ranks) { deck.add(new Card(suit, rank)); } }   하지만 몬든 상황에서 for-each 문을 사용할 수 있는 건 아닙니다. 다음은 for-each 문을 사용할 수 없는 상황입니다.\n 파괴적인 필터링: 컬렉션을 순회하면서 선택된 원소를 제거하려면 반복자의 remove 메서드를 호출해야 합니다. 자바 8부터는 Collection의 removeIf 메서드를 사용해 컬렉션을 명시적으로 순회하는 일을 피할수 있습니다. 변형: 리시트나 배열을 순회하면서 그 원소의 값 일부 홋은 전체를 교체해야 한다면 반복자나 배열의 인덱스를 사용해야 합니다. 병렬 반복: 여러 컬렉션을 병렬로 순회해야 한다면 각각의 반복자와 인덱스 변수를 사용해 엄격하고 명시적으로 제어해야 합니다.  ","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-08/item58/","summary":"[아이템 58] 전통적인 for 문보다는 for-each를 사용하라. for 문은 코드가 장황해질 수 있고, 요소 종류가 늘어날 수록 오류가 생길 가능성이 있습니다. for-each (정식명칭 향상된 for문)은 이러한 단점들을 해결해줄 수 있습니다.\n1 2 3  for (Element e : elements) { .... // e로 무언가를 한다. }   컬렉션을 중첩해서 사용하면 for-each 문의 이점은 더욱 커집니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13  // 버그를 찾아보자 enum Suit { CLUB, DIAMOND, HEART, SPADE } enum Rank { ACE, DEUCE, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT, NINE, TEN, JACK, QUEEN, KING } .","title":""},{"content":"[아이템 59] 라이브러리를 익히고 사용하라. 0부터 명시한 수 까지 무작위 정수를 하나 생성하려고 합니다. 다음은 흔히 마주할 수 있는 문제있는 메서드입니다.\n1 2 3 4 5  static Random ran = new Randon(); static int random(int n) { return Math.abs(ran.nextInt()) % n; }   이 코드에는 세 가지 문제점이 있습니다. 첫 번째. n이 그리 크지 않은 2의 제곱수라면 얼마 지나지 않아 같은 수열이 반복됩니다. 두 번째, n이 2의 제곱수가 아니라면 몇몇 숫자가 평균적으로 더 반복됩니다. n값이 크면 이 현상은 더 두드러집니다.\n다음 코드는 선택한 버뮈에서 무작위 수를 백만개를 생성한 뒤, 그 중 중간 값보다 작은 게 몇 개인지를 출력합니다.\n1 2 3 4 5 6 7 8 9 10  public static void main(String[] args) { int n = 2 * (Integer.MAX_VALUE / 3); int low = 0; for (int i = 0; i \u0026lt; 1000000; i++) { if (random(n) \u0026lt; n/2) { low++; } } System.out.println(low); }   이상적으로는 50만개가 나와야하지만 계속 실행해봐도 666,666개와 가까운 값을 얻습니다. 이는 random 메서드의 결함인데 지정한 범위 \u0026lsquo;바깥\u0026rsquo;수가 종종 튀어나올 수 있습니다. rnd.nextInt()가 반환한 값을 Math.abs를 이용해 음수가 아닌 정수로 매핑하기 때문입니다. 라이브러리를 제대로 익히지 않고 사용하기 때문에 나타난 문제입니다.자바 7부터는 Random대신 ThreadLocalRandom을 사용하는 게 좋습니다. Random보다 속도도 더 빠르고 고품질의 무작위 수를 생성하기 때문입니다. 한편 포크-조인 풀이나 병렬 스트림에서는 SplittableRandom을 사용합시다.\n라이브러리를 익히고 사용하면 다음과 같은 이점들도 추가로 있습니다. 노력을 하지 않아도 성능이 지속해서 개선 될 수 있습니다. 또한 기능이 점점 많아진다는 것입니다. 라이브러리에 부족한 부분이 있다면 논의된 후 다음 릴리즈에 해당 기능이 추가도곤 합니다. 마지막으로 여러분으 작성한 코드가 많은 사람에게 낯익은 콛,가 됩니다. 결국 유지 보수하기가 쉬워지고 가독성이 좋아집니다.\n","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-08/item59/","summary":"[아이템 59] 라이브러리를 익히고 사용하라. 0부터 명시한 수 까지 무작위 정수를 하나 생성하려고 합니다. 다음은 흔히 마주할 수 있는 문제있는 메서드입니다.\n1 2 3 4 5  static Random ran = new Randon(); static int random(int n) { return Math.abs(ran.nextInt()) % n; }   이 코드에는 세 가지 문제점이 있습니다. 첫 번째. n이 그리 크지 않은 2의 제곱수라면 얼마 지나지 않아 같은 수열이 반복됩니다. 두 번째, n이 2의 제곱수가 아니라면 몇몇 숫자가 평균적으로 더 반복됩니다.","title":""},{"content":"[아이템 60] 정확한 답이 필요하다면 float와 double은 피하라. float와 dobule은 과학과 공학 계산용으로 설계 되었습니다. 이진 부동소수점 연산에 쓰이며, 넓은 범위의 수를 빠르게 정밀한 \u0026lsquo;근사치\u0026rsquo;로 계산하도록 설계되었습니다. 따라서 정확한 계산 결과가 필요할 때는 사용하면 안 됩니다. 특 히 금용 관련 계산과 맞지 않습니다. 0.1 혹은 10의 음의 거듭 제곱수(10^-1, 10-^2)를 표현할 수 없기 때문입니다.예를 들어 1.03달러에서 42센트를 사용하고 남은 돈을 계산한다고 가정해봅시다.\n1  System.out.println(1.03 - 0.42);   이 코드는 0.6100000000000001를 출력합니다. 원하는 결과가 나오지 않음을 알 수 있습니다.다음 예제는 주머니에는 1달러가 있고 10,20 .. 1달러 짜리의 사탕이 있습니다. 10센트짜리부터 하나씩 얼마나 살 수 있고, 잔돈을 확인하는 어설픈 코드입니다.\n1 2 3 4 5 6 7 8  double funds = 1.00; int itemsBought = 0; for (double price = 0.10; funds \u0026gt;= price; price += 0.10) { funds -= price; itemsBought++; } System.out.println(itemsBought + \u0026#34; items bought.\u0026#34;); System.out.println(\u0026#34;Change: $\u0026#34; + funds);   실행 결과 3개를 구매했고, 잔돈은 0.3999999999999999 달러가 출력되는 걸 확인할 수 있습니다. 이러한 금융 계산 문제에는 BigDecimal, int 혹은 long을 사용해야 합니다.\n다음 코드는 BigDecimal로 교체한 코드입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13  final BigDecimal TEN_CENTS = new BigDecimal(\u0026#34;.10\u0026#34;); int itemsBought = 0; BigDecimal funds = new BigDecimal(\u0026#34;1.00\u0026#34;); for (BigDecimal price = TEN_CENTS; funds.compareTo(price) \u0026gt;= 0; price = price.add(TEN_CENTS)) { funds = funds.subtract(price); itemsBought++; } System.out.println(itemsBought + \u0026#34; items bought.\u0026#34;); System.out.println(\u0026#34;Money left over: $\u0026#34; + funds);   4개를 구매했고 잔돈은 0이 나온 걸 확인할 수 있습니다. 하지만 Dedecimal에는 두 가지 단점이 존재합니다. 기본타입보다 쓰기 불편하고 훨씬 느립니다. Bigdecimal의 대안으로 int, long를 사용할 수도 있습니다. 그럴경우 소숫점 관리랑 값의 크기는 따로 관리해줘야합니다.\n","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-08/item60/","summary":"[아이템 60] 정확한 답이 필요하다면 float와 double은 피하라. float와 dobule은 과학과 공학 계산용으로 설계 되었습니다. 이진 부동소수점 연산에 쓰이며, 넓은 범위의 수를 빠르게 정밀한 \u0026lsquo;근사치\u0026rsquo;로 계산하도록 설계되었습니다. 따라서 정확한 계산 결과가 필요할 때는 사용하면 안 됩니다. 특 히 금용 관련 계산과 맞지 않습니다. 0.1 혹은 10의 음의 거듭 제곱수(10^-1, 10-^2)를 표현할 수 없기 때문입니다.예를 들어 1.03달러에서 42센트를 사용하고 남은 돈을 계산한다고 가정해봅시다.\n1  System.out.println(1.03 - 0.42);   이 코드는 0.","title":""},{"content":"[아이템 61] 박싱된 기본 타입보다는 기본 타입을 사용하라. 자바의 데이터 타입은 기본형과 참조형이 있습니다. 기본형에 대응하는 참조 타입이 하나씩 있으며 이를 박싱된 기본 타입이라 합니다. 기본 타입과 박싱된 기본 타입은 분명한 차이가 있으며 용도에 맞게 사용해야합니다.박싱된 기본 타입은 값 뿐만 아니라 식별성이 더해졌습니다. 즉 값이 같아도 서로 다르게 식별될 수 있습니다. 그리고 박싱 타입은 null을 가질 수 있습니다. 추가로 기본 타입은 박싱 타입보다 메모리와 시간 측면에서 더 효율적입니다.1 2 3  // 잘못 구현된 비교자 Comparator\u0026lt;Integer\u0026gt; naturalOrder = (i, j) -\u0026gt; (i \u0026lt; j) ? -1 : (i == j ? 0 : 1);   컴파일 오류도 생기지 않고 잘 실행되지만 런타임에서 엉뚱한 결과가 발생할 수 있습니다. new Integer(10), new Integer(10) 똑같은 값이지만 0이 아닌 1을 출력합니다. 첫번째 (i \u0026lt; j)는 오토언박싱이 일어나서 정상적으로 작동합니다. 하지만 (i == j)에서는 참조를 비교하기 때문에 false가 나오게 됩니다. 실무에서는 이와 같이 기본 타입을 다루는 비교자가 필요하면 Comparator.naturalOrder를 사용합시다. 비교자를 직접 만들면 비교자 생성 메서드나 기본타입을 받는 정적 compare 메서드를 사용해야 합니다.이 문제를 해결하려면 지역변수 2개를 두어 각각 박싱된 Integer 매개변수의 값을 기본타입으로 저장한 다음, 비교를 수행해야 합니다.\n1 2 3 4 5  // 문제를 수정한 비교자 Comparator\u0026lt;Integer\u0026gt; naturalOrder = (iBoxed, jBoxed) -\u0026gt; { int i = iBoxed, j = jBoxed; reutrn i \u0026lt; j ? -1 : (i == j ? 0 : 1); };   다음은 시간에 대한 문제입니다.\n1 2 3 4 5  Long sum = 0L; for(long i = 0; i \u0026lt;= Integer.MAX_VALUE; i++) { sum += i; } System.out.println(sum);   박싱과 언박싱이 반복되면서 굉장히 성능이 저하되는 걸 확인할 수 있습니다.\n","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-08/item61/","summary":"[아이템 61] 박싱된 기본 타입보다는 기본 타입을 사용하라. 자바의 데이터 타입은 기본형과 참조형이 있습니다. 기본형에 대응하는 참조 타입이 하나씩 있으며 이를 박싱된 기본 타입이라 합니다. 기본 타입과 박싱된 기본 타입은 분명한 차이가 있으며 용도에 맞게 사용해야합니다.박싱된 기본 타입은 값 뿐만 아니라 식별성이 더해졌습니다. 즉 값이 같아도 서로 다르게 식별될 수 있습니다. 그리고 박싱 타입은 null을 가질 수 있습니다. 추가로 기본 타입은 박싱 타입보다 메모리와 시간 측면에서 더 효율적입니다.1 2 3  // 잘못 구현된 비교자 Comparator\u0026lt;Integer\u0026gt; naturalOrder = (i, j) -\u0026gt; (i \u0026lt; j) ?","title":""},{"content":"[아이템 62] 다른 타입이 적절하다면 문자열 사용을 피하라. 문자열은 다른 값 타입을 대신하기엔 적절하지 않습니다.\n1 2  // 흔한 타입을 문자열로 처리한 부적절한 예 String compoundKey = className + \u0026#34;#\u0026#34; + i.next();   두 요소를 구분해주는 #이 두 요소 중 하나에서 쓰였다면 혼란을 초래할 수 있습니다. 각 요소를 개별로 접근하려면 문자열을 파싱해야 해서 느리고, 귀찮고, 오류 가능성도 커집니다. 이럴 경우 전용 클래스를 새로 만드는 편이 낫습니다. 보통 private 정적 멤버 클래스로 선언합니다.1 2 3 4 5  public final class ThreadLocal\u0026lt;T\u0026gt; { public ThreadLocal() {} public void set(T value); public T get(); }   ","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-08/item62/","summary":"[아이템 62] 다른 타입이 적절하다면 문자열 사용을 피하라. 문자열은 다른 값 타입을 대신하기엔 적절하지 않습니다.\n1 2  // 흔한 타입을 문자열로 처리한 부적절한 예 String compoundKey = className + \u0026#34;#\u0026#34; + i.next();   두 요소를 구분해주는 #이 두 요소 중 하나에서 쓰였다면 혼란을 초래할 수 있습니다. 각 요소를 개별로 접근하려면 문자열을 파싱해야 해서 느리고, 귀찮고, 오류 가능성도 커집니다. 이럴 경우 전용 클래스를 새로 만드는 편이 낫습니다. 보통 private 정적 멤버 클래스로 선언합니다.","title":""},{"content":"# [아이템 63] 문자열 연결은 느리니 주의하라. 문자열 연결 연산자로 문자열을 n개를 잇는 시간은 n^2에 비례합니다. 문자열은 immutable이라 두 문자열을 연결할 경우 양쪽의 내용을 모두 복사해야 하므로 성능 저하는 피할 수 없습니다.\n1 2 3 4 5 6 7  public String statement() { String result = \u0026#34;\u0026#34;; for (int i = 0; i \u0026lt; numItems(); i++) { result += lineForItem(); // 문자열연결  } return result; }   StringBuilder를 활용하면 성능을 크게 개선할 수 있습니다.\n1 2 3 4 5 6 7 8  // StringBuilder를 활용한 성능 개g선 public String statement() { StringBuilder sb = new SringBuilder(numItems() * LINE_WIDTH); for (int i = 0; i \u0026lt; numItems(); i++) { b.append(lineForItem(i)); } return b.toString(); }   `\n","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-08/item63/","summary":"# [아이템 63] 문자열 연결은 느리니 주의하라. 문자열 연결 연산자로 문자열을 n개를 잇는 시간은 n^2에 비례합니다. 문자열은 immutable이라 두 문자열을 연결할 경우 양쪽의 내용을 모두 복사해야 하므로 성능 저하는 피할 수 없습니다.\n1 2 3 4 5 6 7  public String statement() { String result = \u0026#34;\u0026#34;; for (int i = 0; i \u0026lt; numItems(); i++) { result += lineForItem(); // 문자열연결  } return result; }   StringBuilder를 활용하면 성능을 크게 개선할 수 있습니다.","title":""},{"content":"[아이템 64] 객체는 인터페이스를 사용해 참조하라. 1 2  // 좋은 예 Set\u0026lt;Student\u0026gt; student = new HashSet\u0026lt;\u0026gt;();   1 2  // 나쁜 예. 클래스 참조 HashSet\u0026lt;Student\u0026gt; student = new HashSet\u0026lt;\u0026gt;();   인터페이스를 활용하면 유연함을 얻을 수 있습니다. 구현체를 교체하고 싶으면 구현 클래스만 바꾸면 됩니다.\n1 2  // HashSet -\u0026gt; LinkedHashSet 교체 Set\u0026lt;Student\u0026gt; student = new LinkedHashSet\u0026lt;\u0026gt;();   하지만 구현체를 바꿀 경우 주의할 점이 있습니다. 기존 구현체만의 특별한 기능을 제공하는 게 있다면, 바꿀 구현체에도 있는지 혹은 사이드 이펙트도 충분히 고려해야 합니다. 물론 적합한 인터페이스가 없을 경우는 당연히 클래스를 참조해야한다. 대표적으로 String 등이 있습니다.\n","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-08/item64/","summary":"[아이템 64] 객체는 인터페이스를 사용해 참조하라. 1 2  // 좋은 예 Set\u0026lt;Student\u0026gt; student = new HashSet\u0026lt;\u0026gt;();   1 2  // 나쁜 예. 클래스 참조 HashSet\u0026lt;Student\u0026gt; student = new HashSet\u0026lt;\u0026gt;();   인터페이스를 활용하면 유연함을 얻을 수 있습니다. 구현체를 교체하고 싶으면 구현 클래스만 바꾸면 됩니다.\n1 2  // HashSet -\u0026gt; LinkedHashSet 교체 Set\u0026lt;Student\u0026gt; student = new LinkedHashSet\u0026lt;\u0026gt;();   하지만 구현체를 바꿀 경우 주의할 점이 있습니다. 기존 구현체만의 특별한 기능을 제공하는 게 있다면, 바꿀 구현체에도 있는지 혹은 사이드 이펙트도 충분히 고려해야 합니다.","title":""},{"content":"[아이템 65] 리플렉션보다는 인터페이스를 사용하라. 리플렉션 기능을 활용하면 클래스에 접근 할 수 있습니다. Class객체가 주어지면 생성자, 메서드, 필드에 해당하는 Consturct, Method, Field 인스턴스를 가져올 수 있고 그 인스턴스들로는 그 클래스의 시그니처 등을 가져올 수 있습니다.\nMethod.invoke는 어떤 클래스의 어떤 객체가 가진 어떤 메서드라도 호출할 수 있게 해줍니다 물론 장점만있는 건 아닙니다. 단점은 다음과 같습니다.\n 컴파일타임 타입 검사가 주는 이점을 하나도 누릴 수 없다. 예외 검사도 마찬가지입니다. 리플렉션 기능으로 존재하지 않는 혹은 접근할 수 없는 메서드를 호출하려고하면 런타임 오류가 발생합니다. 리플렉션을 이용하면 코드가 지저분하고 장황해진다. 성능이 떨어진다. 리플렉션을 통한 메서드 호출은 일반 메서드 호출보다 느립니다.  단점이 명백하게 존재하기 때문에 리플렉션을 써야하는 복잡한 애플리케이션도 리플렉션 사용을 점차 줄이고 있습니다. 컴파일 타임에 이용할 수 없는 클래스를 사용해야만 하는 프로그램은 비록 컴파일타임이라도 적절한 인터페이스나 상위 클래스를 이용할 수는 있을 것입니다. 이런 경우라면 리플렉션은 인스턴스 생성에만 쓰고, 이렇게 만든 인스턴스는 인터페이스나 상위 클래스로 참조해 사용합시다. 리플렉션은 컴파일타임에는 알 수 없는 클래스를 사용하는 프로그램을 작성한다면 리플렉션을 사용해야할 것입니다. 하지만 되도록 객체 생성에만 사용고 생성한 객체를 이용할 때는 적절한 인터페이스나 컴파일타임에 알 수 있는 상위 클래스로 형변환해서 사용해야 합니다.\n","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-08/item65/","summary":"[아이템 65] 리플렉션보다는 인터페이스를 사용하라. 리플렉션 기능을 활용하면 클래스에 접근 할 수 있습니다. Class객체가 주어지면 생성자, 메서드, 필드에 해당하는 Consturct, Method, Field 인스턴스를 가져올 수 있고 그 인스턴스들로는 그 클래스의 시그니처 등을 가져올 수 있습니다.\nMethod.invoke는 어떤 클래스의 어떤 객체가 가진 어떤 메서드라도 호출할 수 있게 해줍니다 물론 장점만있는 건 아닙니다. 단점은 다음과 같습니다.\n 컴파일타임 타입 검사가 주는 이점을 하나도 누릴 수 없다. 예외 검사도 마찬가지입니다. 리플렉션 기능으로 존재하지 않는 혹은 접근할 수 없는 메서드를 호출하려고하면 런타임 오류가 발생합니다.","title":""},{"content":"[아이템 66] 네이티브 메서드는 신중히 사용하라. 자바 네이티브 인터페이스는 자바 프로그램이 네이티브 메서드를 호출하는 기술입니다. 네이티브 메서드란 C나 C++같읕 네이비티브 프로그래밍 언어로 작성한 메서드를 말합니다. 네이티브 메서드의 주요 쓰임은 세 가지가 있습니다.\n 레지스트리 같은 플랫폼 특화 기능을 사용한다. 네이티브 코드로 작성된 기존 라이브러리를 사용한다. 성능 개선을 목적으로 성능에 결정적인 영향을 주는 영역만 따로 네이티브 언어로 작성한다.  자바 9부터는 process API를 추가해 OS 프로세스에 접근하는 길을 열어주었고 자바에서 네이티브 메서드를 사용할 필요가 점점 줄어드는 추세입니다. 성능 개선을 목적으로 네이티브 메서드를 사용하는 건 권장하지 않습니다. JVM이 많이 발전한 덕에 속도가 굉장히 빨라졌기 떄문입니다. 또한 네이티브 언어가 안전하지 않으므로 네이티브 메서들 사용하는 애플리케이션도 메모리 훼손 오류로부터 안전하지 않습니다. 가비지 컬렉터가 네이티브 메모리는 자동 회수하지 못하고 추적 조차할 수 없습니다.\n","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-08/item66/","summary":"[아이템 66] 네이티브 메서드는 신중히 사용하라. 자바 네이티브 인터페이스는 자바 프로그램이 네이티브 메서드를 호출하는 기술입니다. 네이티브 메서드란 C나 C++같읕 네이비티브 프로그래밍 언어로 작성한 메서드를 말합니다. 네이티브 메서드의 주요 쓰임은 세 가지가 있습니다.\n 레지스트리 같은 플랫폼 특화 기능을 사용한다. 네이티브 코드로 작성된 기존 라이브러리를 사용한다. 성능 개선을 목적으로 성능에 결정적인 영향을 주는 영역만 따로 네이티브 언어로 작성한다.  자바 9부터는 process API를 추가해 OS 프로세스에 접근하는 길을 열어주었고 자바에서 네이티브 메서드를 사용할 필요가 점점 줄어드는 추세입니다.","title":""},{"content":"[아이템 67] 최적화는 신중히 하라. 최적화는 좋은 결과보다 해로운 결과로 이어지기 쉽고, 자칫하면 빠르지도 않고 제대로 동작하지 않는 소프트웨어를 탄생시키는 것과 같습니다. 그러므로 최적화 할때는 득과실을 잘 생각해봐야 합니다.\n성능을 제한하는 설계를 피하라 완성 후 변경하기가 가장 어려운 설계 요소는 바로 컴포넌트끼리 혹은 외부 시스템과의 소통 방식입니다. 대표적으로 API, 네트워크 프로토콜 등이 있습ㄴ디ㅏ. 이런 설계 요소들은 완성 후에는 변경하기 어려우며 동시에 시스템 성능을 심각하게 제한할 수 있습니다.\nAPI 설계할 때 성능에 주는 영향을 고려하라. public 타입을 가변으로 만들면 불필요한 방어적 복사를 유발할 수 있습니다. 또한 상속 방식으로 설계한 pulblic 클래스는 상위 클래스에 영원히 종석되며 성능 제약까지 물려받습니다.\n","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-08/item67/","summary":"[아이템 67] 최적화는 신중히 하라. 최적화는 좋은 결과보다 해로운 결과로 이어지기 쉽고, 자칫하면 빠르지도 않고 제대로 동작하지 않는 소프트웨어를 탄생시키는 것과 같습니다. 그러므로 최적화 할때는 득과실을 잘 생각해봐야 합니다.\n성능을 제한하는 설계를 피하라 완성 후 변경하기가 가장 어려운 설계 요소는 바로 컴포넌트끼리 혹은 외부 시스템과의 소통 방식입니다. 대표적으로 API, 네트워크 프로토콜 등이 있습ㄴ디ㅏ. 이런 설계 요소들은 완성 후에는 변경하기 어려우며 동시에 시스템 성능을 심각하게 제한할 수 있습니다.\nAPI 설계할 때 성능에 주는 영향을 고려하라.","title":""},{"content":"[아이템 68] 일반적으로 통용되는 명명 규칙을 따르라. 자바이 명명 규칙은 크게 철자와 문법, 두 범주로 나뉘고 명명 규칙을 지켜야 좋은 프로그래밍이 될 수 있습니다. 대표적으로 메서드와 필드 내임의 첫 글자는 소문자를 사용합니다. 하지만 상수 필드의 경우 예외입니다. 상수는 모두 대무자를 이용하며 단어 사이는 _로 구분 합니다. ex)MAX_VALUE.. 상수 필드는 값이 static final 필드를 말합니다. 타입 매개변수 같은 경우 한 문자로 표현되며, 임의의 타입에는 T를, 컬렉션 원소의 타입은 E, 맵의 키와 값에는 K, V를, 예외는 X, 메서드의 반환 타입에는 R을 사용합니다. 그 외에 임의 타입 시퀀스에는 T, U, V 혹은 T1,T2,T3를 사용합니다.\n객체를 생성할 수 있는 클래스의 이름은 보통 명사나 명사구를 사용합니다. 객체를 만들 수 없는 클래스의 이름은 보통 복수형 명사로 짓습니다. 인터페이스 같은 경우 클래스랑 똑같이 짓거나 able 혹은 ible로 끝나는 형용사로 짓습니다.\n동작을 수행하는 메서드의 이름은 동사나 동사구로 짓습니다(append, drawImage). boolean을 반환하는 메서드는 is로 시작하고 명사구, 혹은 형용사로 기능하는 아무단어나 구로 끝나도록 짓습니다. 반환 타입이 해당 인스턴스의 속성을 반환하는 메서드는 보통 명사, 명사구, 혹은 get으로 시작하는 동사구로 짓습니다. get으로 시작하는 형태는 주로 자바빈즈 명세에 뿌리를 두고 있습니다.\n","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-08/item68/","summary":"[아이템 68] 일반적으로 통용되는 명명 규칙을 따르라. 자바이 명명 규칙은 크게 철자와 문법, 두 범주로 나뉘고 명명 규칙을 지켜야 좋은 프로그래밍이 될 수 있습니다. 대표적으로 메서드와 필드 내임의 첫 글자는 소문자를 사용합니다. 하지만 상수 필드의 경우 예외입니다. 상수는 모두 대무자를 이용하며 단어 사이는 _로 구분 합니다. ex)MAX_VALUE.. 상수 필드는 값이 static final 필드를 말합니다. 타입 매개변수 같은 경우 한 문자로 표현되며, 임의의 타입에는 T를, 컬렉션 원소의 타입은 E, 맵의 키와 값에는 K, V를, 예외는 X, 메서드의 반환 타입에는 R을 사용합니다.","title":""},{"content":"[아이템 69] 예외는 진짜 예외 상황에서만 사용하라. 예외는 반드시 예외 상황에서만 사용해야한다. 일반적인 제어 흐름용으로 사용하면 안 됩니다.\n1 2 3 4 5 6 7 8  try { int i = 0; while (true) { index[i++].doSomething(); } } catch (ArrayIndexOutOfBoundsException) { .. }   코드가 장황하고 직관적이지 않습니다. 성능도 일반적인 제어 흐름보다 느립니다.\n","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-09/item69/","summary":"[아이템 69] 예외는 진짜 예외 상황에서만 사용하라. 예외는 반드시 예외 상황에서만 사용해야한다. 일반적인 제어 흐름용으로 사용하면 안 됩니다.\n1 2 3 4 5 6 7 8  try { int i = 0; while (true) { index[i++].doSomething(); } } catch (ArrayIndexOutOfBoundsException) { .. }   코드가 장황하고 직관적이지 않습니다. 성능도 일반적인 제어 흐름보다 느립니다.","title":""},{"content":"[아이템 70] 복구할 수 있는 상황에서는 검사 예외를, 프로그래밍 오류에는 런타임 예외를 시용하라. 자바에서는 기본적으로 오류는 checked exception, runtime exception, error 이렇게 세 가지로 나눌 수 있습니다. 100% 확실한 건 아니지만 일반적으로 사용하는 상황은 다음과 같습니다.\n호출 하는 쪽에서 복구하리라 여거지는 상황에서는 검사 예외를 사용합시다. 이것이 검사 예외랑 비검사 예외를 구분하는 가장 기본적인 규칙입니다. catch로 잡아서 처리하거나 thorws로 예외를 호출한쪽으로 전파하고 호출했을 때 발생할 수 있는 있다는 걸 API 사용자에게 알리는 것입니다.\n반면 비검사 예외는 잡을 필요가 없습니다. 프로그램에서 비검사 예외를 던졌다는 것은 복구가 불가능 하거나 더 실행하면 득보다 실이 많다는 뜻입니다. 런타임 예외는 프로그래밍 오류를 나타낼떼 사용하는 게 좋습니다. 이러한 런타임 예외는 대부분 제약 조건에 부합하지 않을 때 사용되며 복구가 가능한지 불가능한지 명확히 구분되기 쉽지 않습니다. 만약 확신이 들지 않을 경우는 비검사 예외를 선택하는 게 좋을 것입니다.\n에러는 보통 JVM 자원 부족 등 상황에서 사용합니다. 규약상 Error를 상속해 하위 클래스를 만드는 일은 좋지 않습니다. 비검사 예외를 구현할 때는 모두 RuntionException의 하위클래스 이어야 합니다.\n","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-09/item70/","summary":"[아이템 70] 복구할 수 있는 상황에서는 검사 예외를, 프로그래밍 오류에는 런타임 예외를 시용하라. 자바에서는 기본적으로 오류는 checked exception, runtime exception, error 이렇게 세 가지로 나눌 수 있습니다. 100% 확실한 건 아니지만 일반적으로 사용하는 상황은 다음과 같습니다.\n호출 하는 쪽에서 복구하리라 여거지는 상황에서는 검사 예외를 사용합시다. 이것이 검사 예외랑 비검사 예외를 구분하는 가장 기본적인 규칙입니다. catch로 잡아서 처리하거나 thorws로 예외를 호출한쪽으로 전파하고 호출했을 때 발생할 수 있는 있다는 걸 API 사용자에게 알리는 것입니다.","title":""},{"content":"[아이템 71] 필요 없는 검사 예외 사용은 피하라. 검사 예외를 필요한 곳에만 사용하면 프로그램의 안전성을 높여주지만, 과하게 사용하면 오히려 쓰기 불편한 API가 됩니다. API를 제대로 사용해도 발생할 수 있는 예외이거나, 프로그래머가 의미 잇는 조치를 취할 수 있는 경우 둘 중 어디에도 해당하지 않는다면 비검사 예외를 사용하는 것이 좋습니다.\n","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-09/item71/","summary":"[아이템 71] 필요 없는 검사 예외 사용은 피하라. 검사 예외를 필요한 곳에만 사용하면 프로그램의 안전성을 높여주지만, 과하게 사용하면 오히려 쓰기 불편한 API가 됩니다. API를 제대로 사용해도 발생할 수 있는 예외이거나, 프로그래머가 의미 잇는 조치를 취할 수 있는 경우 둘 중 어디에도 해당하지 않는다면 비검사 예외를 사용하는 것이 좋습니다.","title":""},{"content":"[아이템 72] 표준 예외를 사용하라. 자바에서는 기본적으로 다양한 예외를 제공해줍니다. 예외를 만들기 전 먼저 기존 라이브러리를 확인해보는 것이 좋습니다. 기존에 있는 라이브러리를 사용하면 API가 다른 사람이 익히기 쉬워집니다. 또한 예외 클래스가 적어질 수록 메모리 사용량도 줄고 클래스를 적재하는 시간도 적게 걸리기 때문입니다.\nException, RuntimeException, Throwable, Error는 직적 재사용하지 않는 게 좋습니다. 다른 예외들의 상위 클래스이므로 즉 여러 예외를 포괄하기 때문에 안정적으로 테스트할 수 없습니다.\n","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-09/item72/","summary":"[아이템 72] 표준 예외를 사용하라. 자바에서는 기본적으로 다양한 예외를 제공해줍니다. 예외를 만들기 전 먼저 기존 라이브러리를 확인해보는 것이 좋습니다. 기존에 있는 라이브러리를 사용하면 API가 다른 사람이 익히기 쉬워집니다. 또한 예외 클래스가 적어질 수록 메모리 사용량도 줄고 클래스를 적재하는 시간도 적게 걸리기 때문입니다.\nException, RuntimeException, Throwable, Error는 직적 재사용하지 않는 게 좋습니다. 다른 예외들의 상위 클래스이므로 즉 여러 예외를 포괄하기 때문에 안정적으로 테스트할 수 없습니다.","title":""},{"content":"[아이템 73] 추상화 수준에 맞는 예외를 던져라. 메서드가 저수준 예외를 처리하지 않고 바깥으로 전파해버릴 경우 예상치 못한 예외를 접하고 당황할 수가 있습니다. 이 문제를 피하려면 상위 계층에서 저수주 예외를 잡아 자신의 추상화 수준에 맞는 예외를 던져야 합니다. 이를 예외 번역이라 부릅니다.\n1 2 3 4 5 6  try { ... } catch (LowLevelException e) { // 추상화 수준에 맞게 번역.  throw new HighLevelException(..); }   AbstractSequentialList에서 수행하는 예외번역의 예시\n1 2 3 4 5 6 7  public E get(int index) { try { return listIterator(index).next(); } catch (NoSuchElementException exc) { throw new IndexOutOfBoundsException(\u0026#34;Index: \u0026#34;+index); } }   예외 번역을 할 때, 저수준 예외가 디버깅에 도움이 된다면 예외 연쇄룰 사용하는게 좋습니다. 예외 연쇄란 근본 원인인 저수준 예외를 고수준 예외에 실어 보내는 방식입니다. 그러면 별도의 접근자 메서드(Throwable의 getCause 메서드)를 통해 필요하면 저수준 예외를 꺼내 볼 수 도 있습니다.\n1 2 3 4 5 6  try { ... // 저수준 추상화를 이용한다.  } catch (LowerLevelException cause) { throw new HigherLevelException(cause); }   대부분 표준 예외는 예외 연쇄용 생성자를 갖추고 있습니다. 예외 연쇄는 문제의 원인을 프로그램에서 접근할 수 있게 해주며, 고수준 예외의 스택 추적 정보를 잘 통합해줍니다. 그렇다고 남용하지는 맙시다. 가능한 저수준 메서드가 반드시 성공하도록 하여 아래 계층에서 예외가 발생하지 않도록 하는 것이 베스트입니다.\n","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-09/item73/","summary":"[아이템 73] 추상화 수준에 맞는 예외를 던져라. 메서드가 저수준 예외를 처리하지 않고 바깥으로 전파해버릴 경우 예상치 못한 예외를 접하고 당황할 수가 있습니다. 이 문제를 피하려면 상위 계층에서 저수주 예외를 잡아 자신의 추상화 수준에 맞는 예외를 던져야 합니다. 이를 예외 번역이라 부릅니다.\n1 2 3 4 5 6  try { ... } catch (LowLevelException e) { // 추상화 수준에 맞게 번역.  throw new HighLevelException(..); }   AbstractSequentialList에서 수행하는 예외번역의 예시","title":""},{"content":"[아이템 74] 메서드가 던지는 모든 예외를 문서화하라. 검사 예외는 항상 따로따로 선언하고, 각 예외가 발생하는 상황을 자바독의 @throws 태그를 사용하여 정확히 문서화를 합시다. 상위 클래스 하나로 선언하는 일은 삼가는 게 좋습니다. 어떤 예외를 호출하는지 명확하게 알 수 없고, 같은 맥락에서 다른 예외가 발생할 여지가 있을 경우 이러한 것까지 다 삼켜버릴 수 있기 때문입니다. 비검사 예외 같은 경우 메서드 선언에 throws를 넣는 건 권장하지 않습니다. 검사냐 비검사냐에 따라 API 사용자가 할 일이 달라지므로 이 둘은 확실히 구분해두는 것이 좋습니다.\n","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-09/item74/","summary":"[아이템 74] 메서드가 던지는 모든 예외를 문서화하라. 검사 예외는 항상 따로따로 선언하고, 각 예외가 발생하는 상황을 자바독의 @throws 태그를 사용하여 정확히 문서화를 합시다. 상위 클래스 하나로 선언하는 일은 삼가는 게 좋습니다. 어떤 예외를 호출하는지 명확하게 알 수 없고, 같은 맥락에서 다른 예외가 발생할 여지가 있을 경우 이러한 것까지 다 삼켜버릴 수 있기 때문입니다. 비검사 예외 같은 경우 메서드 선언에 throws를 넣는 건 권장하지 않습니다. 검사냐 비검사냐에 따라 API 사용자가 할 일이 달라지므로 이 둘은 확실히 구분해두는 것이 좋습니다.","title":""},{"content":"[아이템 75] 예외 상세 메시지에 실패 관련 정보를 담으라. 스택 트레이스는 예외 객체의 toString 메서드를 호출해 얻는 문자열입니다. toString 메서드에 발생 원인에 대한 정보는 가능한 많을 수록 좋습니다. 물론 장황하지 않고 필요한 정보만 담는 것입니다. 가장 좋은 건 발생한 예외에 관여된 모든 매개변수와 필드의 값을 실패 메세지에 담는 것입니다. 물론 보안관 관련된 정보는 유의해서 다루어야 합니다.\nex) IndexOutOfBoundsException의 상세 메세지에는 범위의 최솟값, 최댓값, 범위를 벗어난 인덱스의 값을 담는 것입니다.\n","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-09/item75/","summary":"[아이템 75] 예외 상세 메시지에 실패 관련 정보를 담으라. 스택 트레이스는 예외 객체의 toString 메서드를 호출해 얻는 문자열입니다. toString 메서드에 발생 원인에 대한 정보는 가능한 많을 수록 좋습니다. 물론 장황하지 않고 필요한 정보만 담는 것입니다. 가장 좋은 건 발생한 예외에 관여된 모든 매개변수와 필드의 값을 실패 메세지에 담는 것입니다. 물론 보안관 관련된 정보는 유의해서 다루어야 합니다.\nex) IndexOutOfBoundsException의 상세 메세지에는 범위의 최솟값, 최댓값, 범위를 벗어난 인덱스의 값을 담는 것입니다.","title":""},{"content":"[아이템 76] 가능한 한 실패 원자적으로 만들라. 여기서 말하는 실패 원자적이란 호출한 메서드가 실패하더라도 해당 객체는 호출 전 상태로 유지되는 것입니다. 가장 간단한 방법은 불변 객채로 설계하는 것입니다. 가변 객체일 경우 작업 수행 전에 유효성을 검사합는 것입니다.\n1 2 3 4 5 6 7 8  public Object pop() { if (size == 0) { throw new EmptyStachException(); } Object result = el[--size]; el[size] = null; // 참조 해제  return result; }   유효성 검사하는 부분이 없어도 ArrayOutOfBoundsException을 던지지만 이는 추상화 수준에 상황에 어울리지 않습니다.\n","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-09/item76/","summary":"[아이템 76] 가능한 한 실패 원자적으로 만들라. 여기서 말하는 실패 원자적이란 호출한 메서드가 실패하더라도 해당 객체는 호출 전 상태로 유지되는 것입니다. 가장 간단한 방법은 불변 객채로 설계하는 것입니다. 가변 객체일 경우 작업 수행 전에 유효성을 검사합는 것입니다.\n1 2 3 4 5 6 7 8  public Object pop() { if (size == 0) { throw new EmptyStachException(); } Object result = el[--size]; el[size] = null; // 참조 해제  return result; }   유효성 검사하는 부분이 없어도 ArrayOutOfBoundsException을 던지지만 이는 추상화 수준에 상황에 어울리지 않습니다.","title":""},{"content":"[아이템 77] 예외를 무시하지 마라. 발생할 수 있는 실수\n1 2 3 4 5  try { ... } catch (IllegalArgumentException e){ }   초보 프로그래머가 할 수 있는 실수입니다. catch 블록에서 아무것도 하지 않으면 catch가 존재할 이유가 없어지는 것과 마찬가지입니다. 예외가 발생허더라도 계속 지나칠 수 있습니다. 이는 심각한 결함으로 이어질 수 있습니다. 만약 예외를 무시하기로 결정한 부분이라면 IllegalArgumentException ignored로 바꿔놓는 것이 좋습니다.\n","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-09/item77/","summary":"[아이템 77] 예외를 무시하지 마라. 발생할 수 있는 실수\n1 2 3 4 5  try { ... } catch (IllegalArgumentException e){ }   초보 프로그래머가 할 수 있는 실수입니다. catch 블록에서 아무것도 하지 않으면 catch가 존재할 이유가 없어지는 것과 마찬가지입니다. 예외가 발생허더라도 계속 지나칠 수 있습니다. 이는 심각한 결함으로 이어질 수 있습니다. 만약 예외를 무시하기로 결정한 부분이라면 IllegalArgumentException ignored로 바꿔놓는 것이 좋습니다.","title":""},{"content":"[아이템 78] 공유중인 가변 데이터는 동기화해 사용하라. 동기화란 특정 메서드나 블럭에 한 쓰레드가 접근했을 때, 해당 객체에 락을 걸고 다른 쓰레드가 접근하지 못하도록 하는 것이다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  public class StopThread { private static boolean stopRequested; public static void main(String[] args) throws InterruptedException { Thread backgroundThread = new Thread(() -\u0026gt; { int i = 0; while (!stopRequested) i++; }); backgroundThread.start(); TimeUnit.SECONDS.sleep(1); stopRequested = true; } }   메인 스레드가 1초 후 stopRequested를 true로 설정하고 반복문을 빠져나올 거락 생각할 수 있지만, 끝나지 않고 계속 실행됩니다.원인은 동기화에 있습니다. 동기화 하지 않으면 메인 스레드가 수정한 값을 백그라운드 스레드가 언제쯤에나 보게 될지 보증할 수 없습니다.\nstopRequested 필드를 동기화해 접근하면 이 문제를 해결할 수 있습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  // 정상적으로 종료한다. public class StopThread { private static boolean stopRequested; private static synchronized void requestStop() { stopRequested = true; } private static synchronized boolean stopRequested() { return stopRequested; } public static void main(String[] args) throws InterruptedException { Thread backgroundThread = new Thread(() -\u0026gt; { int i = 0; while (!stopRequested()) i++; }); backgroundThread.start(); TimeUnit.SECONDS.sleep(1); requestStop(); } }   쓰기와 읽기 모두가 동기화 되지 않으면 동작을 보장하지 않습니다. volatile으로 필드를 선언하면 동기화를 생략해도 되고, 속도가 더 빠릅니다. volatile 한정자는 배타적 수행과는 상관없자먼 항상 최근에 기록된 값을 읽게 됨을 보장합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  public class StopThread { private static volatile boolean stopRequested; public static void main(String[] args) throws InterruptedException { Thread backgroundThread = new Thread(() -\u0026gt; { int i = 0; while (!stopRequested) i++; }); backgroundThread.start(); TimeUnit.SECONDS.sleep(1); stopRequested = true; } }   하지만 volatile를 사용할 때도 주의할 점이 있습니다.\n1 2 3 4 5  public static volatile int num = 0; public static int gernerateNum() { return num++; }   num필드는 원자적으로 접근할 수 있고 어떤 값이든 허용한다. 문제는 ++연산자인데 numgernerateNum는 필드에 두 번 접근한다. 먼저 값을 읽고, 그 다음에 1증가한 값을 저장하는 것이다. 이 두 접근 사이에 다른 스레드가 들어와 값을 읽을 경우 첫번째 스레드와 똑같은 값을 돌려받게 되다. 프로그램이 잘못된 결과를 계사해내는 이런 오류를 safety failure라고 한다.\n이러한 문제점들에 벗어나느 가장 좋은 방법은 가변 데이터를 공유하지 않는 것이다. 한 스레드가 데이터를 다 수정한 후 다른 스레드에 공유할 때는 해당 객체에서 공유하는 부분만 동기화해도 된다. 그럼 그 객체는 다시 수정할 일이 생기기 전까지 다른 스레드들은 동기화 없이 자유롭게 값을 이어갈 수 있다. 이러한 객체를 effective immutable이라 하며, 다른 스레드에 이런 객체를 건내는 행위는 safe publication이라 한다. 객체를 안전하게 발행하는 방법은 많다. 클래스 초기화 과정에서 객체를 정적 필드, volatile 필드, final 필드, 혹은 보통릐 락을 통해 접근하는 필드에 저장해도 되고 동시성 컬렉션에 저장하는 방법도 있다.\n","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-10/item78/","summary":"[아이템 78] 공유중인 가변 데이터는 동기화해 사용하라. 동기화란 특정 메서드나 블럭에 한 쓰레드가 접근했을 때, 해당 객체에 락을 걸고 다른 쓰레드가 접근하지 못하도록 하는 것이다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  public class StopThread { private static boolean stopRequested; public static void main(String[] args) throws InterruptedException { Thread backgroundThread = new Thread(() -\u0026gt; { int i = 0; while (!","title":""},{"content":"[Itemm 79] 과도한 동기화는 피하라. 과도한 동기화는 성능을 저하시키고 교차상태에 빠뜨릴 수 있다.\nliveness, safety failures를 피하려면 동기화 메서드나 동기화 블록 안에서는 제어를 절대로 클라이언트에게 양보하면 안 된다. ex) 동기화된 영역 안에서 재정의할 수 있는 메서드 호출 x, 클라이언트가 념겨준 함수 객체 호출 x\n과도한 동기화는 성능을을 저하 시킨다. 가변 클래스를 작성하거든 동기화를 전혀 하지 말고, 그 클래스를 동시에 사용해야 하는 클래스가 외부에서 알아서 동기화 하게 하던가, 동기화를 내부에서 수행해 스레드 안전한 클래스로 만들자. 단 클라이언트가 외부에서 객체 전체에 락을 거는 것보다 동시성을 월등히 개선할 수 있을 때만 후자를 택해라. java.util은 첫번째 방식을 택했고 java.util.concurrent는 두 번째 방식을 취했다.\n","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-10/item79/","summary":"[Itemm 79] 과도한 동기화는 피하라. 과도한 동기화는 성능을 저하시키고 교차상태에 빠뜨릴 수 있다.\nliveness, safety failures를 피하려면 동기화 메서드나 동기화 블록 안에서는 제어를 절대로 클라이언트에게 양보하면 안 된다. ex) 동기화된 영역 안에서 재정의할 수 있는 메서드 호출 x, 클라이언트가 념겨준 함수 객체 호출 x\n과도한 동기화는 성능을을 저하 시킨다. 가변 클래스를 작성하거든 동기화를 전혀 하지 말고, 그 클래스를 동시에 사용해야 하는 클래스가 외부에서 알아서 동기화 하게 하던가, 동기화를 내부에서 수행해 스레드 안전한 클래스로 만들자.","title":""},{"content":"[아이템 80] 스레드보다는 실행자, 태스크, 스트림을 애용하라. Excutor Framework는 인터페이스 기반의 유연한 태스크 실행 기능을 담고 있다.\n1 2 3  ExecutorService exec = Executors.newSingleThreadExecutor(); exec.excute(runnable); // 이 실행자에게 task를 넘김 exec.shutdown(); // graceful하게 종료 (이 작업이 실패하면 VM 자체가 종료되지 않을 것)   이 외에도 다양한 기능을 실행할 수 있다. 실행자 서비스를 사용하기에 까다로운 애플리케이션도 있는데, 가벼운 서버라면 Executors.newCachedThreadPool이 일반적으로 좋은 선택이지만 CachedThreadPool은 무거운 프로덕션 서버에는 좋지 못하다. CachedThreadPool에서는 요청받은 태스크들이 큐에 쌓이지 않고 즉시 스레드에 위임돼 실행한다 가용한 스레드가 없다면 새로 하나를 생성한다, 서버가 무거울 경우 CPU 이용률이 100%로 치닫고, 새로운 태스크가 도착하는 족족 또 다른 스레드를 생성해 상황을 악화시킨다.\n따라서 무거운 프로덕션 서버에서는 Executors.newFixedThreadPool이나 완전히통재할 수 있는 ThreadPoolExecutor를 직접 사용하는 편이 좋다.\n","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-10/item80/","summary":"[아이템 80] 스레드보다는 실행자, 태스크, 스트림을 애용하라. Excutor Framework는 인터페이스 기반의 유연한 태스크 실행 기능을 담고 있다.\n1 2 3  ExecutorService exec = Executors.newSingleThreadExecutor(); exec.excute(runnable); // 이 실행자에게 task를 넘김 exec.shutdown(); // graceful하게 종료 (이 작업이 실패하면 VM 자체가 종료되지 않을 것)   이 외에도 다양한 기능을 실행할 수 있다. 실행자 서비스를 사용하기에 까다로운 애플리케이션도 있는데, 가벼운 서버라면 Executors.newCachedThreadPool이 일반적으로 좋은 선택이지만 CachedThreadPool은 무거운 프로덕션 서버에는 좋지 못하다. CachedThreadPool에서는 요청받은 태스크들이 큐에 쌓이지 않고 즉시 스레드에 위임돼 실행한다 가용한 스레드가 없다면 새로 하나를 생성한다, 서버가 무거울 경우 CPU 이용률이 100%로 치닫고, 새로운 태스크가 도착하는 족족 또 다른 스레드를 생성해 상황을 악화시킨다.","title":""},{"content":"[아이템 81] wait와 notify보다는 동시성 유틸리티를 애용하라. wait와 notify는 올바르게 사용하기가 아주 까다로우니 고수준 동시성 유틸리티를 사용하라.\njava.util.concurrent의 고수준 유틸리티는 세 범주로 나눌 수 있다.\n 실헹자 프레임워크 동시성 컬렉션 동기화 장치  동시성 컬렉션은 높은 동시성에 도달하기 위해 동기화를 각자의 내부에서 구현한다. 따라서 컬렉션에서 동기성을 무력화하는 건 불가능하며 외부에서 락을 추가로 사용하면 속도가 느려진다.\n동시성을 무력화하지 못하므로 여러 메서드를 원자적으로 묶어 호출하는 건 불가능하다. 그레서 여러 기본 동작을 하나의 원자적 동작으로 묶는 \u0026lsquo;상태 의존적 수정\u0026rsquo; 메서드들이 추가되었다. 이 메서드들은 유용하여 자바 8에서는 일반 컬렉션 인터페이스에더 디폴트 메서드로 추가되었다.\n자주 쓰이는 동기화 장치는 CountDownLatch, Semaphore, Phaser가 있습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  // 동시에 실행 시간을 재는 간단한 프레임워크 (wait, notify만으로 구현하려면 난해해진다)  public static long time(Executor executor, int concurrency, Runnable action) throws InterruptedException { CountDownLatch ready = new CountDownLatch(concurrency); CountDownLatch start = new CountDownLatch(1); CountDownLatch done = new CountDownLatch(concurrency); for (int i = 0; i \u0026lt; concurrency; i++) { executor.execute(() -\u0026gt; { // 타이머에 준비를 마쳤음을 알린다.  ready.countDown(); try { // 모든 작업자 스레드가 준비될 때까지 기다린다.  start.await(); action.run(); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } finally { // 타이머에게 작업을 마쳤음을 알린다.  done.countDown(); } }); } ready.await(); // 모든 작업자가 준비될 때까지 기다린다.  long startNanos = System.nanoTime(); start.countDown(); // 작업자들을 깨운다.  done.await(); // 모든 작업자가 일을 끝마치기를 기다린다.  return System.nanoTime() - startNanos; }   time 메서드에 넘긴 실행자는 concurrency 매개변수로 지정한 동시성 수준만큼 스레드를 생성할 수 있어야 한다. 그렇지 못하면 이 메서드는 결코 끝나지 않을 것이고 이럴 상태를 스레드 기아 교착상태(thread starvation deadlock)라 한다.\n","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-10/item81/","summary":"[아이템 81] wait와 notify보다는 동시성 유틸리티를 애용하라. wait와 notify는 올바르게 사용하기가 아주 까다로우니 고수준 동시성 유틸리티를 사용하라.\njava.util.concurrent의 고수준 유틸리티는 세 범주로 나눌 수 있다.\n 실헹자 프레임워크 동시성 컬렉션 동기화 장치  동시성 컬렉션은 높은 동시성에 도달하기 위해 동기화를 각자의 내부에서 구현한다. 따라서 컬렉션에서 동기성을 무력화하는 건 불가능하며 외부에서 락을 추가로 사용하면 속도가 느려진다.\n동시성을 무력화하지 못하므로 여러 메서드를 원자적으로 묶어 호출하는 건 불가능하다. 그레서 여러 기본 동작을 하나의 원자적 동작으로 묶는 \u0026lsquo;상태 의존적 수정\u0026rsquo; 메서드들이 추가되었다.","title":""},{"content":"[아이템 82] 스레드 안전성 수준을 문서화하라. 일반적으로 스레드 안정성이 높은 순\n 불변: 외부 동기화가 필요없다. 대표적으로 String, Long, BigInteger 무조건적 스레드 안전: 이 클래스의 인스턴스는 수정될 수 있으나, 내부에서 충실히 동기화하여 별도의 외부 동기화 없이 사용해도 안전 대표적으로 ConcurrentHashMap 조건부 스레드 안전: 일부 메서드는 동시에 사용하려면 외부 동기화가 필요. Collections.synchronized 래퍼 메서드가 반환한 컬렉션이 여기 속함 스레드 비안전: 동시에 시용하려면 메서드 호출을 클라이언트가 선택한 외부 동기화 메커니즘으로 감싸야한다. ArrayList, HashMap 같은 기본 컬렉션. 스레드 적대적: 이 클래스는 모든 메서드 호출을 외부 동기화로 감싸더라도 멀티스레드 환경에서 안전하지 않다.  모든 클래스가 자신의 스레드 안전성 정보를 명확하게 문서화 해야한다. 애너테이션을 활용할 수도 있다. synchronized 한정자는 문서화랑 관련이 없다. 구현 이슈일 뿐 API에 속하지 않기 떄문이다.\n","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-10/item82/","summary":"[아이템 82] 스레드 안전성 수준을 문서화하라. 일반적으로 스레드 안정성이 높은 순\n 불변: 외부 동기화가 필요없다. 대표적으로 String, Long, BigInteger 무조건적 스레드 안전: 이 클래스의 인스턴스는 수정될 수 있으나, 내부에서 충실히 동기화하여 별도의 외부 동기화 없이 사용해도 안전 대표적으로 ConcurrentHashMap 조건부 스레드 안전: 일부 메서드는 동시에 사용하려면 외부 동기화가 필요. Collections.synchronized 래퍼 메서드가 반환한 컬렉션이 여기 속함 스레드 비안전: 동시에 시용하려면 메서드 호출을 클라이언트가 선택한 외부 동기화 메커니즘으로 감싸야한다. ArrayList, HashMap 같은 기본 컬렉션.","title":""},{"content":"[아이템 83] 지연 초기화는 신중히 사용하라. 지연 초기화는 필드의 초기화 시점을 그 값이 처음 필요햔 시점까지 늦추는 것이다. 지연 초기화는 인스턴스 생성시 초기화 비용을 줄일 수 있지만, 지연 초기화하는 필드에 접근하는 비용은 커진다. 지연 초기화를 잘못사용하면 실제로 성능이 더 느려질 수도 있다.\n멀티 스레드 환경에서 지연 초기화를 하기에는 까다롭다. 지연 초기화하는 필드를 둘 이상 스레드가 공유한다면 동기화해야 한다. 일반적으로 일반적인 초기화가 지연 초기화보다 낫다.\n1 2  // 인스턴스 필드를 초기화하는 일반적인 방법 private final FieldType field = computerFieldValue();   1 2 3 4 5 6 7 8 9  // 지연 초기화 - sychronized 방식 private FieldType field; private sychronized FieldType getField() { if (field == null) { field = computerFieldValue(); } return field; }   1 2 3 4 5 6 7 8  // 정적 필드용 지연 초기화 홀더 클래스 관용구 private static class FieldHolder { static final FieldType field = computerFieldValue(); } private static FieldType getField() { return FieldHolder.field(); }   getField가 호출되는 순간 FieldHolder.field가 처음 읽히면서 FieldHolder 클래스 초기화를 촉발한다. 일반적인 VM은 클래스를 초기화 할때만 필드 접근을 동기화할 것이다. 클래스 초기화가 끝난 후에는 VM이 동기화 코드를 제거하여, 그 다음부터는 아무런 검사나 동기화 없이 필드에 접근하게 된다.\n성능 때문에 인스턴스 필드를 지연 초기화 한다면 이중검사 관용구를 사용하라. 한 번은 동기화 없이 검사하고 두 번째는 동기화하여 검사한다. 두 번째 검사에서 필드가 초기화되지 않았을 때만 초기화한다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  private volatile FieldType fieldType; private FieldType getFieldType() { FieldType result = fieldType; if (result != null) { // 첫 번째 검사 (락 사용 x)  return result; } synchronized (this) { if (fieldType == null) { // 두 번째 검사 (락 사용)  fieldType = computerFieldValue(); } return fieldType; } }   ","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-10/item83/","summary":"[아이템 83] 지연 초기화는 신중히 사용하라. 지연 초기화는 필드의 초기화 시점을 그 값이 처음 필요햔 시점까지 늦추는 것이다. 지연 초기화는 인스턴스 생성시 초기화 비용을 줄일 수 있지만, 지연 초기화하는 필드에 접근하는 비용은 커진다. 지연 초기화를 잘못사용하면 실제로 성능이 더 느려질 수도 있다.\n멀티 스레드 환경에서 지연 초기화를 하기에는 까다롭다. 지연 초기화하는 필드를 둘 이상 스레드가 공유한다면 동기화해야 한다. 일반적으로 일반적인 초기화가 지연 초기화보다 낫다.\n1 2  // 인스턴스 필드를 초기화하는 일반적인 방법 private final FieldType field = computerFieldValue();   1 2 3 4 5 6 7 8 9  // 지연 초기화 - sychronized 방식 private FieldType field; private sychronized FieldType getField() { if (field == null) { field = computerFieldValue(); } return field; }   1 2 3 4 5 6 7 8  // 정적 필드용 지연 초기화 홀더 클래스 관용구 private static class FieldHolder { static final FieldType field = computerFieldValue(); } private static FieldType getField() { return FieldHolder.","title":""},{"content":"[아이템 84] 프로그램의 동작을 스레드 스케줄러에 기대지 말라. 구체적인 스케줄링 정책은 운영체제 마다 다를 수 있다. 따라서 이 정책에 죄지우지 되면 안 된다. 실행 가능한 스레드의 평균적인 수를 프로세스 수보다 지나치게 많아지지 않도록 하는 것이 좋은 프로그래램이다. 그래야 스케줄러가 고민할 거리가 줄기 때문이다.\n","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-10/item84/","summary":"[아이템 84] 프로그램의 동작을 스레드 스케줄러에 기대지 말라. 구체적인 스케줄링 정책은 운영체제 마다 다를 수 있다. 따라서 이 정책에 죄지우지 되면 안 된다. 실행 가능한 스레드의 평균적인 수를 프로세스 수보다 지나치게 많아지지 않도록 하는 것이 좋은 프로그래램이다. 그래야 스케줄러가 고민할 거리가 줄기 때문이다.","title":""},{"content":"[아이템 85] 자바 직렬화의 대안을 찾으라. 자바의 역직렬화에는 치명적인 단점이 있습니다. 신롸할 수 없는 스트림을 역직렬화하면 원격 코드 실행, 서비스 거부 등의 공격으로 이어질 수 있습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  static byte[] bomb() { Set\u0026lt;Object\u0026gt; root = new HashSet\u0026lt;\u0026gt;(); Set\u0026lt;Object\u0026gt; s1 = root; Set\u0026lt;Object\u0026gt; s2 = new HashSet\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; 100; i++) { Set\u0026lt;Object\u0026gt; t1 = new HashSet\u0026lt;\u0026gt;(); Set\u0026lt;Object\u0026gt; t2 = new HashSet\u0026lt;\u0026gt;(); t1.add(\u0026#34;foo\u0026#34;); // t1을 t2와 다르게 만든다  s1.add(t1); s1.add(t2); s2.add(t1); s2.add(t2); s1 = t1; s2 = t2; } return serialize(root); }   이 코드는 끝날 기미가 보이지 않는다. HashSet 인스턴스를 역직렬화 하려면 원소들의 해시코드를 계산해야 하는데 위 코드에서는 hashCode 메서드를 2^100번 넘게 호출해야합니다.\n이러한 문제를 해결하는 가장 좋은 방법은 사용하지 않는 것입니다. 자바 직렬화보다 훨씬 간단하고 문제를 회피할 수 있는 방법으로 JSON과 프로토콜 버퍼가 대표적으로 있습니다.\n","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-11/item85/","summary":"[아이템 85] 자바 직렬화의 대안을 찾으라. 자바의 역직렬화에는 치명적인 단점이 있습니다. 신롸할 수 없는 스트림을 역직렬화하면 원격 코드 실행, 서비스 거부 등의 공격으로 이어질 수 있습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  static byte[] bomb() { Set\u0026lt;Object\u0026gt; root = new HashSet\u0026lt;\u0026gt;(); Set\u0026lt;Object\u0026gt; s1 = root; Set\u0026lt;Object\u0026gt; s2 = new HashSet\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; 100; i++) { Set\u0026lt;Object\u0026gt; t1 = new HashSet\u0026lt;\u0026gt;(); Set\u0026lt;Object\u0026gt; t2 = new HashSet\u0026lt;\u0026gt;(); t1.","title":""},{"content":"[아이템 86] Serializable을 구현할지는 신중히 결정하라. Serializable을 구현하면 릴리스 한 뒤에는 수정하기 어렵습니다. 직렬화 당시 내부 구현 방식에 묶이고, 캡슐화가 깨지는 위험이 있습니다. 직렬화된 클래스는 고유 식별 번호를 부여받는데, serialVersionUID를 명시하지 않으면 런타임에 SHA-1을 적용하여 자동으로 클래스 안에 생성해 넣는데, 클래스의 이름, 멤버 등이 포함됩니다. 그래서 나중에 이들 중 하나를 수정한다면 UID 값도 변하여 호환성이 깨져버립니다.\n1 2 3 4  // 상태가 있고, 확장 가능하고, 직렬화 가능한 클래스용 readObjectNoData 메서드 private void readObjectNoData() throws InvalidObjectException() { throw new InvalidObjectException(\u0026#34;스트림 데이터가 필요합니다\u0026#34;); }   ","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-11/item86/","summary":"[아이템 86] Serializable을 구현할지는 신중히 결정하라. Serializable을 구현하면 릴리스 한 뒤에는 수정하기 어렵습니다. 직렬화 당시 내부 구현 방식에 묶이고, 캡슐화가 깨지는 위험이 있습니다. 직렬화된 클래스는 고유 식별 번호를 부여받는데, serialVersionUID를 명시하지 않으면 런타임에 SHA-1을 적용하여 자동으로 클래스 안에 생성해 넣는데, 클래스의 이름, 멤버 등이 포함됩니다. 그래서 나중에 이들 중 하나를 수정한다면 UID 값도 변하여 호환성이 깨져버립니다.\n1 2 3 4  // 상태가 있고, 확장 가능하고, 직렬화 가능한 클래스용 readObjectNoData 메서드 private void readObjectNoData() throws InvalidObjectException() { throw new InvalidObjectException(\u0026#34;스트림 데이터가 필요합니다\u0026#34;); }   ","title":""},{"content":"[아이템 87] 커스텀 직렬화 형태를 고려해보라. 이상적인 직렬화는 물리적인 모습과 독립된 논리적인 모습을 표현해야한다. 하지만 기본 직렬화 형태는 객체가 포함한 모든 데이터와 그 객체에서부터 시작해 접근할 수 있는 모든 객체를 담아낸다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  public class Name implements Serializable { /* * 성. null이 아니어야 함. * @serial */ private final String lastName; /* * 이름. null이 아니어야 함. * @serial */ private final String firstName; /* * 이름. null이 아니어야 함. * @serial */ private final String middleName; .. }   성명은 논리적으로 이름, 성, 중간이라는 3개의 문자열로 구성되며, 앞 코드의 인스턴스 필드들은 이 논리적 구성요소를 정확히 반영했음.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  // 기본 직렬화 형태에 적합하지 않은 클래스 public final class StringList implements Serializable { private int size = 0; private Entry head = null; private static class Entry implements Serializable { String data; Entry next; Entry previous; } .. }   객체의 물리적 표환과 논리적 표현의 차이가 클 때 기본 직렬화를 사옹하면 발생하는 문제점   공개 API가 현재 내부 표현 방식에 영구히 묶인다. 위 코드에서는 StringList.Entry가 공개 API가 되어버린다. 다음 릴리스에서 내부 표현 방식을 변경하더라도 StringList 클래스는 연결 리스트로 펴현된 입력도 처리할 수 있어야한다.\n  너무 많은 공간을 차지할 수 있다.위 코드에서 직렬화에 필요없는 연결리스트의 모든 엔트리와 연결 정보까지 저장했다.이처럼 직렬화 형태가 너무 커져서 디스크에 저장하거나 네트워크에 전송하는 속도가 느려질 수 있다.\n  시간이 너무 많이 걸릴 수 있다. 직렬화 로직은 객체 그래프의 위상에 관한 정보가 없어서 그래프를 직접 순회해볼 수 밖에 없다.\n  스택 오버플로를 일으킬 수 있다. 기본 직렬화 과정은 객체 그래프를 재귀 순회하는데 크기가 크지 않는 객체 그래프에서도 오버플로를 일으킬 수 있다.\n  StringList를 합리적으로 직렬화려면 리스트가 포함한 문자열의 개수를 적은 뒤, 그 뒤로 문자열을 나열하는 수준이면 된다. 논리적인 구성만 담는 것이다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  public final class StringList implements Serializable { private transient int size = 0; private transient Entry head = null; // 더이상 직렬화 x  private static class Entry { String data; Entry next; Entry previous; } // 지정한 문자열을 이 리스트에 추가  public final void add(String s) { ... } /** * Serialize this {@code StringList} instance. * * @serialData 이 리스트의 크기(포함된 문자열의 개수) 를 기록한 후 ({@code int}), 이어서 모든 원소를(각각은 {@code String})순서대로 기 */ private void writeObject(ObjectOutputStream s) throws IOException { s.defaultWriteObject(); s.writeInt(size); // 모든 원소를 올바른 순서로 기록한  for (Entry e = head; e != null; e = e.next) s.writeObject(e.data); } private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException { s.defaultReadObject(); int numElements = s.readInt(); // 모든 원소를 읽어 이 리스트에 삽입한다  for (int i = 0; i \u0026lt; numElements; i++) add((String) s.readObject()); } .. }   transient이어도 defaultWriteObject, defaultReadObject를 호출해야 한다. 그래야 향후 릴리스에서 trasient가 아닌 인스턴스 필드가 추가되더라도 상호 호환이 되기 때문이다. 기본 직렬화 사용 여부와 상관없이 객체의 전체 상태를 읽는 메서드에 적용해야 하는 동기화 메커니즘을 직렬화에도 적용해야한다.\n1 2 3 4 5  // 기본 직렬화를 사용하는 동기화된 클래스를 위한 writeObject 메서드 private synchronized void writeObject(ObjectOutputStream s) throws IOException { s.defaultWriteObject(); }   writeObject 메서드 안에서 동기화하고 싶으면 클래스의 다른 부분에서 사용하는 락 순서를 똑같이 해야한다. 그렇지 않으면 교착상태에 빠질 수 있다.\n어떤 직렬화 형태를 택하든 직렬화 가능 클래스 모두에 직렬버전 UID를 명시적으로 부여해주자.이렇게 해야 잠재적인 호환성 문제가 사라진다. 성능도 조금 빨라지는데 명시하지 않을 경우 런타임에 UID 값을 생성하는 연산을 수행하기 때문이다. 구버전하고 호환성을 끊으려면 값을 변경해주면 된다.\n","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-11/item87/","summary":"[아이템 87] 커스텀 직렬화 형태를 고려해보라. 이상적인 직렬화는 물리적인 모습과 독립된 논리적인 모습을 표현해야한다. 하지만 기본 직렬화 형태는 객체가 포함한 모든 데이터와 그 객체에서부터 시작해 접근할 수 있는 모든 객체를 담아낸다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  public class Name implements Serializable { /* * 성. null이 아니어야 함. * @serial */ private final String lastName; /* * 이름.","title":""},{"content":"[아이템 88] readObject 메서드는 방어적으로 작성하라. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  // 방어적 복사를 사용하는 불변 클ㄹ스  public final class Period { private final Date start; private final Date end; /** * @param start 시작 시간 * @param end 종료 시각. 시작 시간보다 뒤어야 한다 * @throws IllegalArgumentException 시작 시간이 종료 시간보다 늦을 때 발생한다 * @throws NullPointerException start나 end가 null일시 발생 */ public Period(Date start, Date end) { this.start = new Date(start.getTime()); this.end = new Date(end.getTime()); if (this.start.compareTo(this.end) \u0026gt; 0) throw new IllegalArgumentException(tart + \u0026#34; after \u0026#34; + end); } public Date start () { return new Date(start.getTime()); } public Date end () { return new Date(end.getTime()); } public String toString() { return start + \u0026#34; - \u0026#34; + end; } ... }   Period에 기본 직렬화 방법을 이용하면 주요한 불변식을 더는 보장하지 못하게 된다. readObject 메서드가 실질적으로 또 다른 public 생성자이기 때문이다. readObject는 매개변수로 바이트 스틤을 받는 생성자라고 할 수 있다. 불변식을 깨디를 의도로 임의 생성한 바이트 스트림을 건네면 정상적인 생성자로는 만들어낼 수 없는 객체를 생성해 낼 수 있기 떄문이다.\n이러한 문제를 해결하려면 Period의 readObject 메서드가 defaultReadObject를 호출한 다음 역직렬화된 객체가 유효한지 검사해야한다. 유효성 검사에 실패하면 InvalidObjectException을 던져서 역직렬화를 막을 수 있다.\n1 2 3 4 5 6 7 8  // 유효성 검사를 수행하는 readObject method - 아직 부족하다 private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException { s.defaultReadObject(); // 불변식을 만족하는지 검사한다  if (start.compareTo(end) \u0026gt; 0) throw new InvalidObjectException(start +\u0026#34; after \u0026#34;+ end); }   아직 맹점이 남아 있다. 정상 Period 인스턴스에서 시작된 바이트 스트림 끝에 private Date 필드로의 참조를 추가하면 가변 Period 인스턴스를 만들어낼 수 있다. ObjectInpuStream에서 Period 인스턴스를 읽은 후 스트림 끝에 추가된 악의적인 참조를 읽어 Period객체의 내부 정보를 얻을 수 있다.\n이제 이 참조로 얻은 Date 인스턴스들은 수정할 수 있어서 Period는 더는 불변이 아니게 된다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  // 가변 공격의 예 public class MutablePeriod { public final Period period; public final Date start; public final Date end; public MutablePeriod() { try { ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream out = new ObjectOutputStream(bos); // 유효한 Period 인스턴스를 직렬화한다.  out.writeObject(new Period(new Date(), new Date())); /* * 악의적인 \u0026#39;이진 객체 참조\u0026#39;, 즉 내부 Date 피드로의 참조를 추가한다. */ byte[] ref = {0x71, 0, 0x7e, 0, 5}; // 참조 #5  bos.write(ref); // 시작(start) 필드  ref[4] = 4; // 참조 #4  out.write(ref); // 종료(end) 필드  // Period 역직렬화 후 Date 참조룰 \u0026#39;훔친다\u0026#39;  ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(bos.toByteArray())); period = (Period) in.readObject(); start = (Date) in.readObject(); end = (Date) in.readObject(); } catch (ClassNotFoundException | IOException e) { throw new AssertionError(e); } } }   실제 공격이 이루어지는 코드\n1 2 3 4 5 6 7 8 9 10 11 12 13  public static void main(String[] args) { MutablePeriod mp = new MutablePeriod(); Period p = mp.period; Date pEnd = mp.end; // 시간을 되돌리자  pEnd.setYear(78); System.out.println(p); // 60년대로 회귀  pEnd.setYear(69); System.out.println(p); }   심각한 보안 문제로 이어질 수 있다. 실제로 보안 문제를 String이 불변이라는 사실에 기댄 클래스들이 존재하기 많기 때문에 극단적인 예제라고 볼 수 없다. 객체를 역직렬화할 때는 클라이언트가 소유해서는 안 되는 객체 참조를 갖는 필드를 모두 반드시 방어적으로 복사해야한다. 띠리사 readObject에서는 불변 클래스 안의 모든 private 가변 요소를 방어적으로 복사해야한다.\n1 2 3 4 5 6 7 8 9 10 11 12  // 방어적 복사와 유효성 검사를 수행하는 readObject 메서드 private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException { s.defaultReadObject(); // 가변 요소를 방어적으로 복사한다.  start = new Date(start.getTime()); end = new Date(end.getTime()); // 불변식을 만족하는지 검사  if (start.compareTo(end) \u0026gt; 0) throw new InvalidObjectException(start +\u0026#34; after \u0026#34;+ end); }   final 필드는 방어적 복사가 불가능하다. 따라서 start와 end 필드에 final을 제거해야한다.\n기본 readObject 메서드를 사용해도 괜찮을 때\n transient 필드를 제외한 모든 필드의 값을 매개변수로 받아 유효성 검사 없이 필드에 대입하는 public 생성자를 추가해도 괜찮을 때  ","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-11/item88/","summary":"[아이템 88] readObject 메서드는 방어적으로 작성하라. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  // 방어적 복사를 사용하는 불변 클ㄹ스  public final class Period { private final Date start; private final Date end; /** * @param start 시작 시간 * @param end 종료 시각. 시작 시간보다 뒤어야 한다 * @throws IllegalArgumentException 시작 시간이 종료 시간보다 늦을 때 발생한다 * @throws NullPointerException start나 end가 null일시 발생 */ public Period(Date start, Date end) { this.","title":""},{"content":"[아이템 89] 인스턴스 수를 통제해야 한다면 readResolve 보단는 열거타입을 사용하라. 1 2 3 4 5 6 7  // 싱글턴 public class Elvis { public static final Elvis INSTANCE = new Elvis(); private Elvis() { ... } public void leaveTheBuilding() { ... } }   Serializable을 구현하는 순간 더이상 싱글턴이 아니다. 어떤 readObject를 사용하든 초기화될때 만들어진 인스턴스와는 별개인 인스턴스를 반환하게 된다.\nreadResolve 기능을 활용하면 readObject가 만들어낸 인스턴스를 다른 것으로 대체할 수 있다\n1 2 3 4 5 6  // 인스턴스 통제를 위한 readResolve - 개선의 여지가 있다. private Object readResolve() { // wlsWK Elvis를 반환하고, 가짜 Elvis는 가비지 컬렉터에 맡긴다.  return INSTANCE; }   readResolve를 인스턴스 통제 목적으로 사용한다면 객체 참조 타입 인스턴스 필드는 모두 transient로 선언해야 한다. 그렇지 않으면 역직렬화된 객체의 참조를 공격할 여지가 남는다.\n싱글턴이 transient가 아닌 참조 필드를 갖고 있다면, 그 필드의 내용은 readResolve 메서드가 실행되기 전에 역직렬화된다. 그렇다면 잘 조작된 스트림을 써서 참조 필드의 내용이 역직렬화 되는 시점에 그 역직렬화된 인스턴스의 참조를 훔쳐올 수 있다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  // 잘못된 싱글턴 - transient가 아닌 참조 필드를 가지고 있다. public class Elvis implements Serializable { public static final Elvis INSTANCE = new Elvis(); private Elvis() { } private String[] favoriteSongs = { \u0026#34;Hound Dog\u0026#34;, \u0026#34;Heartbreak Hotel\u0026#34; }; public void printFavorites() { System.out.println(Arrays.toString(favoriteSongs)); } private Object readResolve() { return INSTANCE; } }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  // 도둑 클래스  public class ElvisStealer implements Serializable { static Elvis impersonator; private Elvis payload; private Object readResolve() { // resolve되기 전에 Elvis 인스턴스의 참조를 저장한ㄷ.  impersonator = payload; // favoriteSongs 필드에 맞는 타입의 객체를 반환한다..  return new String[] { \u0026#34;A Fool Such as I\u0026#34; }; } private static final long serialVersionUID = 0; }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  // 직렬화의 허점을 이용해 싱글턴 객체를 2개 생성한다 public class ElvisImpersonator { // 진짜 Elvis 인스턴스로는 만들어질 수 없는 바이트 스트림.  private static final byte[] serializedForm = { (byte)0xac, (byte)0xed, 0x00, 0x05, 0x73, 0x72, 0x00, 0x05, 0x45, 0x6c, 0x76, 0x69, 0x73, (byte)0x84, (byte)0xe6, (byte)0x93, 0x33, (byte)0xc3, (byte)0xf4, (byte)0x8b, 0x32, 0x02, 0x00, 0x01, 0x4c, 0x00, 0x0d, 0x66, 0x61, 0x76, 0x6f, 0x72, 0x69, 0x74, 0x65, 0x53, 0x6f, 0x6e, 0x67, 0x73, 0x74, 0x00, 0x12, 0x4c, 0x6a, 0x61, 0x76, 0x61, 0x2f, 0x6c, 0x61, 0x6e, 0x67, 0x2f, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x3b, 0x78, 0x70, 0x73, 0x72, 0x00, 0x0c, 0x45, 0x6c, 0x76, 0x69, 0x73, 0x53, 0x74, 0x65, 0x61, 0x6c, 0x65, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x01, 0x4c, 0x00, 0x07, 0x70, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64, 0x74, 0x00, 0x07, 0x4c, 0x45, 0x6c, 0x76, 0x69, 0x73, 0x3b, 0x78, 0x70, 0x71, 0x00, 0x7e, 0x00, 0x02 }; public static void main(String[] args) { // ElvisStealer.impersonator를 초기화 한 다음, 진짜 Elvis(Elvis.INSTANCE)를 반환  Elvis elvis = (Elvis) deserialize(serializedForm); Elvis impersonator = ElvisStealer.impersonator; elvis.printFavorites(); impersonator.printFavorites(); } }   출력 결과. 서로 다른 2개의 인스턴스를 생성할 수 있음을 증명했다.\n [Hound Dog, Heartbreak Hotel] [A Fool Such as I]\n 1 2 3 4 5 6 7 8 9  // 열거 타임 싱글턴 - 전통적인 싱글턴보다 우수하다. public enum Elvis { INSTANCE; private String[] favoriteSongs = { \u0026#34;Hound Dog\u0026#34;, \u0026#34;Heartbreak Hotel\u0026#34; }; public void printFavorites() { System.out.println(Arrays.toString(favoriteSongs)); } }   ","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-11/item89/","summary":"[아이템 89] 인스턴스 수를 통제해야 한다면 readResolve 보단는 열거타입을 사용하라. 1 2 3 4 5 6 7  // 싱글턴 public class Elvis { public static final Elvis INSTANCE = new Elvis(); private Elvis() { ... } public void leaveTheBuilding() { ... } }   Serializable을 구현하는 순간 더이상 싱글턴이 아니다. 어떤 readObject를 사용하든 초기화될때 만들어진 인스턴스와는 별개인 인스턴스를 반환하게 된다.\nreadResolve 기능을 활용하면 readObject가 만들어낸 인스턴스를 다른 것으로 대체할 수 있다","title":""},{"content":"[아이템 90] 직렬화된 인스턴스 대신 직렬화 프록시 사용을 검토하라. 직렬화 프록시 패턴을 이용하면 앞서 애기했던 단점들을 줄일 수 있다.먼저 바깥 클래스의 논리적인 상태를 표현하는 중첩 클래스를 private static으로 생성한다. 이 중첩 클래스가 바깥 클래스의 직렬화 프록시다. 이 클래스는 단순히 인스로 넘어온 인스턴스의 데이터만 복사하고 바깥 클래스와 모두 Serializable을 구현해야한다.\n1 2 3 4 5 6 7 8 9 10 11  // Period 클래스용 직렬화 프록시 private static class SerializationProxy implements Serializable { private final Date start; private final Date end; SerializationProxy(Period p) { this.start = p.start; this.end = p.end; } private static final long serialVersionUID = 234098243823485285L; // do (Item 87) }   다음은 바깥 클래스에 다음의 writeReplace 메서드를 추가한다. 직렬화 프록시를 사용하는 모든 클래스에서 그대로 사용하면 된다.\n1 2 3 4  // 직려롸 프록시 패턴용 writeReplace 메서드 private Object writeReplace() { return new SerializationProxy(this); }   이 메서드는 직렬화가 이뤄지기 전에 바깥 클래스의 인스턴스를 직렬화 프록시로 변환해준다. writeReplace 결코 바깥 클래스의 직렬화된 인스턴스를 생성해낼 수 없다.\n1 2 3 4  // readObject를 바깥 클래스에 추가. ( 불변 훼손 공격 방어) private void readObject(ObjectInputStream stream) throws InvalidObjectException { throw new InvalidObjectException(\u0026#34;Proxy required\u0026#34;); }   마지막으로 바깥 클래스와 논리적으로 동일한 인스턴스를 반환하는 readResolve 메서드를 SerializationProxy 클래스에 추가한다. 이 메서드는 역직렬화 시에 직렬화 시스템이 직렬화 프록시를 다시 바깥 클래스의 인스턴스로 변환하게 해준다.\n따라서 불변식을 만족하는 검사를 하지 않아도 된다.\n1 2 3 4 5  // Period.SerializationProxy용 readObject메서드  private Object readResolve() { return new Period(start, end); // public constructor 사용. }   프록시 수준에서 내부 필드 탈취 공격을 차단해준다. 또한 필드에 final을 선언해도 돼서 Period 클래스를 진정한 불변으로 만들 수 있다. 또한 직렬화 프록시 패턴은 역직렬화한 인스턴스와 원래의 직렬화된 인스턴스의 클래스가 달라도 정상 작동한다.\n프록시 패턴의 한계\n 클라이언트가 멋대로 확장할 수 있는 클래스에는 적용할 수 없다. 객체 그래프에서 순환이 있는 클래스에도 적용할 수 없다. 성능이 느리다.  ","permalink":"https://qutrits.github.io/posts/effective-java-3e/chapter-11/item90/","summary":"[아이템 90] 직렬화된 인스턴스 대신 직렬화 프록시 사용을 검토하라. 직렬화 프록시 패턴을 이용하면 앞서 애기했던 단점들을 줄일 수 있다.먼저 바깥 클래스의 논리적인 상태를 표현하는 중첩 클래스를 private static으로 생성한다. 이 중첩 클래스가 바깥 클래스의 직렬화 프록시다. 이 클래스는 단순히 인스로 넘어온 인스턴스의 데이터만 복사하고 바깥 클래스와 모두 Serializable을 구현해야한다.\n1 2 3 4 5 6 7 8 9 10 11  // Period 클래스용 직렬화 프록시 private static class SerializationProxy implements Serializable { private final Date start; private final Date end; SerializationProxy(Period p) { this.","title":""}]